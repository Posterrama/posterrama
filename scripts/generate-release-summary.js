#!/usr/bin/env node
/**
 * Generates (or refreshes) private/release-check-summary.md from latest data:
 * - Reads jest-results.json if present for test count
 * - Reads coverage summary (coverage/coverage-final.json) for metrics
 * - Reads package.json version
 * - Emits a standardized markdown summary
 * NOTE: File lives under private/ (ignored by git by default)
 */
const fs = require('fs');
const path = require('path');

function readJSON(p, fallback) {
    try {
        return JSON.parse(fs.readFileSync(p, 'utf8'));
    } catch (e) {
        return fallback;
    }
}

const root = process.cwd();
const pkg = readJSON(path.join(root, 'package.json'), {});
const jestRaw = readJSON(path.join(root, 'jest-results.json'), {});
const coverage = readJSON(path.join(root, 'coverage', 'coverage-final.json'), {});

// Aggregate coverage numbers
function summarizeCoverage(cov) {
    if (!cov || typeof cov !== 'object') return null;
    let totalLines = 0,
        coveredLines = 0,
        totalStmts = 0,
        coveredStmts = 0,
        totalFns = 0,
        coveredFns = 0,
        totalBranches = 0,
        coveredBranches = 0;
    for (const file of Object.values(cov)) {
        if (!file || !file.l) continue;
        // lines
        for (const hits of Object.values(file.l)) {
            totalLines += 1;
            if (hits > 0) coveredLines += 1;
        }
        // statements
        if (file.s) {
            for (const hits of Object.values(file.s)) {
                totalStmts += 1;
                if (hits > 0) coveredStmts += 1;
            }
        }
        // functions
        if (file.f) {
            for (const hits of Object.values(file.f)) {
                totalFns += 1;
                if (hits > 0) coveredFns += 1;
            }
        }
        // branches
        if (file.b) {
            for (const arr of Object.values(file.b)) {
                totalBranches += arr.length;
                coveredBranches += arr.filter(h => h > 0).length;
            }
        }
    }
    const pct = (c, t) => (t ? ((c / t) * 100).toFixed(2) : '0.00');
    return {
        lines: pct(coveredLines, totalLines),
        statements: pct(coveredStmts, totalStmts),
        functions: pct(coveredFns, totalFns),
        branches: pct(coveredBranches, totalBranches),
        counts: { coveredLines, totalLines },
    };
}

const covSummary = summarizeCoverage(coverage);
const testsTotal = Array.isArray(jestRaw.testResults)
    ? jestRaw.testResults.reduce((a, s) => a + (s.assertionResults?.length || 0), 0)
    : undefined;

const now = new Date();
const dateStr = now.toISOString().slice(0, 10);

const lines = [];
lines.push(`# Release Check Summary (Generated)`);
lines.push('');
lines.push(`Date: ${dateStr}`);
lines.push(`Package version: ${pkg.version || 'unknown'}`);
if (testsTotal !== undefined) lines.push(`Total tests (from jest-results.json): ${testsTotal}`);
if (covSummary) {
    lines.push('');
    lines.push('## Coverage');
    lines.push(
        `- Lines: ${covSummary.lines}% (${covSummary.counts.coveredLines}/${covSummary.counts.totalLines})`
    );
    lines.push(`- Statements: ${covSummary.statements}%`);
    lines.push(`- Functions: ${covSummary.functions}%`);
    lines.push(`- Branches: ${covSummary.branches}%`);
}
lines.push('');
lines.push('## Notes');
lines.push('- This file is regenerated by scripts/generate-release-summary.js');
lines.push(
    '- It uses the latest existing artifacts; run your full quality pipeline first for up-to-date numbers.'
);

const outPath = path.join(root, 'private', 'release-check-summary.md');
try {
    fs.mkdirSync(path.join(root, 'private'), { recursive: true });
    fs.writeFileSync(outPath, lines.join('\n') + '\n', 'utf8');
    console.log('Updated', outPath);
} catch (e) {
    console.error('Failed to write release summary:', e.message);
    process.exitCode = 1;
}
