/* Admin v2 Dashboard (theme-based) */
// NOTE: Removed blanket 'eslint-disable no-empty'; empty catches now annotated with purpose.
/* global saveConfigPatch, miniCache, inflight, refreshOverviewLastSync */
/* global initMsForSelect, rebuildMsForSelect, getMultiSelectValues, fetchPlexLibraries */
/* global fetchJellyfinLibraries, populatePosterpackLibraries */
(function () {
    const $ = (sel, root = document) => root.querySelector(sel);

    // Posterpack debug logger removed

    // ---- Diagnostic Sentinel (notifications resilience) ----
    // Provides quick confirmation in the browser console that the latest admin.js has loaded.
    // Type:  __diagUI   or  window.__diagUI.showScripts()  in DevTools.
    try {
        // Directory modal UI removed (fixed 'media' root)
        // Minimal diagnostic helpers for modals (safe to keep in production)
        window.__diagUI = window.__diagUI || {};
        window.__diagUI.modalInfo = function modalInfo(id) {
            try {
                const el = document.getElementById(id);
                if (!el) return { exists: false };
                const r = el.getBoundingClientRect();
                return {
                    exists: true,
                    id,
                    classes: [...el.classList],
                    rect: r.toJSON(),
                    portal: el.hasAttribute('data-portal'),
                    hiddenAttr: el.hasAttribute('hidden'),
                    ariaHidden: el.getAttribute('aria-hidden'),
                    open: el.classList.contains('open'),
                    parent: el.parentElement?.id || el.parentElement?.className,
                };
            } catch (e) {
                return { error: e?.message };
            }
        };
        window.__diagUI.openModalTest = function openModalTest(id) {
            try {
                window.openModal?.(id);
                return window.__diagUI.modalInfo(id);
            } catch (e) {
                return { error: e?.message };
            }
        };
        // Clear any previous log guard to ensure visibility
        // Removed admin boot sentinel log (was noisy in production)
        try {
            window.__adminTrace = window.__adminTrace || [];
            window.__adminTrace.push('after:sentinel');
        } catch (_) {
            /* adminTrace push is best-effort (localStorage/memory issues) */
        }
        // Portal watchdog (deferred): only repairs after user opens panel at least once to avoid auto-open side effect
        try {
            if (!window.__notifPortalWatch) {
                window.__notifPortalWatch = setInterval(() => {
                    try {
                        const panel = document.getElementById('notify-center');
                        if (!panel) return;
                        if (!window.__notifUserOpenedOnce) return; // do nothing until user has opened
                        if (!panel.classList.contains('open')) return; // only enforce when meant to be visible
                        const r = panel.getBoundingClientRect();
                        if (r.width === 0 || r.height === 0) {
                            if (panel.parentElement !== document.body) {
                                document.body.appendChild(panel);
                                panel.setAttribute('data-portal', 'true');
                                console.warn(
                                    '[NotifDebug] watchdog moved panel to body (post-open)'
                                );
                            }
                            window.__ensureVisible?.(panel, 'notify');
                        } else if (window.__notifUserOpenedOnce) {
                            // Once we have a healthy rect after user interaction we can retire the watchdog
                            clearInterval(window.__notifPortalWatch);
                            window.__notifPortalWatch = null;
                            console.info('[NotifDebug] portal watchdog retired (healthy)');
                        }
                    } catch (e) {
                        console.warn('[NotifDebug] portal watchdog error', e);
                    }
                }, 1200);
            }
        } catch (_) {
            /* portal watchdog setup failed; resilience feature only */
        }
        // NOTE: portal watchdog is a resilience fallback. Can be removed once root cause of zero-size containment is permanently fixed.
    } catch (diagErr) {
        /* admin diag helper init failed (suppressed) */
    }

    // Early fallback binding for notification button (before heavy logic) so we at least log clicks.
    try {
        const earlyNotifBtn = document.getElementById('notif-btn');
        if (earlyNotifBtn && !earlyNotifBtn.__earlyBound) {
            earlyNotifBtn.__earlyBound = true;
            earlyNotifBtn.addEventListener('click', ev => {
                // If main delegation later also handles it, this simply adds extra debug once.
                console.debug('[EarlyNotifBinding] click captured');
                // Mark the event for downstream logic
                ev.__fromNotifBtn = true;
            });
        }
    } catch (e) {
        console.warn('[EarlyNotifBinding] failed', e);
    }

    // Small utility: debounce
    function debounce(fn, wait = 120) {
        let t;
        return function debounced(...args) {
            const self = this;
            if (t) clearTimeout(t);
            t = setTimeout(() => fn.apply(self, args), wait);
        };
    }

    // Fallback for update polling if not provided by this build
    if (typeof window.pollUpdateStatusOnce !== 'function') {
        window.pollUpdateStatusOnce = async function () {
            return null;
        };
    }

    function setText(id, val) {
        const el = typeof id === 'string' ? document.getElementById(id) : id;
        if (el) el.textContent = val;
    }
    function formatNumber(n) {
        const num = Number(n);
        return Number.isFinite(num) ? num.toLocaleString() : '—';
    }

    // Returns true when the given ISO date falls on the current local day
    /* eslint-disable no-unused-vars */
    function isToday(iso) {
        if (!iso) return false;
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return false;
        const now = new Date();
        return (
            d.getFullYear() === now.getFullYear() &&
            d.getMonth() === now.getMonth() &&
            d.getDate() === now.getDate()
        );
    }
    /* eslint-enable no-unused-vars */

    // Safe fallback meter renderer used by cache/perf panels
    function setMeter(id, pct /* 0-100 */, kind = 'default') {
        const el = typeof id === 'string' ? document.getElementById(id) : id;
        if (!el) return;
        const v = Math.max(0, Math.min(100, Number(pct) || 0));

        // Set width for progress bar
        el.style.width = `${v}%`;

        // Dynamic color based on percentage and kind
        let gradient = '';
        if (kind === 'danger' || v >= 90) {
            gradient = 'linear-gradient(90deg,#ff4d4f,#ff7875)';
        } else if (kind === 'warn' || v >= 70) {
            gradient = 'linear-gradient(90deg,#faad14,#ffc53d)';
        } else if (kind === 'ok' || v >= 40) {
            gradient = 'linear-gradient(90deg,#52c41a,#73d13d)';
        } else {
            gradient = 'linear-gradient(90deg,#1890ff,#40a9ff)';
        }
        el.style.background = gradient;
    }

    function formatBytes(bytes) {
        if (!bytes && bytes !== 0) return '—';
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let i = 0;
        let b = bytes;
        while (b >= 1024 && i < units.length - 1) {
            b /= 1024;
            i++;
        }
        return `${b.toFixed(1)} ${units[i]}`;
    }

    // Simple HTML escaper available at module scope for safe rendering
    function escapeHtml(s) {
        return String(s || '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    // Small helper for JSON fetch with credentials and error propagation
    async function fetchJSON(url, opts = {}) {
        const res = await fetch(url, { credentials: 'include', ...opts });
        const text = await res.text();
        let json = null;
        try {
            json = text ? JSON.parse(text) : null;
        } catch (_) {
            /* ignore parse */
        }
        if (!res.ok) {
            const err = new Error(json?.error || `HTTP ${res.status}`);
            err.status = res.status;
            err.data = json || text;
            throw err;
        }
        return json;
    }

    // Multiselect helper functions (moved to top-level scope to fix lint errors)
    function __closeAllMsExcept(exceptRoot = null) {
        try {
            document.querySelectorAll('.multiselect.ms-open').forEach(el => {
                if (exceptRoot && el === exceptRoot) return;
                el.classList.remove('ms-open');
                const ctrl = el.querySelector('.ms-control');
                if (ctrl) ctrl.setAttribute('aria-expanded', 'false');
                // Do not force menu.style.display; CSS tied to .ms-open handles visibility
            });
        } catch (_) {
            /* ignore: __closeAllMsExcept cleanup loop failures (DOM mutation during iteration) */
        }
    }
    function initMsForSelect(idBase, selectId) {
        const sel = document.getElementById(selectId);
        const root = document.getElementById(`${idBase}`);
        if (!sel || !root) return;
        if (root.dataset.msWired === 'true') return; // listeners already attached; use rebuildMsForSelect() to refresh options
        const control = root.querySelector('.ms-control');
        const chipsEl = root.querySelector('.ms-chips');
        const menu = document.getElementById(`${idBase}-menu`);
        const optsEl = document.getElementById(`${idBase}-options`);
        const search = document.getElementById(`${idBase}-search`);
        const clear = document.getElementById(`${idBase}-clear`);
        const selectAll = document.getElementById(`${idBase}-select-all`);
        const clearAll = document.getElementById(`${idBase}-clear-all`);
        if (!control || !chipsEl || !menu || !optsEl || !search || !selectAll || !clearAll) return;

        const getSelected = () => new Set(Array.from(sel.selectedOptions).map(o => o.value));
        const setSelected = valsSet => {
            const vals = new Set(valsSet);
            Array.from(sel.options).forEach(o => {
                o.selected = vals.has(o.value);
            });
            sel.dispatchEvent(new Event('change', { bubbles: true }));
        };
        const renderChips = () => {
            const selected = getSelected();
            chipsEl.innerHTML = '';
            selected.forEach(v => {
                const label = Array.from(sel.options).find(o => o.value === v)?.textContent || v;
                const chip = document.createElement('span');
                chip.className = 'ms-chip';
                chip.dataset.value = v;
                chip.innerHTML = `${label} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
                chip.querySelector('.ms-chip-remove')?.addEventListener('click', e => {
                    e.stopPropagation();
                    const s = getSelected();
                    s.delete(v);
                    setSelected(s);
                    syncOptions();
                    renderChips();
                    control.classList.toggle('has-selection', s.size > 0);
                });
                chipsEl.appendChild(chip);
            });
            control.classList.toggle('has-selection', selected.size > 0);
        };
        const syncOptions = () => {
            const selected = getSelected();
            Array.from(optsEl.children).forEach(row => {
                const v = row.dataset.value;
                const cb = row.querySelector('input[type="checkbox"]');
                if (cb) cb.checked = selected.has(v);
            });
        };
        const buildOptions = () => {
            optsEl.innerHTML = '';
            const items = Array.from(sel.options).map(o => ({
                value: o.value,
                label: o.textContent,
            }));
            items.forEach(it => {
                const row = document.createElement('div');
                row.className = 'ms-option';
                row.dataset.value = it.value;
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                const span = document.createElement('span');
                span.textContent = it.label;
                row.appendChild(cb);
                row.appendChild(span);
                optsEl.appendChild(row);
            });
            syncOptions();
        };
        const filterOptions = q => {
            const qq = (q || '').toLowerCase();
            Array.from(optsEl.children).forEach(child => {
                const label = child.querySelector('span')?.textContent?.toLowerCase() || '';
                child.style.display = label.includes(qq) ? '' : 'none';
            });
        };
        const openMenu = open => {
            root.classList.toggle('ms-open', !!open);
            control.setAttribute('aria-expanded', open ? 'true' : 'false');
            if (open) {
                // Auto-fetch libraries when opening Plex/Jellyfin library multiselects
                if (selectId === 'plex.movies' || selectId === 'plex.shows') {
                    // Fetch Plex libraries if not already loaded
                    if (window.__plexLibsFetchNeeded !== false) {
                        window.__plexLibsFetchNeeded = false;
                        (async () => {
                            try {
                                if (typeof window.__fetchPlexLibraries === 'function') {
                                    await window.__fetchPlexLibraries(true, true);
                                }
                            } catch (_) {
                                /* plex libraries fetch failed (auto-load on open) */
                            }
                        })();
                    }
                } else if (selectId === 'jf.movies' || selectId === 'jf.shows') {
                    // Fetch Jellyfin libraries if not already loaded
                    if (window.__jfLibsFetchNeeded !== false) {
                        window.__jfLibsFetchNeeded = false;
                        (async () => {
                            try {
                                if (typeof window.__fetchJellyfinLibraries === 'function') {
                                    await window.__fetchJellyfinLibraries(true, true);
                                }
                            } catch (_) {
                                /* jellyfin libraries fetch failed (auto-load on open) */
                            }
                        })();
                    }
                }

                // Ensure only one dropdown is open at a time
                __closeAllMsExcept(root);
                try {
                    if (menu) menu.scrollTop = 0;
                    if (optsEl) optsEl.scrollTop = 0;
                    // If options are empty but backing <select> has items, rebuild on-the-fly
                    if (optsEl && optsEl.children.length === 0 && sel && sel.options.length > 0) {
                        // Clear any stale search text
                        if (search) search.value = '';
                        buildOptions();
                        // Ensure all rows visible
                        Array.from(optsEl.children).forEach(ch => (ch.style.display = ''));
                    } else if (optsEl && optsEl.children.length > 0) {
                        // If rows exist but all are hidden (old filter), clear filter and unhide
                        const hiddenCount = Array.from(optsEl.children).filter(
                            ch => ch.style.display === 'none'
                        ).length;
                        if (hiddenCount === optsEl.children.length) {
                            if (search) search.value = '';
                            Array.from(optsEl.children).forEach(ch => (ch.style.display = ''));
                        }
                    }
                } catch (e) {
                    // scroll reset failed
                }
            }
        };
        // Handlers
        const clearBtn = document.getElementById(`${idBase}-clear`);
        clearBtn?.addEventListener('mousedown', e => {
            e.stopPropagation();
        });
        // Guard to avoid double-toggle when both mousedown and click fire
        let lastPointerDownTs = 0;
        // Open on mousedown (primary path)
        control.addEventListener('mousedown', e => {
            e.preventDefault();
            e.stopPropagation();
            lastPointerDownTs = Date.now();
            // Close all other multiselects before opening this one
            __closeAllMsExcept(root);
            const willOpen = !root.classList.contains('ms-open');
            openMenu(willOpen);
            if (willOpen) setTimeout(() => search.focus(), 0);
        });
        // Open on click as a fallback (e.g., keyboard-generated click); ignore if it immediately follows a mousedown
        control.addEventListener('click', e => {
            e.preventDefault();
            e.stopPropagation();
            if (Date.now() - lastPointerDownTs < 300) return; // ignore synthetic click after mousedown
            __closeAllMsExcept(root);
            const willOpen = !root.classList.contains('ms-open');
            openMenu(willOpen);
            if (willOpen) setTimeout(() => search.focus(), 0);
        });
        // Keyboard access: Enter/Space toggles, Escape closes
        control.addEventListener('keydown', e => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                e.stopPropagation();
                const willOpen = !root.classList.contains('ms-open');
                openMenu(willOpen);
                if (willOpen) setTimeout(() => search.focus(), 0);
            } else if (e.key === 'Escape') {
                openMenu(false);
            }
        });
        document.addEventListener('click', e => {
            // If click is outside this multiselect and its menu, close only this one
            const insideThis = root.contains(e.target) || (menu && menu.contains(e.target));
            if (!insideThis) openMenu(false);
        });
        search.addEventListener('focus', () => openMenu(true));
        search.addEventListener('keydown', e => {
            if (e.key === 'Escape') openMenu(false);
        });
        search.addEventListener('input', () => filterOptions(search.value));
        selectAll.addEventListener('click', e => {
            e.preventDefault();
            const all = new Set(Array.from(sel.options).map(o => o.value));
            setSelected(all);
            syncOptions();
            renderChips();
        });
        clearAll.addEventListener('click', e => {
            e.preventDefault();
            setSelected(new Set());
            syncOptions();
            renderChips();
            search.value = '';
            filterOptions('');
        });
        clear?.addEventListener('click', e => {
            e.preventDefault();
            setSelected(new Set());
            syncOptions();
            renderChips();
            search.value = '';
            filterOptions('');
        });
        optsEl.addEventListener('click', e => {
            const row = e.target.closest('.ms-option');
            if (!row) return;
            const v = row.dataset.value;
            const selected = getSelected();
            if (selected.has(v)) selected.delete(v);
            else selected.add(v);
            setSelected(selected);
            syncOptions();
            renderChips();
        });
        // Initial paint
        buildOptions();
        renderChips();
        root.dataset.msWired = 'true';
    }

    function rebuildMsForSelect(idBase, selectId) {
        const sel = document.getElementById(selectId);
        const root = document.getElementById(`${idBase}`);
        if (!sel || !root) return;
        if (root.dataset.msWired !== 'true') {
            // Not wired yet; initialize now
            initMsForSelect(idBase, selectId);
            return;
        }
        const control = root.querySelector('.ms-control');
        const chipsEl = root.querySelector('.ms-chips');
        const optsEl = document.getElementById(`${idBase}-options`);
        const search = document.getElementById(`${idBase}-search`);
        if (!control || !chipsEl || !optsEl) return;
        // Build options from current <select>
        const selected = new Set(Array.from(sel.selectedOptions).map(o => o.value));
        optsEl.innerHTML = '';
        const items = Array.from(sel.options).map(o => ({
            value: o.value,
            label: o.textContent,
        }));
        items.forEach(it => {
            const row = document.createElement('div');
            row.className = 'ms-option';
            row.dataset.value = it.value;
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = selected.has(it.value);
            const span = document.createElement('span');
            span.textContent = it.label;
            row.appendChild(cb);
            row.appendChild(span);
            optsEl.appendChild(row);
        });
        // Clear any lingering search/filter and unhide all rows
        if (search) search.value = '';
        Array.from(optsEl.children).forEach(ch => (ch.style.display = ''));
        // Render chips
        chipsEl.innerHTML = '';
        selected.forEach(v => {
            const label = Array.from(sel.options).find(o => o.value === v)?.textContent || v;
            const chip = document.createElement('span');
            chip.className = 'ms-chip';
            chip.dataset.value = v;
            chip.innerHTML = `${label} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
            chip.querySelector('.ms-chip-remove')?.addEventListener('click', e => {
                e.stopPropagation();
                // Update select
                Array.from(sel.options).forEach(o => {
                    if (o.value === v) o.selected = false;
                });
                // Recurse to refresh options and chips
                rebuildMsForSelect(idBase, selectId);
                control.classList.toggle('has-selection', sel.selectedOptions.length > 0);
                sel.dispatchEvent(new Event('change', { bubbles: true }));
            });
            chipsEl.appendChild(chip);
        });
        control.classList.toggle('has-selection', selected.size > 0);
    }

    // Resilient late-binding: ensure known multiselects are wired even if earlier init missed
    function __ensureMsWired(idBase, selectId) {
        try {
            const root = document.getElementById(idBase);
            const sel = document.getElementById(selectId);
            if (!root || !sel) return;
            if (root.dataset.msWired === 'true') return;
            initMsForSelect(idBase, selectId);
        } catch (_) {
            /* ensureMsWired: multiselect late init failed (missing elements) */
        }
    }
    // Forward declaration for linter (defined later)
    function loadPosterpackServerFilterOptions() {}

    function __ensureAllMultiselects() {
        // Media Sources (main panels)
        __ensureMsWired('plex-ms-movies', 'plex.movies');
        __ensureMsWired('plex-ms-shows', 'plex.shows');
        __ensureMsWired('jf-ms-movies', 'jf.movies');
        __ensureMsWired('jf-ms-shows', 'jf.shows');
        // Posterpack section
        __ensureMsWired('pp-plex-ms-movies', 'pp-plex.movies');
        __ensureMsWired('pp-plex-ms-shows', 'pp-plex.shows');
        __ensureMsWired('pp-jf-ms-movies', 'pp-jf.movies');
        __ensureMsWired('pp-jf-ms-shows', 'pp-jf.shows');
        // Posterpack server filters (ratings/genres/qualities)
        __ensureMsWired('pp-srv-ms-ratings', 'pp-server.ratings');
        __ensureMsWired('pp-srv-ms-genres', 'pp-server.genres');
        __ensureMsWired('pp-srv-ms-qualities', 'pp-server.qualities');
        try {
            loadPosterpackServerFilterOptions().catch(() => {});
        } catch (_) {
            /* posterpack filter multiselect wiring on DOM ready failed (non-fatal) */
        }
    }
    try {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () =>
                setTimeout(__ensureAllMultiselects, 0)
            );
        } else {
            setTimeout(__ensureAllMultiselects, 0);
        }
        window.addEventListener('hashchange', () => setTimeout(__ensureAllMultiselects, 35));
        window.addEventListener('panelActivated', () => setTimeout(__ensureAllMultiselects, 25));
    } catch (_) {
        /* initial admin bootstrap cosmetic hook failed */
    }

    function ensureLibrarySelectionIntegrity(source) {
        try {
            if (source === 'plex') {
                if (!window.__plexAutoSelected) return;
                if (window.__plexUserModifiedSelection) return; // don't override user edits
                const mSel = document.getElementById('plex.movies');
                const sSel = document.getElementById('plex.shows');
                if (!mSel || !sSel) return;
                const hasAny = mSel.selectedOptions.length > 0 || sSel.selectedOptions.length > 0;
                if (!hasAny) {
                    const allMovies = Array.from(mSel.options).map(o => o.value);
                    const allShows = Array.from(sSel.options).map(o => o.value);
                    allMovies.forEach(v => {
                        const opt = Array.from(mSel.options).find(o => o.value === v);
                        if (opt) opt.selected = true;
                    });
                    allShows.forEach(v => {
                        const opt = Array.from(sSel.options).find(o => o.value === v);
                        if (opt) opt.selected = true;
                    });
                    mSel.dispatchEvent(new Event('change', { bubbles: true }));
                    sSel.dispatchEvent(new Event('change', { bubbles: true }));
                    rebuildMsForSelect('plex-ms-movies', 'plex.movies');
                    rebuildMsForSelect('plex-ms-shows', 'plex.shows');
                }
            } else if (source === 'jellyfin') {
                if (!window.__jfAutoSelected) return;
                if (window.__jfUserModifiedSelection) return;
                const mSel = document.getElementById('jf.movies');
                const sSel = document.getElementById('jf.shows');
                if (!mSel || !sSel) return;
                const hasAny = mSel.selectedOptions.length > 0 || sSel.selectedOptions.length > 0;
                if (!hasAny) {
                    const allMovies = Array.from(mSel.options).map(o => o.value);
                    const allShows = Array.from(sSel.options).map(o => o.value);
                    allMovies.forEach(v => {
                        const opt = Array.from(mSel.options).find(o => o.value === v);
                        if (opt) opt.selected = true;
                    });
                    allShows.forEach(v => {
                        const opt = Array.from(sSel.options).find(o => o.value === v);
                        if (opt) opt.selected = true;
                    });
                    mSel.dispatchEvent(new Event('change', { bubbles: true }));
                    sSel.dispatchEvent(new Event('change', { bubbles: true }));
                    rebuildMsForSelect('jf-ms-movies', 'jf.movies');
                    rebuildMsForSelect('jf-ms-shows', 'jf.shows');
                }
            }
        } catch (_) {
            /* ensureLibrarySelectionIntegrity: auto-selection logic failed; user can still select manually */
        }
    }

    // Minimal fallbacks so the page can load even if these panels are not needed
    async function refreshDevices() {
        // Fetch devices list and compute counts for Active/Offline tiles
        try {
            const list = await fetchJSON('/api/devices');
            const devices = Array.isArray(list) ? list : [];
            const STALE_OFFLINE_MS = 60 * 60 * 1000; // 1 hour (keep in sync with getStatusClass)
            const isLive = d => {
                try {
                    const raw = String(d.status || '').toLowerCase();
                    // Consider device active if it's live (WS) or reported online by server
                    if (d?.wsConnected) return true;
                    const last = Date.parse(d?.lastSeenAt || 0) || 0;
                    const recent = last && Date.now() - last <= STALE_OFFLINE_MS;
                    return recent && (raw === 'online' || raw === 'live');
                } catch (_) {
                    return false;
                }
            };
            const active = devices.filter(isLive).length;
            const offline = Math.max(0, devices.length - active);
            setText('metric-active-devices', formatNumber(active));
            setText('metric-offline-devices', formatNumber(offline));
            // simple trend/subtext
            const activeTrend = document.getElementById('metric-active-trend');
            if (activeTrend) activeTrend.textContent = active > 0 ? 'live now' : '';
            const offlineSub = document.getElementById('metric-offline-sub');
            if (offlineSub) offlineSub.textContent = offline > 0 ? 'needs attention' : 'all good';
        } catch (e) {
            // Silently ignore to avoid breaking dashboard on unauthenticated sessions
        }
    }

    // Small helpers for Local media total caching
    const LS_LOCAL_TOTAL_KEY = 'admin2:localTotal';
    function setCachedLocalTotal(n) {
        try {
            sessionStorage.setItem(LS_LOCAL_TOTAL_KEY, String(Number(n) || 0));
        } catch (_) {
            /* setCachedLocalTotal: sessionStorage unavailable */
        }
    }

    async function computeLocalTotalSafe() {
        try {
            const url = '/api/local/browse?path=/';
            let data = null;
            if (typeof window.dedupJSON === 'function') {
                const res = await window.dedupJSON(url);
                if (!res || !res.ok) return 0;
                data = await res.json().catch(() => null);
            } else {
                const res = await fetch(url, { credentials: 'include' }).catch(() => null);
                if (!res || !res.ok) return 0;
                data = await res.json().catch(() => null);
            }
            if (!data || !Array.isArray(data.directories)) return 0;
            const map = new Map(data.directories.map(d => [String(d.name || '').toLowerCase(), d]));
            const sum = name => Number(map.get(name)?.itemCount || 0);
            const total = sum('posters') + sum('backgrounds') + sum('motion') + sum('complete');
            if (Number.isFinite(total)) setCachedLocalTotal(total);
            return Number.isFinite(total) ? total : 0;
        } catch (_) {
            return 0;
        }
    }

    /**
     * Update dashboard media items count by summing enabled sources with filters applied:
     * - Plex/Jellyfin: Count items matching configured filters (from playlist)
     * - TMDB: Count items in queue
     * - Local: Total items count
     */
    async function updateMediaItemsCount() {
        try {
            const configData = await fetchJSON('/api/admin/config').catch(() => null);
            if (!configData) return 0;

            const config = configData.config || {};
            let total = 0;
            const breakdown = [];

            // Check each source type
            const mediaServers = config.mediaServers || [];
            const plex = mediaServers.find(s => s.type === 'plex');
            const jf = mediaServers.find(s => s.type === 'jellyfin');

            // Plex: filtered count from playlist
            if (plex?.enabled) {
                const plexCount = window.__lastPlexFilteredCount || 0;
                if (plexCount > 0) {
                    total += plexCount;
                    breakdown.push(`Plex: ${formatNumber(plexCount)}`);
                }
            }

            // Jellyfin: filtered count from playlist
            if (jf?.enabled) {
                const jfCount = window.__lastJellyfinFilteredCount || 0;
                if (jfCount > 0) {
                    total += jfCount;
                    breakdown.push(`Jellyfin: ${formatNumber(jfCount)}`);
                }
            }

            // TMDB: queue count
            if (config.tmdbSource?.enabled) {
                const tmdbCount = window.__lastTmdbCount || 0;
                if (tmdbCount > 0) {
                    total += tmdbCount;
                    breakdown.push(`TMDB: ${formatNumber(tmdbCount)}`);
                }
            }

            // Local: total items count
            if (config.localDirectory?.enabled) {
                const localCount = await computeLocalTotalSafe();
                if (localCount > 0) {
                    total += localCount;
                    breakdown.push(`Local: ${formatNumber(localCount)}`);
                }
            }

            // Update dashboard display
            setText('metric-media-items', formatNumber(total));

            // Store breakdown for tooltip/debugging
            const mediaItemsEl = document.getElementById('metric-media-items');
            if (mediaItemsEl) {
                mediaItemsEl.setAttribute('title', breakdown.join(' | ') || 'No items');
            }

            return total;
        } catch (err) {
            logger.error('Failed to update media items count:', err);
            return 0;
        }
    }

    async function refreshDashboardMetrics() {
        // Populate media totals and Active Mode for the top dashboard cards
        // Apply client-side dedupe and 429 backoff to avoid hammering the server
        if (!window.__metricsCooldownUntil) window.__metricsCooldownUntil = 0;
        if (!window.__metricsInFlight) window.__metricsInFlight = null;
        try {
            // Calculate total media items from enabled sources with filters applied
            await updateMediaItemsCount();

            const now = Date.now();
            if (now < window.__metricsCooldownUntil) {
                // Respect cooldown after server rate-limited us
                throw new Error('metrics:cooldown');
            }
            if (window.__metricsInFlight) {
                // Share a single in-flight request among callers
                await window.__metricsInFlight;
            }
            const p = (async () => {
                let data = null;
                if (typeof window.dedupJSON === 'function') {
                    const res = await window.dedupJSON('/api/v1/metrics/dashboard');
                    if (res && res.status === 429) {
                        // Exponential backoff-lite: fixed cool-down window
                        window.__metricsCooldownUntil = Date.now() + 30_000; // 30s
                        return null;
                    }
                    data = (res && res.ok && (await res.json())) || null;
                } else {
                    // Fallback
                    data = await fetchJSON('/api/v1/metrics/dashboard').catch(() => null);
                }
                return data;
            })();

            // version-bump: ensure fresh cache-busting token for admin.js
            // reason: force clients and SW to fetch updated spinner wiring (2025-09-24)
            window.__metricsInFlight = p;
            await p;
        } catch (_) {
            // non-fatal
        } finally {
            window.__metricsInFlight = null;
        }

        // Count enabled sources and update Active Mode from the actual config
        try {
            const configData = await fetchJSON('/api/admin/config').catch(() => null);
            if (configData) {
                const config = configData.config || {};
                let enabledSources = 0;

                // Check each source type
                const mediaServers = config.mediaServers || [];
                const plex = mediaServers.find(s => s.type === 'plex');
                const jf = mediaServers.find(s => s.type === 'jellyfin');

                if (plex?.enabled) enabledSources++;
                if (jf?.enabled) enabledSources++;
                if (config.tmdbSource?.enabled) enabledSources++;
                if (config.localDirectory?.enabled) enabledSources++;

                // Dashboard media items count is now handled by updateMediaItemsCount()
                // which sums all enabled sources with proper filtering

                const mediaSub = document.getElementById('metric-media-sub');
                if (mediaSub) {
                    if (enabledSources === 0) {
                        mediaSub.textContent = 'no sources configured';
                    } else if (enabledSources === 1) {
                        mediaSub.textContent = 'from 1 source';
                    } else {
                        mediaSub.textContent = `from ${enabledSources} sources`;
                    }
                }

                // Update Posterpack Content Source labels with (not configured) only when missing (disabled still counts as configured)
                try {
                    const sel = document.getElementById('posterpack.source');
                    if (sel) {
                        const mark = (value, isConfigured) => {
                            const opt = Array.from(sel.options).find(o => o.value === value);
                            if (!opt) return;
                            const base =
                                opt.dataset.origLabel ||
                                opt.textContent.replace(/\s*\(not configured\)$/i, '');
                            opt.dataset.origLabel = base;
                            opt.textContent = isConfigured ? base : `${base} (not configured)`;
                        };
                        const plexConfigured = !!plex; // presence in config is enough
                        const jfConfigured = !!jf;
                        mark('plex', plexConfigured);
                        mark('jellyfin', jfConfigured);
                    }
                } catch (_) {
                    /* legacy numeric wrapper attempt failed (will retry via manualWrap) */
                }

                // Active Mode snapshot: cinema > wallart > screensaver
                try {
                    const c = config;
                    const w = c.wallartMode || {};
                    const active = c.cinemaMode ? 'cinema' : w.enabled ? 'wallart' : 'screensaver';
                    const label =
                        active === 'cinema'
                            ? 'Cinema'
                            : active === 'wallart'
                              ? 'Wallart'
                              : 'Screensaver';
                    setText('metric-mode', label);
                    const sub = (() => {
                        if (active === 'screensaver') {
                            const eff = String(c.transitionEffect || 'kenburns');
                            const interval = Number(c.transitionIntervalSeconds || 0);
                            const clock = c.clockWidget !== false;
                            const effLabel =
                                eff === 'kenburns'
                                    ? 'Ken Burns'
                                    : eff === 'fade'
                                      ? 'Fade'
                                      : eff === 'slide'
                                        ? 'Slide'
                                        : eff;
                            const parts = [];
                            if (interval) parts.push(`Every ${interval}s`);
                            parts.push(`Effect: ${effLabel}`);
                            parts.push(`Clock: ${clock ? 'On' : 'Off'}`);
                            return parts.join(' · ');
                        }
                        if (active === 'wallart') {
                            const density = w.density || 'medium';
                            const rate = Number(w.refreshRate ?? 6);
                            const variant = w.layoutVariant || 'heroGrid';
                            const rateLabel = (() => {
                                const map = [
                                    'Very slow',
                                    'Slow',
                                    'Med‑slow',
                                    'Medium',
                                    'Med‑fast',
                                    'Fast',
                                    'Faster',
                                    'Very fast',
                                    'Ultra',
                                    'Ludicrous',
                                ];
                                return map[Math.min(Math.max(rate, 1), 10) - 1];
                            })();
                            return `${density} · ${rateLabel} · ${variant}`;
                        }
                        // cinema
                        const orient = c.cinemaOrientation || 'auto';
                        return `Orientation: ${orient}`;
                    })();
                    const subEl = document.getElementById('metric-mode-sub');
                    if (subEl) subEl.textContent = sub;
                    // Icon swap
                    const iconEl = document.getElementById('metric-mode-icon');
                    if (iconEl) {
                        iconEl.className = 'fas';
                        if (active === 'screensaver') iconEl.classList.add('fa-image');
                        else if (active === 'wallart') iconEl.classList.add('fa-images');
                        else iconEl.classList.add('fa-tv');
                    }
                } catch (_) {
                    /* width bucket sizing verification failed (debug only) */
                }
            }
        } catch (_) {
            // fallback to static text
            const mediaSub = document.getElementById('metric-media-sub');
            if (mediaSub) mediaSub.textContent = 'from sources';
        }

        // Also refresh devices counts shown on this dashboard row
        await refreshDevices();
    }

    // --- Live Dashboard KPIs ---
    let dashTimer = null;
    let dashLastRun = 0;
    const DASH_MIN_INTERVAL = 10000; // 10s between refreshes (aligned with mini cache TTL)
    function stopDashboardLive() {
        if (dashTimer) {
            clearTimeout(dashTimer);
            dashTimer = null;
        }
    }
    function scheduleNextDashboardTick() {
        stopDashboardLive();
        dashTimer = setTimeout(runDashboardTick, DASH_MIN_INTERVAL);
    }
    async function runDashboardTick() {
        try {
            // Only refresh if dashboard is visible
            const active = document.getElementById('section-dashboard');
            const visible = !!active && active.classList.contains('active') && !active.hidden;
            if (!visible) return;
            const now = Date.now();
            if (now - dashLastRun < DASH_MIN_INTERVAL - 50) return scheduleNextDashboardTick();
            dashLastRun = now;
            await refreshDashboardMetrics();
        } catch (_) {
            /* ignore errors */
        } finally {
            scheduleNextDashboardTick();
        }
    }
    function startDashboardLive() {
        // Avoid duplicate loops
        if (dashTimer) return;
        runDashboardTick();
    }

    // --- Live System Performance ---
    let perfTimer = null;
    const PERF_INTERVAL = 10000; // 10s
    function stopPerfLive() {
        if (perfTimer) {
            clearTimeout(perfTimer);
            perfTimer = null;
        }
    }
    function startPerfLive() {
        // Avoid duplicate loops
        if (perfTimer) return;
        const tick = async () => {
            try {
                // Only poll when dashboard is visible (same visibility gate as KPIs)
                const active = document.getElementById('section-dashboard');
                const visible = !!active && active.classList.contains('active') && !active.hidden;
                if (visible) await refreshPerfDashboard();
            } catch (_) {
                /* ignore errors */
            } finally {
                perfTimer = setTimeout(tick, PERF_INTERVAL);
            }
        };
        tick();
    }

    async function refreshPerfDashboard() {
        // System status chips and resources
        try {
            const status = await fetchJSON('/api/admin/status');
            const app = String(status?.app?.status || 'unknown');
            const db = String(status?.database?.status || 'unknown');
            const cache = String(status?.cache?.status || 'unknown');

            const map = s => {
                const v = String(s || '').toLowerCase();
                if (v === 'running' || v === 'connected' || v === 'active' || v === 'ok')
                    return 'success';
                if (v === 'warning' || v === 'degraded' || v === 'idle') return 'warning';
                return 'error';
            };
            const appCls = map(app);
            const dbCls = map(db);
            const cacheCls = map(cache);

            const setChip = (dotId, badgeId, cls, textVal) => {
                const dot = document.getElementById(dotId);
                const badge = document.getElementById(badgeId);
                if (dot) {
                    dot.classList.remove('status-success', 'status-warning', 'status-error');
                    dot.classList.add(`status-${cls}`);
                }
                if (badge) {
                    // Don't remove existing status classes for our new pills, just update the text
                    if (!badge.classList.contains('header-pill')) {
                        badge.classList.remove('status-success', 'status-warning', 'status-error');
                        badge.classList.add(`status-${cls}`);
                    }
                    // Update the value span inside the pill
                    const valueSpan = badge.querySelector('.value');
                    if (valueSpan) {
                        let displayText = String(textVal || '');
                        // For storage pill, map to Healthy/Unhealthy wording
                        if (badgeId === 'perf-db-status') {
                            const v = displayText.toLowerCase();
                            const healthyVals = ['connected', 'ok', 'running', 'active'];
                            if (cls === 'success' || healthyVals.includes(v)) {
                                displayText = 'Healthy';
                            } else if (cls === 'warning') {
                                displayText = 'Degraded';
                            } else {
                                displayText = 'Unhealthy';
                            }
                        }
                        valueSpan.textContent = displayText;
                    } else {
                        let displayText = String(textVal || '');
                        if (badgeId === 'perf-db-status') {
                            const v = displayText.toLowerCase();
                            const healthyVals = ['connected', 'ok', 'running', 'active'];
                            if (cls === 'success' || healthyVals.includes(v)) {
                                displayText = 'Healthy';
                            } else if (cls === 'warning') {
                                displayText = 'Degraded';
                            } else {
                                displayText = 'Unhealthy';
                            }
                        }
                        badge.textContent = displayText;
                    }
                }
            };
            setChip('chip-app-dot', 'perf-app-status', appCls, app);
            setChip('chip-db-dot', 'perf-db-status', dbCls, db);
            setChip('chip-cache-dot', 'perf-cache-status', cacheCls, cache);

            // Uptime (prefer numeric seconds → compact format Xd Xh Xm)
            (function () {
                const us = status?.uptimeSeconds;
                const u = status?.uptime;
                let txt = '—';
                if (typeof us === 'number' && Number.isFinite(us)) txt = formatUptime(us);
                else if (typeof u === 'number' && Number.isFinite(u)) txt = formatUptime(u);
                else if (/^\d+$/.test(String(u || ''))) txt = formatUptime(Number(u));
                else if (u) txt = String(u);
                setText('perf-uptime', txt);
            })();
            const memPct = Number(status?.memory?.percent);
            if (Number.isFinite(memPct)) {
                setText(
                    'perf-mem',
                    `${memPct}% (${status?.memory?.usedGB || '—'} GB / ${status?.memory?.totalGB || '—'} GB)`
                );
                setMeter('meter-mem', memPct, 'mem');
            }
            // Simple activity level for end users (Low/Medium/High) — now shown in header pill
            try {
                const cpuPct = Number(
                    status?.cpu?.system ?? status?.cpu?.percent ?? status?.cpu?.usage ?? 0
                );
                const mPct = Number.isFinite(memPct) ? memPct : 0;
                const load = Math.max(0, Math.min(100, Math.round((cpuPct + mPct) / 2)));
                const level = load < 30 ? 'Low' : load < 70 ? 'Medium' : 'High';
                const pill = document.getElementById('perf-activity');
                if (pill) {
                    const valueEl = pill.querySelector('.value');
                    if (valueEl) valueEl.textContent = level;
                    pill.classList.remove('status-success', 'status-warning', 'status-error');
                    if (level === 'Low') pill.classList.add('status-success');
                    else if (level === 'Medium') pill.classList.add('status-warning');
                    else pill.classList.add('status-error');
                    pill.setAttribute(
                        'title',
                        `Overall system activity (CPU and memory): ${level}`
                    );
                }
            } catch (_) {
                /* non-fatal */
            }
        } catch (_) {
            // ignore
        }

        // Detailed performance (CPU, Disk) and show meters
        try {
            const perf = await fetchJSON('/api/admin/performance');
            const cpu = Math.max(
                0,
                Math.min(100, Number(perf?.cpu?.usage ?? perf?.cpu?.percent ?? 0))
            );
            const cpuSys = Math.max(0, Math.min(100, Number(perf?.cpu?.system ?? cpu)));
            const mem = Math.max(0, Math.min(100, Number(perf?.memory?.usage || 0)));
            const diskPct = Math.max(0, Math.min(100, Number(perf?.disk?.usage || 0)));
            // Show only system CPU as requested
            setText('perf-cpu', `${cpuSys}%`);
            setMeter('meter-cpu', cpuSys, 'cpu');
            setText(
                'perf-mem',
                `${mem}% (${perf?.memory?.used || '—'} / ${perf?.memory?.total || '—'})`
            );
            setMeter('meter-mem', mem, 'mem');
            setText(
                'perf-disk',
                `${diskPct}% (${perf?.disk?.used || '—'} / ${perf?.disk?.total || '—'})`
            );
            // Update disk progress bar similar to CPU/Memory
            setMeter('meter-disk', diskPct);
            (function () {
                const us = perf?.uptimeSeconds;
                const u = perf?.uptime;
                let txt = '—';
                if (typeof us === 'number' && Number.isFinite(us)) txt = formatUptime(us);
                else if (typeof u === 'number' && Number.isFinite(u)) txt = formatUptime(u);
                else if (/^\d+$/.test(String(u || ''))) txt = formatUptime(Number(u));
                else if (u) txt = String(u);
                setText('perf-uptime', txt);
            })();

            // Load Average display (1, 5, 15 mins)
            try {
                const laStr = String(perf?.cpu?.loadAverage || '').trim();
                const parts = laStr ? laStr.split(',').map(s => s.trim()) : [];
                const [la1, la5, la15] = [parts[0], parts[1], parts[2]];
                const setChip = (id, val, label) => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    const num = Number(val);
                    const displayVal = Number.isFinite(num) ? String(val) : '—';
                    // include the small label inside the chip
                    el.innerHTML = label
                        ? `<span style="opacity:.8;font-size:.75em;margin-right:6px;">${label}</span><span>${displayVal}</span>`
                        : displayVal;
                    // tooltip for clarity
                    if (label) el.setAttribute('title', `${label} load average: ${val || '—'}`);
                    // simple thresholds: <1 good, 1-2 busy, >2 overloaded
                    el.style.background = '';
                    el.style.color = '';
                    el.style.borderColor = '';
                    if (Number.isFinite(num)) {
                        if (num < 1) {
                            el.style.background = 'rgba(34,197,94,0.15)'; // green
                            el.style.color = '#86efac';
                            el.style.borderColor = 'rgba(34,197,94,0.25)';
                        } else if (num <= 2) {
                            el.style.background = 'rgba(234,179,8,0.15)'; // amber
                            el.style.color = '#fde68a';
                            el.style.borderColor = 'rgba(234,179,8,0.25)';
                        } else {
                            el.style.background = 'rgba(239,68,68,0.15)'; // red
                            el.style.color = '#fca5a5';
                            el.style.borderColor = 'rgba(239,68,68,0.25)';
                        }
                    }
                };
                setChip('perf-loadavg-1', la1, '1m');
                setChip('perf-loadavg-5', la5, '5m');
                setChip('perf-loadavg-15', la15, '15m');
            } catch (_) {
                /* non-fatal */
            }

            // Update tooltip/context for CPU meter to clarify meaning
            try {
                const cpuLabel = document.getElementById('perf-cpu');
                const meter = document.getElementById('meter-cpu');
                const tip = `CPU (system): ${cpuSys}%`;
                if (cpuLabel) cpuLabel.setAttribute('title', tip);
                if (meter) meter.setAttribute('title', tip);
            } catch (_) {
                /* ignore */
            }
        } catch (_) {
            // ignore
        }

        // Traffic & Reliability panel removed
    }

    async function refreshCacheStatsV2() {
        try {
            // Always get fresh stats; also fetch config to derive current maxSizeGB
            const ts = Date.now();
            const [statsRes, cfgRes] = await Promise.all([
                fetch(`/api/admin/cache-stats?_=${ts}`, {
                    credentials: 'include',
                    cache: 'no-store',
                }),
                fetch(`/api/admin/config?_=${ts}`, {
                    credentials: 'include',
                    cache: 'no-store',
                }).catch(() => null),
            ]);
            if (!statsRes.ok) throw new Error(`HTTP ${statsRes.status}`);
            const stats = await statsRes.json();
            let cfg = {};
            try {
                cfg = cfgRes && cfgRes.ok ? await cfgRes.json() : {};
            } catch (_) {
                /* ignore */
            }
            // Prefer value returned by stats.cacheConfig; fall back to config.json
            const fromCfg =
                stats?.cacheConfig?.maxSizeGB ??
                cfg?.config?.cache?.maxSizeGB ??
                cfg?.cache?.maxSizeGB;
            if (fromCfg != null) {
                stats.cacheConfig = stats.cacheConfig || {};
                stats.cacheConfig.maxSizeGB = Number(fromCfg);
            }
            updateCacheStatsDisplayV2(stats);
        } catch (e) {
            console.warn('Cache stats failed', e);
            updateCacheStatsDisplayV2({ diskUsage: { total: 0 }, itemCount: { total: 0 } }, true);
        }
    }

    function updateCacheStatsDisplayV2(data, isError = false) {
        const diskEl = document.getElementById('cache-disk-usage');
        const itemEl = document.getElementById('cache-item-count');
        if (!diskEl || !itemEl) return;
        if (isError) {
            diskEl.innerHTML = '<span class="error">Error loading</span>';
            itemEl.innerHTML = '<span class="error">Error loading</span>';
            return;
        }
        const totalSize = data.diskUsage?.total || 0;
        const imageCacheSize = data.diskUsage?.imageCache || 0;
        const logSize = data.diskUsage?.logFiles || 0;
        // Read server-side cache config if exposed; fallback to 2GB if not available
        const maxSizeGB = Number(
            (data.cacheConfig && data.cacheConfig.maxSizeGB) != null
                ? data.cacheConfig.maxSizeGB
                : 2
        );
        const maxSizeBytes = maxSizeGB * 1024 * 1024 * 1024;
        const usagePct = maxSizeBytes > 0 ? Math.round((imageCacheSize / maxSizeBytes) * 100) : 0;
        diskEl.innerHTML = `
      <div>${formatBytes(imageCacheSize)} / ${formatBytes(maxSizeBytes)} (${usagePct}%)</div>
      <div class="size-bytes">Logs: ${formatBytes(logSize)} | Total: ${formatBytes(totalSize)}</div>
    `;
        const totalItems = data.itemCount?.total || 0;
        itemEl.innerHTML = `
      <div>${Number(totalItems).toLocaleString()}</div>
      <div class="size-bytes">Active in RAM</div>
    `;
        // Update image cache usage meter
        setMeter('meter-image-cache', usagePct, 'mem');
    }

    function wireCacheActions() {
        const cleanupBtn = document.getElementById('cleanup-cache-button');
        const clearBtn = document.getElementById('clear-cache-button');
        const editBtn = document.getElementById('btn-edit-cache-size');
        // Ensure spinner spans exist
        const ensureSpinner = btn => {
            if (!btn) return;
            if (!btn.querySelector('.spinner')) {
                const sp = document.createElement('span');
                sp.className = 'spinner';
                sp.style.display = 'none'; // Hide spinner by default
                btn.insertBefore(sp, btn.firstChild);
            }
        };
        // TMDB custom dropdown wiring lives near iconFor()
        ensureSpinner(cleanupBtn);
        ensureSpinner(clearBtn);
        ensureSpinner(editBtn);
        // Open modal and preload current value
        editBtn?.addEventListener('click', async () => {
            try {
                editBtn.classList.add('btn-loading');
                // Prefer config endpoint for source of truth; fallback to cache-stats if needed
                let maxSizeGB = 2;
                try {
                    const r = await window.dedupJSON('/api/admin/config?_=' + Date.now(), {
                        credentials: 'include',
                    });
                    const j = r?.ok ? await r.json() : null;
                    maxSizeGB = Number(
                        j?.config?.cache?.maxSizeGB ?? j?.cache?.maxSizeGB ?? maxSizeGB
                    );
                } catch (_) {
                    // fallback to cache-stats
                    try {
                        const rs = await window.dedupJSON(
                            '/api/admin/cache-stats?_=' + Date.now(),
                            {
                                credentials: 'include',
                            }
                        );
                        const dj = rs?.ok ? await rs.json() : null;
                        maxSizeGB = Number(dj?.cacheConfig?.maxSizeGB ?? maxSizeGB);
                    } catch (_) {
                        /* ignore */
                    }
                }
                const input = document.getElementById('input-cache-size-gb');
                if (input)
                    input.value = String(
                        Number.isFinite(maxSizeGB) && maxSizeGB > 0 ? maxSizeGB : 2
                    );
                // Ensure custom number steppers are applied for the modal input
                try {
                    const alreadyWrapped = input?.closest('.number-input-wrapper');
                    if (input && !alreadyWrapped) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'number-input-wrapper niw-compact';
                        const parent = input.parentElement;
                        if (parent) {
                            parent.replaceChild(wrapper, input);
                            wrapper.appendChild(input);
                            const controls = document.createElement('div');
                            controls.className = 'number-controls';
                            const btnUp = document.createElement('button');
                            btnUp.type = 'button';
                            btnUp.className = 'number-btn number-inc';
                            btnUp.setAttribute('aria-label', 'Increase value');
                            btnUp.innerHTML = '<i class="fas fa-chevron-up"></i>';
                            const btnDown = document.createElement('button');
                            btnDown.type = 'button';
                            btnDown.className = 'number-btn number-dec';
                            btnDown.setAttribute('aria-label', 'Decrease value');
                            btnDown.innerHTML = '<i class="fas fa-chevron-down"></i>';
                            controls.appendChild(btnUp);
                            controls.appendChild(btnDown);
                            wrapper.appendChild(controls);
                            // Wire up handlers (mirror global enhancer)
                            const step = () => Number(input.step || '1') || 1;
                            const clamp = v => {
                                let val = v;
                                const min = input.min === '' ? null : Number(input.min);
                                const max = input.max === '' ? null : Number(input.max);
                                if (min != null && !Number.isNaN(min)) val = Math.max(val, min);
                                if (max != null && !Number.isNaN(max)) val = Math.min(val, max);
                                return val;
                            };
                            btnUp.addEventListener('click', () => {
                                const cur = Number(input.value || '0') || 0;
                                input.value = String(clamp(cur + step()));
                                input.dispatchEvent(new Event('input', { bubbles: true }));
                                input.dispatchEvent(new Event('change', { bubbles: true }));
                            });
                            btnDown.addEventListener('click', () => {
                                const cur = Number(input.value || '0') || 0;
                                input.value = String(clamp(cur - step()));
                                input.dispatchEvent(new Event('input', { bubbles: true }));
                                input.dispatchEvent(new Event('change', { bubbles: true }));
                            });
                        }
                    }
                } catch (_) {
                    /* non-fatal */
                }
                openModal('modal-cache-size');
            } finally {
                editBtn.classList.remove('btn-loading');
            }
        });
        // Save from modal
        const btnSaveSize = document.getElementById('btn-cache-size-save');
        ensureSpinner(btnSaveSize);
        btnSaveSize?.addEventListener('click', async () => {
            const input = document.getElementById('input-cache-size-gb');
            const raw = (input?.value || '').trim();
            const val = Number(raw);
            if (!Number.isFinite(val) || val <= 0) {
                return window.notify?.toast({
                    type: 'warning',
                    title: 'Invalid size',
                    message: 'Enter a number greater than 0 (e.g., 1.5)',
                    duration: 3500,
                });
            }
            if (val > 50) {
                // Hard sanity guard
                const proceed = confirm(
                    'Set cache size above 50GB? This may use significant disk space.'
                );
                if (!proceed) return;
            }
            try {
                btnSaveSize.classList.add('btn-loading');
                // Persist via config patch helper; ensure nested path
                await (typeof saveConfigPatch === 'function'
                    ? saveConfigPatch({ cache: { maxSizeGB: val } })
                    : (async () => {
                          const r = await fetch('/api/admin/config', {
                              method: 'POST',
                              headers: { 'Content-Type': 'application/json' },
                              credentials: 'include',
                              body: JSON.stringify({
                                  config: { cache: { maxSizeGB: val } },
                                  env: {},
                              }),
                          });
                          if (!r.ok) throw new Error('Save failed');
                          try {
                              // Manually invalidate cached GET for config and cache-stats in dedup cache if present
                              if (typeof miniCache?.delete === 'function') {
                                  miniCache.delete('/api/admin/config|GET');
                                  miniCache.delete('/api/admin/cache-stats|GET');
                              }
                              if (typeof inflight?.delete === 'function') {
                                  inflight.delete('/api/admin/config|GET');
                                  inflight.delete('/api/admin/cache-stats|GET');
                              }
                          } catch (_) {
                              /* ignore */
                          }
                      })());
                closeModal('modal-cache-size');
                // Optimistically update displayed limit immediately
                try {
                    const diskEl = document.getElementById('cache-disk-usage');
                    if (diskEl) {
                        // Skip brittle inline DOM/Text replacement; a full refresh occurs below
                    }
                } catch (_) {
                    /* ignore */
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Saved',
                    message: `Cache size set to ${val} GB`,
                    duration: 3000,
                });
                // Refresh displayed stats and meter
                await refreshCacheStatsV2();
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Save failed',
                    message: e?.message || 'Unable to save cache size',
                    duration: 5000,
                });
            } finally {
                btnSaveSize.classList.remove('btn-loading');
            }
        });
        cleanupBtn?.addEventListener('click', async () => {
            try {
                // Persistent progress toast
                const t = window.notify?.toast({
                    type: 'info',
                    title: 'Cleaning up…',
                    message: 'Removing old cache files…',
                    duration: 0,
                });
                cleanupBtn.disabled = true;
                cleanupBtn.setAttribute('aria-busy', 'true');
                cleanupBtn.classList.add('btn-loading');
                const res = await fetch('/api/admin/cleanup-cache', {
                    method: 'POST',
                    credentials: 'include',
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok) throw new Error(data?.error || 'Failed to cleanup cache');
                t?.dismiss && t.dismiss();
                const detail = [];
                if (typeof data?.filesRemoved === 'number')
                    detail.push(`${data.filesRemoved} files removed`);
                if (data?.spaceSaved) detail.push(`saved ${data.spaceSaved}`);
                window.notify?.toast({
                    type: 'success',
                    title: 'Cleanup complete',
                    message: detail.join(' • ') || 'Cache cleanup finished',
                    duration: 3500,
                });
            } catch (e) {
                console.warn('Cleanup cache failed', e);
                window.notify?.toast({
                    type: 'error',
                    title: 'Cleanup failed',
                    message: e?.message || 'Unable to cleanup cache',
                    duration: 5000,
                });
            } finally {
                cleanupBtn.disabled = false;
                cleanupBtn.removeAttribute('aria-busy');
                cleanupBtn.classList.remove('btn-loading');
                refreshCacheStatsV2();
            }
        });
        clearBtn?.addEventListener('click', async () => {
            const confirmOnce = clearBtn.getAttribute('data-confirm') === '1';
            if (!confirmOnce) {
                clearBtn.setAttribute('data-confirm', '1');
                const label = clearBtn.querySelector('span:not(.spinner)');
                if (label) label.textContent = 'Click again to confirm';
                // Visual confirm state: warning style + warning icon + title
                clearBtn.classList.remove('btn-primary');
                clearBtn.classList.add('btn-warning');
                clearBtn.setAttribute('title', 'Click again to confirm');
                const icon = clearBtn.querySelector('i');
                if (icon) {
                    icon.classList.remove('fa-broom');
                    icon.classList.add('fa-exclamation-triangle');
                }
                // Always show a toast so users on compact layouts see the confirmation
                window.notify?.toast({
                    type: 'warning',
                    title: 'Confirm',
                    message: 'Click Clear Cache again to confirm',
                    duration: 3500,
                });
                setTimeout(() => {
                    clearBtn.removeAttribute('data-confirm');
                    const s = clearBtn.querySelector('span:not(.spinner)');
                    if (s) s.textContent = 'Clear Cache';
                    clearBtn.classList.remove('btn-warning');
                    clearBtn.classList.add('btn-primary');
                    clearBtn.setAttribute('title', 'Clear image cache from disk');
                    const ic = clearBtn.querySelector('i');
                    if (ic) {
                        ic.classList.remove('fa-exclamation-triangle');
                        ic.classList.add('fa-broom');
                    }
                }, 5000);
                return;
            }
            try {
                const t = window.notify?.toast({
                    type: 'info',
                    title: 'Clearing cache…',
                    message: 'Deleting cached images from disk…',
                    duration: 0,
                });
                clearBtn.disabled = true;
                clearBtn.setAttribute('aria-busy', 'true');
                clearBtn.classList.add('btn-loading');
                const res = await fetch('/api/admin/clear-image-cache', {
                    method: 'POST',
                    credentials: 'include',
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok) throw new Error(data?.error || 'Failed to clear cache');
                t?.dismiss && t.dismiss();
                const msg = data?.message || 'Image cache cleared';
                window.notify?.toast({
                    type: 'success',
                    title: 'Cache cleared',
                    message: msg,
                    duration: 3500,
                });
            } catch (e) {
                console.warn('Clear cache failed', e);
                window.notify?.toast({
                    type: 'error',
                    title: 'Clear failed',
                    message: e?.message || 'Unable to clear cache',
                    duration: 5000,
                });
            } finally {
                clearBtn.disabled = false;
                clearBtn.removeAttribute('aria-busy');
                clearBtn.classList.remove('btn-loading');
                // Ensure button label and style return to default state after action
                const span = clearBtn.querySelector('span:not(.spinner)');
                if (span) span.textContent = 'Clear Cache';
                clearBtn.classList.remove('btn-warning');
                clearBtn.classList.add('btn-primary');
                clearBtn.setAttribute('title', 'Clear image cache from disk');
                const icon = clearBtn.querySelector('i');
                if (icon) {
                    icon.classList.remove('fa-exclamation-triangle');
                    icon.classList.add('fa-broom');
                }
                clearBtn.removeAttribute('data-confirm');
                refreshCacheStatsV2();
            }
        });
    }

    // --- Config Backups UI (Operations) ---
    async function renderConfigBackups() {
        const list = document.getElementById('cfg-backup-list');
        if (!list) return;
        list.innerHTML = '<div class="subtle">Loading…</div>';
        try {
            const r = await fetch('/api/admin/config-backups', {
                credentials: 'include',
                cache: 'no-store',
            });
            const arr = r.ok ? await r.json() : [];
            if (!Array.isArray(arr) || !arr.length) {
                list.innerHTML = '<div class="subtle">No backups found</div>';
                return;
            }
            list.innerHTML = '';
            arr.forEach(b => {
                const item = document.createElement('div');
                item.className = 'backup-item';
                const created = new Date(b.createdAt || Date.now());
                const count = (b.files || []).length;
                const summary = document.createElement('div');
                summary.className = 'backup-summary';
                summary.innerHTML = `
                                        <div class="left">
                    <i class="fas fa-archive"></i>
                    <strong>${b.id}</strong>
                                        <span class="subtle">${created.toLocaleString()}</span>
                                        <span class="subtle">• ${count} files</span>
                  </div>
                  <div class="right">
                                        <button class="btn btn-link btn-sm" title="Toggle details"><i class="fas fa-chevron-down"></i></button>
                                        <button class="btn btn-link btn-sm" title="Delete"><i class="fas fa-trash"></i></button>
                  </div>`;
                item.appendChild(summary);
                const details = document.createElement('div');
                details.className = 'backup-details';
                details.style.display = 'none';
                // Group files by Core/Data visual buckets
                const buckets = { Core: [], Data: [] };
                (b.files || []).forEach(f => {
                    const coreNames = ['config.json', 'device-presets.json', '.env'];
                    buckets[coreNames.includes(f.name) ? 'Core' : 'Data'].push(f);
                });
                const makeGroup = (title, files) => {
                    const wrap = document.createElement('div');
                    wrap.className = 'backup-group';
                    wrap.setAttribute('data-group', title);
                    wrap.innerHTML = `<div class="group-title">${title}</div>`;
                    const listWrap = document.createElement('div');
                    listWrap.className = 'backup-files';
                    files.forEach(f => {
                        const row = document.createElement('div');
                        row.className = 'backup-file-row';
                        const base = f.name.split('/').pop();
                        const label = base.replace('.json', '').replace(/-/g, ' ');
                        const icon =
                            f.name === 'config.json' || f.name.startsWith('config/')
                                ? 'fa-sliders-h'
                                : f.name === 'device-presets.json'
                                  ? 'fa-layer-group'
                                  : f.name === 'devices.json'
                                    ? 'fa-display'
                                    : f.name === 'groups.json'
                                      ? 'fa-object-group'
                                      : f.name === '.env'
                                        ? 'fa-key'
                                        : 'fa-file-alt';
                        const subtitle =
                            f.name === 'config.json'
                                ? 'Application settings'
                                : f.name === 'device-presets.json'
                                  ? 'Default device configuration'
                                  : f.name === 'devices.json'
                                    ? 'Registered devices list'
                                    : f.name === 'groups.json'
                                      ? 'Device groups and assignments'
                                      : f.name === '.env'
                                        ? 'Environment variables (API keys, secrets)'
                                        : f.name;
                        row.innerHTML = `
                            <div class="file-left">
                                <i class="fas ${icon}"></i>
                                <div class="file-text">
                                    <div class="file-title">${label}</div>
                                    <div class="file-subtle">${subtitle}</div>
                                </div>
                            </div>
                            <div class="file-right">
                                <button class="btn btn-secondary btn-xs"><i class="fas fa-undo"></i><span>Restore</span></button>
                            </div>`;
                        const btn = row.querySelector('button');
                        btn.addEventListener('click', async () => {
                            const ok = await confirmAction({
                                title: 'Restore file',
                                message: `Restore ${label}?`,
                                okText: 'Restore',
                                okClass: 'btn-secondary',
                            });
                            if (!ok) return;
                            btn.disabled = true;
                            try {
                                const r2 = await fetch('/api/admin/config-backups/restore', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    credentials: 'include',
                                    body: JSON.stringify({ backupId: b.id, file: f.name }),
                                });
                                const j2 = await r2.json().catch(() => ({}));
                                if (!r2.ok) throw new Error(j2?.error || 'Restore failed');
                                window.notify?.toast({
                                    type: 'success',
                                    title: 'Restored',
                                    message: label,
                                    duration: 2500,
                                });
                            } catch (e) {
                                window.notify?.toast({
                                    type: 'error',
                                    title: 'Restore failed',
                                    message: e?.message || 'Please try again',
                                    duration: 4000,
                                });
                            } finally {
                                btn.disabled = false;
                            }
                        });
                        listWrap.appendChild(row);
                    });
                    wrap.appendChild(listWrap);
                    return wrap;
                };
                details.appendChild(makeGroup('Core', buckets.Core));
                details.appendChild(makeGroup('Data', buckets.Data));
                item.appendChild(details);
                const [btnToggle, btnDelete] = summary.querySelectorAll('button');
                btnToggle.addEventListener('click', () => {
                    const open = details.style.display !== 'none';
                    details.style.display = open ? 'none' : '';
                    const ic = btnToggle.querySelector('i');
                    ic?.classList.toggle('fa-chevron-down', open);
                    ic?.classList.toggle('fa-chevron-up', !open);
                });
                btnDelete.addEventListener('click', async () => {
                    const ok = await confirmAction({
                        title: 'Delete backup',
                        message: 'Delete this backup?',
                        okText: 'Delete',
                        okClass: 'btn-error',
                    });
                    if (!ok) return;
                    btnDelete.disabled = true;
                    try {
                        const rdel = await fetch(
                            `/api/admin/config-backups/${encodeURIComponent(b.id)}`,
                            { method: 'DELETE', credentials: 'include' }
                        );
                        const jdel = await rdel.json().catch(() => ({}));
                        if (!rdel.ok) throw new Error(jdel?.error || 'Delete failed');
                        window.notify?.toast({
                            type: 'success',
                            title: 'Deleted',
                            message: b.id,
                            duration: 2000,
                        });
                        await renderConfigBackups();
                    } catch (e) {
                        window.notify?.toast({
                            type: 'error',
                            title: 'Delete failed',
                            message: e?.message || 'Please try again',
                            duration: 4000,
                        });
                    } finally {
                        btnDelete.disabled = false;
                    }
                });
                list.appendChild(item);
            });
        } catch (_) {
            list.innerHTML = '<div class="subtle">Failed to load</div>';
        }
    }

    // Wire buttons and schedule controls
    const btnCreateCfgBackup = document.getElementById('btn-create-cfg-backup');
    const btnCleanupCfgBackups = document.getElementById('btn-cleanup-cfg-backups');
    btnCreateCfgBackup?.addEventListener('click', async () => {
        try {
            btnCreateCfgBackup.classList.add('btn-loading');
            const r = await fetch('/api/admin/config-backups', {
                method: 'POST',
                credentials: 'include',
            });
            const j = await r.json().catch(() => ({}));
            if (!r.ok) throw new Error(j?.error || 'Backup failed');
            window.notify?.toast({
                type: 'success',
                title: 'Backup created',
                message: j?.id || '',
                duration: 2500,
            });
            await renderConfigBackups();
        } catch (e) {
            window.notify?.toast({
                type: 'error',
                title: 'Backup failed',
                message: e?.message || 'Please try again',
                duration: 4000,
            });
        } finally {
            btnCreateCfgBackup.classList.remove('btn-loading');
        }
    });
    btnCleanupCfgBackups?.addEventListener('click', async () => {
        const keepEl = document.getElementById('input-keep-cfg-backups');
        const keep = Math.max(1, Math.min(60, Number(keepEl?.value || 5)));
        try {
            btnCleanupCfgBackups.classList.add('btn-loading');
            const r = await fetch('/api/admin/config-backups/cleanup', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ keep }),
            });
            const j = await r.json().catch(() => ({}));
            if (!r.ok) throw new Error(j?.error || 'Cleanup failed');
            window.notify?.toast({
                type: 'success',
                title: 'Cleaned up',
                message: `Kept ${j?.kept ?? keep}`,
                duration: 2200,
            });
            await renderConfigBackups();
        } catch (e) {
            window.notify?.toast({
                type: 'error',
                title: 'Cleanup failed',
                message: e?.message || 'Please try again',
                duration: 4000,
            });
        } finally {
            btnCleanupCfgBackups.classList.remove('btn-loading');
        }
    });
    async function loadCfgBackupSchedule() {
        try {
            const r = await fetch('/api/admin/config-backups/schedule', {
                credentials: 'include',
                cache: 'no-store',
            });
            const j = r.ok ? await r.json() : { enabled: true, time: '02:30', retention: 5 };
            const en = document.getElementById('input-cfg-backup-enabled');
            const time = document.getElementById('input-cfg-backup-time');
            const ret = document.getElementById('input-keep-cfg-backups');
            const pill = document.getElementById('cfg-backup-schedule-pill');
            if (en) en.checked = j.enabled !== false;
            if (time) time.value = String(j.time || '02:30');
            if (ret && (j.retention || j.retention === 0)) ret.value = String(j.retention);
            if (pill) {
                const enabled = j.enabled !== false;
                pill.textContent = enabled ? `Daily • ${String(j.time || '02:30')}` : 'Disabled';
                pill.classList.toggle('status-success', enabled);
                pill.classList.toggle('status-warning', !enabled);
            }
        } catch (_) {
            /* loadCfgBackupSchedule: UI pill render fallback if elements missing */
        }
    }
    async function saveCfgBackupSchedule(opts) {
        const en = document.getElementById('input-cfg-backup-enabled');
        const time = document.getElementById('input-cfg-backup-time');
        const ret = document.getElementById('input-keep-cfg-backups');
        const silent = !!(opts && opts.silent);
        try {
            const payload = {
                enabled: !!en?.checked,
                time: (time?.value || '02:30').slice(0, 5),
                retention: Math.max(1, Math.min(60, Number(ret?.value || 5))),
            };
            const r = await fetch('/api/admin/config-backups/schedule', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify(payload),
            });
            if (!r.ok) throw new Error('Save failed');
            if (!silent) {
                window.notify?.toast({ type: 'success', title: 'Schedule saved', duration: 2000 });
            }
            try {
                await loadCfgBackupSchedule();
            } catch (_) {
                /* re-load schedule after save failed (non-fatal since save succeeded) */
            }
        } catch (e) {
            if (!silent) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Save failed',
                    message: e?.message || 'Please try again',
                    duration: 4000,
                });
            }
            throw e;
        }
    }
    // Local button removed; schedule is saved via global Operations Save
    // Load list and schedule when Operations becomes visible
    (function observeOpsForBackups() {
        const sec = document.getElementById('section-operations');
        if (!sec) return;
        const obs = new MutationObserver(() => {
            if (sec.classList.contains('active') && !sec.hidden) {
                renderConfigBackups();
                loadCfgBackupSchedule();
            }
        });
        obs.observe(sec, { attributes: true, attributeFilter: ['class', 'hidden'] });
        if (sec.classList.contains('active') && !sec.hidden) {
            renderConfigBackups();
            loadCfgBackupSchedule();
        }
    })();

    // Auto-refresh the backups list on relevant SSE events
    try {
        if (window.__adminSSE) {
            const s = window.__adminSSE;
            const refresh = debounce(() => {
                const sec = document.getElementById('section-operations');
                if (sec && sec.classList.contains('active') && !sec.hidden) {
                    renderConfigBackups();
                    loadCfgBackupSchedule();
                }
            }, 500);
            s.addEventListener('backup-created', refresh);
            s.addEventListener('backup-deleted', refresh);
            s.addEventListener('backup-restored', refresh);
            s.addEventListener('backup-cleanup', refresh);
        }
    } catch (_) {
        /* SSE backup refresh wiring failed (SSE unavailable) */
    }

    // format uptime helper (not used everywhere but kept for parity/UI)

    function formatUptime(sec) {
        const s = Math.max(0, Math.floor(Number(sec) || 0));
        // Show seconds for sub-minute uptimes (e.g., 45s)
        if (s < 60) return `${s}s`;
        const d = Math.floor(s / 86400);
        const h = Math.floor((s % 86400) / 3600);
        const m = Math.floor((s % 3600) / 60);
        if (d > 0) return `${d}d ${h}h`;
        if (h > 0) return `${h}h ${m}m`;
        return `${m}m`;
    }

    // Debug helper
    const __debugOn = (() => {
        try {
            const params = new URLSearchParams(location.search);
            if (params.get('debug') === '1') return true;
            if (localStorage.getItem('admin2Debug') === '1') return true;
        } catch (_) {
            // ignore
        }
        return false;
    })();
    const dbg = (...args) => {
        if (__debugOn) {
            try {
                console.debug('[admin2]', ...args);
            } catch (_) {
                // ignore (source-status fetch unavailable; leave pills unchanged)
            }
        }
    };
    // Focused devices debug helper (uses same debug flag)
    const ddbg = (...args) => {
        if (!__debugOn) return;
        try {
            console.debug('[devices]', ...args);
        } catch (_) {
            /* silent */
        }
    };

    // Authoritative nav activation logic (idempotent + microtask re-assert)
    function ensureNavActive(sectionId) {
        try {
            const map = {
                'section-dashboard': 'dashboard',
                'section-display': 'display',
                'section-media-sources': 'media-sources',
                'section-devices': 'devices',
                'section-operations': 'operations',
            };
            const key = map[sectionId];
            const all = document.querySelectorAll('.sidebar-nav .nav-item');
            all.forEach(n => n.classList.remove('active'));
            if (key) {
                const el = document.querySelector(`.sidebar-nav .nav-item[data-nav="${key}"]`);
                if (el) el.classList.add('active');
            }
            Promise.resolve().then(() => {
                const still = document.querySelector('.sidebar-nav .nav-item.active');
                if (!still && key) {
                    const el2 = document.querySelector(`.sidebar-nav .nav-item[data-nav="${key}"]`);
                    el2?.classList.add('active');
                }
            });
        } catch (_) {
            /* ensureNavActive: nav highlighting not critical */
        }
    }

    function showSection(id) {
        const sections = document.querySelectorAll('.app-section');
        sections.forEach(s => {
            s.classList.remove('active');
            s.hidden = s.id !== id; // ensure visibility aligns with active section
        });
        const target = document.getElementById(id);
        if (target) {
            target.classList.add('active');
            target.hidden = false;
        }
        // Single authoritative nav sync (no other code should toggle .active)
        ensureNavActive(id);

        // Lazy device section initialization (if user clicked sidebar directly, hash routing may not fire init)
        if (id === 'section-devices') {
            try {
                const section = document.getElementById('section-devices');
                // If not initialized and no device tiles present yet, trigger init + default tab
                const already = section?.dataset.inited === '1';
                const grid = document.getElementById('device-grid');
                const hasDevices = grid && grid.children.length > 0;
                if (!already && !hasDevices) {
                    // Select Devices tab as default
                    document.getElementById('seg-devices')?.click();
                    window.admin2?.initDevices?.();
                }
            } catch (_) {
                /* device section lazy-init failed (user can refresh or navigate again) */
            }
        }
        // Update header title for basic context switch
        const pageHeader = document.querySelector('.page-header');
        const h1 = pageHeader?.querySelector('h1');
        const subtitle = pageHeader?.querySelector('p');
        if (pageHeader && h1) {
            if (id === 'section-media-sources') {
                // Hide the big page header; Media Sources now has its own panel header
                pageHeader.style.display = 'none';
            } else if (id === 'section-operations') {
                // Hide the big page header for Operations (use compact in-panel header)
                pageHeader.style.display = 'none';
            } else if (id === 'section-devices') {
                // Hide the big page header for Device Management (use compact in-panel header)
                pageHeader.style.display = 'none';
            } else if (id === 'section-display') {
                // Hide the big page header for Display Settings (compact panel)
                pageHeader.style.display = 'none';
            } else {
                // Default (Dashboard and any other sections using the big header)
                pageHeader.style.display = '';
                h1.innerHTML = '<i class="fas fa-gauge-high"></i> Dashboard';
                if (subtitle) subtitle.textContent = 'Devices, media, and health at a glance';
            }
        }

        // Ensure Operations number inputs are enhanced when the section becomes visible
        if (id === 'section-operations') {
            try {
                const ensureWrapped = input => {
                    if (!input || input.closest('.number-input-wrapper')) return;
                    const wrapper = document.createElement('div');
                    wrapper.className = 'number-input-wrapper niw-compact';
                    const parent = input.parentElement;
                    if (!parent) return;
                    parent.replaceChild(wrapper, input);
                    wrapper.appendChild(input);
                    const controls = document.createElement('div');
                    controls.className = 'number-controls';
                    const btnUp = document.createElement('button');
                    btnUp.type = 'button';
                    btnUp.className = 'number-btn number-inc';
                    btnUp.setAttribute('aria-label', 'Increase value');
                    btnUp.innerHTML = '<i class="fas fa-chevron-up"></i>';
                    const btnDown = document.createElement('button');
                    btnDown.type = 'button';
                    btnDown.className = 'number-btn number-dec';
                    btnDown.setAttribute('aria-label', 'Decrease value');
                    btnDown.innerHTML = '<i class="fas fa-chevron-down"></i>';
                    controls.appendChild(btnUp);
                    controls.appendChild(btnDown);
                    wrapper.appendChild(controls);
                    const step = () => Number(input.step || '1') || 1;
                    const clamp = v => {
                        let val = v;
                        const min = input.min === '' ? null : Number(input.min);
                        const max = input.max === '' ? null : Number(input.max);
                        if (min != null && !Number.isNaN(min)) val = Math.max(val, min);
                        if (max != null && !Number.isNaN(max)) val = Math.min(val, max);
                        return val;
                    };
                    btnUp.addEventListener('click', () => {
                        const cur = Number(input.value || '0') || 0;
                        input.value = String(clamp(cur + step()));
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    });
                    btnDown.addEventListener('click', () => {
                        const cur = Number(input.value || '0') || 0;
                        input.value = String(clamp(cur - step()));
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    });
                };
                [
                    'input-keep-backups',
                    'input-keep-cfg-backups',
                    'ops.backgroundRefreshMinutes',
                    'SERVER_PORT',
                    'siteServer.port',
                ].forEach(id => ensureWrapped(document.getElementById(id)));
            } catch (_) {
                /* dashboard live metrics start/stop failed - continue without live updates */
            }
        }

        // Toggle Admin v2 Display preview visibility based on active section
        try {
            const pvc = document.getElementById('display-preview-container');
            if (pvc) {
                pvc.style.display = id === 'section-display' ? 'block' : 'none';
                // When returning to Display, nudge the preview to its proper anchor
                if (id === 'section-display') {
                    try {
                        // Do it twice across frames to allow layout to settle
                        window.__previewReanchor?.();
                        requestAnimationFrame(() => window.__previewReanchor?.());
                    } catch (_) {
                        /* slider bar re-render (input event) failed (cosmetic) */
                    }
                }
            }
        } catch (_) {
            /* display preview reanchor nested attempt failed (will retry on next activation) */
        }

        // Show/hide Activity pill - only show on dashboard
        const activityPill = document.getElementById('perf-activity');
        if (activityPill) {
            if (id === 'section-dashboard') {
                activityPill.style.display = '';
            } else {
                activityPill.style.display = 'none';
            }
        }

        // Live dashboard KPIs: start/stop polling based on active section
        try {
            if (id === 'section-dashboard') {
                startDashboardLive();
                startPerfLive();
            } else {
                stopDashboardLive();
                stopPerfLive();
            }
        } catch (_) {
            /* non-fatal */
        }

        // Lazy-init Display section when it becomes visible
        try {
            if (id === 'section-display' && !window.__displayInit) {
                window.__displayInit = true;
                initDisplaySection();
                // Lazily initialize the floating live preview for Display
                try {
                    if (!window.__displayPreviewInit) {
                        window.__displayPreviewInit = true;
                        initDisplayPreviewV2();
                    }
                } catch (_) {
                    /* display preview reanchor attempt failed (layout still usable) */
                }
            }
        } catch (_) {
            /* toggle preview container visibility failed */
        }
    }

    // Removed unused syncCustomSelect helper; cleaned stray references to selectEl/list.

    // Enhance: ensure standard selects inside Cinema cards get the caret wrapper
    // Idempotent: skips selects already wrapped or not eligible
    function ensureCaretWrapped(selectEl) {
        try {
            if (!selectEl || !(selectEl instanceof HTMLSelectElement)) return;
            if (selectEl.multiple) return; // skip multiselect backers
            if (selectEl.closest('.select-wrap')) return; // already wrapped
            const wrap = document.createElement('div');
            wrap.className = 'select-wrap has-caret';
            // Insert wrapper before select, then move select inside
            const parent = selectEl.parentNode;
            if (!parent) return;
            parent.insertBefore(wrap, selectEl);
            wrap.appendChild(selectEl);
            const caret = document.createElement('span');
            caret.className = 'select-caret';
            caret.setAttribute('aria-hidden', 'true');
            caret.textContent = '▾';
            wrap.appendChild(caret);
        } catch (_) {
            /* caret wrapper enhancement failed (purely cosmetic) */
        }
    }

    function enhanceCinemaSelects(root) {
        try {
            const scope = root || document.getElementById('card-cinema');
            if (!scope) return;
            const sels = scope.querySelectorAll('select');
            sels.forEach(sel => ensureCaretWrapped(sel));
        } catch (_) {
            /* cinema select enhancement failed (non-critical UI) */
        }
    }

    function setupCinemaCaretEnhancer() {
        try {
            const root = document.getElementById('card-cinema');
            if (!root) return;
            // Initial pass
            enhanceCinemaSelects(root);
            // Observe dynamic inserts from cinema-ui.js
            if (!window.__cinemaCaretObs) {
                const obs = new MutationObserver(muts => {
                    let touched = false;
                    for (const m of muts) {
                        if (m.type === 'childList' && (m.addedNodes?.length || 0) > 0) {
                            touched = true;
                            break;
                        }
                    }
                    if (touched) enhanceCinemaSelects(root);
                });
                obs.observe(root, { childList: true, subtree: true });
                window.__cinemaCaretObs = obs;
            }
        } catch (_) {
            /* cinema caret observer setup failed (visual enhancement only) */
        }
    }

    // Run on load; Display section is present on admin page load
    window.addEventListener('DOMContentLoaded', () => {
        try {
            setupCinemaCaretEnhancer();
        } catch (_) {
            /* cinema caret enhancer onload failed (safe to ignore) */
        }
    });

    // ---------- Display Section Wiring ----------
    function getVal(id) {
        return document.getElementById(id);
    }

    function setRadioGroupActive(val) {
        const segs = [
            { id: 'seg-saver', value: 'screensaver' },
            { id: 'seg-wallart', value: 'wallart' },
            { id: 'seg-cinema', value: 'cinema' },
        ];
        segs.forEach(s => {
            const el = document.getElementById(s.id);
            if (!el) return;
            const active = s.value === val;
            el.setAttribute('aria-checked', String(active));
        });

        // Update sliding indicator position
        try {
            const container = document.querySelector('#section-display .segmented');
            if (!container) return;
            let ind = container.querySelector('.seg-indicator');
            if (!ind) {
                ind = document.createElement('div');
                ind.className = 'seg-indicator';
                container.appendChild(ind);
            }
            const activeSeg = container.querySelector(`.seg[aria-checked="true"]`);
            if (!activeSeg) return;
            const cRect = container.getBoundingClientRect();
            const sRect = activeSeg.getBoundingClientRect();
            const left = sRect.left - cRect.left; // includes 4px padding space
            const width = sRect.width;
            ind.style.left = `${left}px`;
            ind.style.width = `${width}px`;
        } catch (_) {
            /* segmented control indicator update failed (layout unchanged) */
        }
    }

    function updateModeBadges(active) {
        // Show only the active mode card; others are hidden and disabled
        const cs = document.getElementById('card-screensaver');
        const cw = document.getElementById('card-wallart');
        const cc = document.getElementById('card-cinema');
        if (cs) cs.hidden = active !== 'screensaver';
        if (cw) cw.hidden = active !== 'wallart';
        if (cc) cc.hidden = active !== 'cinema';

        document
            .getElementById('fs-screensaver')
            ?.toggleAttribute('disabled', active !== 'screensaver');
        document.getElementById('fs-wallart')?.toggleAttribute('disabled', active !== 'wallart');
        document.getElementById('fs-cinema')?.toggleAttribute('disabled', active !== 'cinema');

        // Update header pill with current mode
        const pill = document.getElementById('display-mode-pill');
        if (pill) {
            const label =
                active === 'screensaver'
                    ? 'Screensaver'
                    : active === 'wallart'
                      ? 'Wallart'
                      : 'Cinema';
            // Reset classes and apply mode-specific highlight
            pill.classList.remove('pill-screensaver', 'pill-wallart', 'pill-cinema');
            const modeClass =
                active === 'screensaver'
                    ? 'pill-screensaver'
                    : active === 'wallart'
                      ? 'pill-wallart'
                      : 'pill-cinema';
            pill.classList.add(modeClass);
            // Add an icon for extra visual weight
            const icon =
                active === 'screensaver'
                    ? '<i class="fas fa-image" aria-hidden="true"></i>'
                    : active === 'wallart'
                      ? '<i class="fas fa-images" aria-hidden="true"></i>'
                      : '<i class="fas fa-tv" aria-hidden="true" style="transform: rotate(90deg);"></i>';
            pill.innerHTML = `${icon} <span class="mode-label">Mode:</span> ${label}`;
        }
        // Note: Screensaver now contains its own cards (Visual, Clock, Scaling, Effects, Playback, Sync).
        // No separate shared container toggling is needed anymore.
    }

    async function loadAdminConfig() {
        const r = await fetch('/api/admin/config', { credentials: 'include' });
        if (!r.ok) throw new Error('Failed to load config');
        return r.json();
    }

    function hydrateDisplayForm(cfg) {
        const c = cfg?.config || cfg || {};
        const w = c.wallartMode || {};
        // Active mode rules: cinema > wallart > screensaver
        const active = c.cinemaMode ? 'cinema' : w.enabled ? 'wallart' : 'screensaver';
        setRadioGroupActive(active);
        updateModeBadges(active);

        // Global values
        const setIf = (id, val) => {
            const el = getVal(id);
            if (!el || val === undefined || val === null) return;
            if (el.type === 'checkbox') el.checked = !!val;
            else el.value = String(val);
        };
        setIf('transitionIntervalSeconds', c.transitionIntervalSeconds);
        setIf('transitionEffect', c.transitionEffect || 'kenburns');
        setIf('effectPauseTime', c.effectPauseTime);
        setIf('clockWidget', c.clockWidget !== false);
        setIf('clockFormat', c.clockFormat || '24h');
        setIf('clockTimezone', c.clockTimezone || 'auto');
        setIf('showPoster', c.showPoster !== false);
        setIf('showMetadata', c.showMetadata !== false);
        setIf('showClearLogo', c.showClearLogo !== false);
        setIf('showRottenTomatoes', c.showRottenTomatoes === true);
        // Map 0–100 schema -> 0–10 UI (snap to .0 or .5). If value looks like 0–10 already, keep it.
        (function () {
            const raw = c.rottenTomatoesMinimumScore;
            if (raw == null) return setIf('rottenTomatoesMinimumScore', 0);
            const num = Number(raw);
            if (!Number.isFinite(num)) return setIf('rottenTomatoesMinimumScore', 0);
            const uiRaw = num > 10 ? num / 10 : num;
            // Clamp 0..10 and snap to nearest 0.5
            const clamped = Math.min(10, Math.max(0, uiRaw));
            const snapped = Math.round(clamped * 2) / 2;
            setIf('rottenTomatoesMinimumScore', snapped);
        })();
        const us = c.uiScaling || {};
        setIf('uiScaling_global', us.global ?? 100);
        setIf('uiScaling_content', us.content ?? 100);
        setIf('uiScaling_clearlogo', us.clearlogo ?? 100);
        setIf('uiScaling_clock', us.clock ?? 100);
        // Sync
        setIf('syncEnabled', c.syncEnabled !== false);
        if (typeof c.syncAlignMaxDelayMs !== 'undefined')
            setIf('syncAlignMaxDelayMs', c.syncAlignMaxDelayMs);

        // Sync card: keep contents visible regardless of switch state (per request)
        try {
            const delayRow = document.getElementById('syncAlignMaxDelayMs')?.closest('.form-row');
            if (delayRow) delayRow.style.display = '';
        } catch (_) {
            /* preview container show/hide failed (dashboard continues) */
        }

        // Screensaver: no screensaver-only numeric fields to hydrate here (refresh lives under Operations)

        // Wallart
        setIf('wallartMode_density', w.density || 'medium');
        setIf('wallartMode_refreshRate', w.refreshRate ?? 6);
        setIf('wallartMode_randomness', w.randomness ?? 3);
        setIf('wallartMode_animationType', w.animationType || 'fade');
        setIf('wallartMode_layoutVariant', w.layoutVariant || 'heroGrid');
        setIf('wallartMode_ambientGradient', w.ambientGradient === true);
        // Columns / Items per screen / Grid transition removed in Admin v2; Density controls layout.
        const hg = (w.layoutSettings && w.layoutSettings.heroGrid) || {};
        setIf('wallartMode_heroSide', hg.heroSide || 'left');
        setIf('wallartMode_heroRotationMinutes', hg.heroRotationMinutes ?? 10);
        setIf('wallartMode_biasAmbientToHero', hg.biasAmbientToHero !== false);

        // Wallart: show hero settings only for heroGrid layout
        try {
            const layoutSel = document.getElementById('wallartMode_layoutVariant');
            const heroSideRow = document
                .getElementById('wallartMode_heroSide')
                ?.closest('.form-row');
            const heroRotRow = document
                .getElementById('wallartMode_heroRotationMinutes')
                ?.closest('.form-row');
            const heroBiasRow = document
                .getElementById('wallartMode_biasAmbientToHero')
                ?.closest('.form-row');
            const applyHeroVis = () => {
                const isHero = layoutSel?.value === 'heroGrid';
                [heroSideRow, heroRotRow, heroBiasRow].forEach(row => {
                    if (row) row.style.display = isHero ? '' : 'none';
                });
                const heroCard = document.getElementById('wallart-hero-card');
                if (heroCard) heroCard.style.display = isHero ? '' : 'none';
            };
            layoutSel?.addEventListener('change', applyHeroVis);
            applyHeroVis();
        } catch (_) {
            /* hero layout visibility toggle failed (defaults still sensible) */
        }

        // Wallart: Ambience — keep Bias visible regardless of Ambient Gradient state (as requested)

        // Cinema
        setIf('cinemaOrientation', c.cinemaOrientation || 'auto');

        // Wire radio changes after hydration to update UI states
        const radios = document.querySelectorAll('input[name="display.mode"]');
        radios.forEach(r =>
            r.addEventListener('change', () => {
                const value = document.querySelector('input[name="display.mode"]:checked')?.value;
                if (value) {
                    setRadioGroupActive(value);
                    updateModeBadges(value);
                }
            })
        );

        // Ensure indicator positions correctly on first paint and on resize
        try {
            const apply = () => {
                const value = document.querySelector('input[name="display.mode"]:checked')?.value;
                if (value) setRadioGroupActive(value);
            };
            window.addEventListener('resize', apply);
            // defer initial layout to next frame so sizes are correct
            requestAnimationFrame(apply);
        } catch (_) {
            /* resize indicator alignment failed (fallback static position) */
        }

        // Update slider labels for modern sliders
        try {
            // Create lightweight progress bars behind native sliders without changing their appearance
            (function initSliderBars() {
                const ids = [
                    'uiScaling_global',
                    'uiScaling_content',
                    'uiScaling_clearlogo',
                    'uiScaling_clock',
                    'wallartMode_refreshRate',
                    'wallartMode_randomness',
                ];
                const updateBar = inputEl => {
                    try {
                        const wrap = inputEl.closest('.modern-slider');
                        if (!wrap) return;
                        const bar = wrap.querySelector('.slider-bar');
                        const fill = bar && bar.querySelector('.fill');
                        if (!bar || !fill) return;
                        const min = Number(inputEl.min || 0);
                        const max = Number(inputEl.max || 100);
                        const val = Number(inputEl.value || 0);
                        const pct = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
                        fill.style.width = pct + '%';
                    } catch (_) {
                        /* slider bar percent calc failed (purely cosmetic) */
                    }
                };
                ids.forEach(id => {
                    const el = getVal(id);
                    if (!el) return;
                    const wrap = el.closest('.modern-slider');
                    if (wrap && !wrap.querySelector('.slider-bar')) {
                        const bar = document.createElement('div');
                        bar.className = 'slider-bar';
                        const fill = document.createElement('div');
                        fill.className = 'fill';
                        bar.appendChild(fill);
                        wrap.appendChild(bar);
                    }
                    updateBar(el);
                    el.addEventListener('input', () => updateBar(el));
                    el.addEventListener('change', () => updateBar(el));
                });
            })();
            const labelFor = (id, val) => {
                if (id === 'wallartMode_refreshRate') {
                    const v = Number(val);
                    const map = [
                        'Very slow',
                        'Slow',
                        'Med‑slow',
                        'Medium',
                        'Med‑fast',
                        'Fast',
                        'Faster',
                        'Very fast',
                        'Ultra',
                        'Ludicrous',
                    ];
                    return map[Math.min(Math.max(v, 1), 10) - 1];
                }
                if (id === 'wallartMode_randomness') {
                    const v = Number(val);
                    if (v <= 2) return 'Low';
                    if (v <= 5) return 'Medium';
                    if (v <= 8) return 'High';
                    return 'Chaotic';
                }
                if (id.startsWith('uiScaling_')) return `${val}%`;
                return String(val);
            };
            const updateSliderLabel = id => {
                const el = getVal(id);
                const lab = document.querySelector(
                    `#section-display .slider-percentage[data-target="${CSS.escape(id)}"]`
                );
                if (el && lab) lab.textContent = labelFor(id, el.value);
            };
            [
                'uiScaling_global',
                'uiScaling_content',
                'uiScaling_clearlogo',
                'uiScaling_clock',
                'wallartMode_refreshRate',
                'wallartMode_randomness',
            ].forEach(id => {
                const el = getVal(id);
                if (!el) return;
                el.addEventListener('input', () => updateSliderLabel(id));
                updateSliderLabel(id);
            });
            // UI scaling preset buttons
            const applyUIScaling = vals => {
                const ids = ['global', 'content', 'clearlogo', 'clock'];
                ids.forEach(key => {
                    const el = getVal('uiScaling_' + key);
                    if (el && vals[key] != null) {
                        el.value = String(vals[key]);
                        const lab = document.querySelector(
                            `#section-display .slider-percentage[data-target="${CSS.escape('uiScaling_' + key)}"]`
                        );
                        if (lab) lab.textContent = `${vals[key]}%`;
                        // Fire events so live preview picks up the changes
                        el.dispatchEvent(new Event('input', { bubbles: true }));
                        el.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });
            };
            const p4k = document.getElementById('preset-4k-tv');
            const pFhd = document.getElementById('preset-full-hd');
            const pUw = document.getElementById('preset-ultrawide');
            const pReset = document.getElementById('reset-ui-scaling');
            p4k?.addEventListener('click', () =>
                applyUIScaling({ global: 120, content: 120, clearlogo: 110, clock: 110 })
            );
            pFhd?.addEventListener('click', () =>
                applyUIScaling({ global: 100, content: 100, clearlogo: 100, clock: 100 })
            );
            pUw?.addEventListener('click', () =>
                applyUIScaling({ global: 95, content: 95, clearlogo: 95, clock: 95 })
            );
            pReset?.addEventListener('click', () =>
                applyUIScaling({ global: 100, content: 100, clearlogo: 100, clock: 100 })
            );
        } catch (_) {
            /* slider label / bar hydration failed (visual only) */
        }

        // Poster → Metadata dependency: disable metadata when poster is off
        try {
            const posterEl = document.getElementById('showPoster');
            const metaEl = document.getElementById('showMetadata');
            const applyDep = () => {
                const enabled = !!posterEl?.checked;
                if (metaEl) {
                    metaEl.disabled = !enabled;
                    if (!enabled) metaEl.checked = false;
                    const label = metaEl.closest('.form-row');
                    if (label) label.style.opacity = enabled ? '' : '.7';
                }
            };
            posterEl?.addEventListener('change', applyDep);
            applyDep();
        } catch (_) {
            /* poster->metadata dependency wiring failed (can still toggle manually) */
        }

        // Clock card: keep timezone/format rows visible regardless of switch state (per request)
        try {
            const tzRow = document.getElementById('clockTimezone')?.closest('.form-row');
            const fmtRow = document.getElementById('clockFormat')?.closest('.form-row');
            if (tzRow) tzRow.style.display = '';
            if (fmtRow) fmtRow.style.display = '';
        } catch (_) {
            /* clock row visibility enforcement failed (non-fatal) */
        }

        // Screensaver no longer supports custom layout; initializer removed.

        // Wallart & Cinema: customize/reset functionality removed per request.

        // Number steppers: inc/dec handlers for all .number-input-wrapper blocks in Display section
        try {
            const panel = document.getElementById('section-display');
            if (panel) {
                panel.querySelectorAll('.number-input-wrapper').forEach(wrapper => {
                    const input = wrapper.querySelector('input[type="number"]');
                    const inc = wrapper.querySelector('.number-inc');
                    const dec = wrapper.querySelector('.number-dec');
                    const step = () => Number(input?.step || '1') || 1;
                    const clamp = v => {
                        let val = v;
                        const min = input?.min === '' ? null : Number(input?.min);
                        const max = input?.max === '' ? null : Number(input?.max);
                        if (min != null && !Number.isNaN(min)) val = Math.max(val, min);
                        if (max != null && !Number.isNaN(max)) val = Math.min(val, max);
                        return val;
                    };
                    inc?.addEventListener('click', () => {
                        if (!input) return;
                        const cur = Number(input.value || '0') || 0;
                        input.value = String(clamp(cur + step()));
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    });
                    dec?.addEventListener('click', () => {
                        if (!input) return;
                        const cur = Number(input.value || '0') || 0;
                        input.value = String(clamp(cur - step()));
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    });
                });
            }
        } catch (_) {
            /* display section number stepper wiring failed (users can type values) */
        }

        // Rotten Tomatoes: live snap to 0.5 and clamp 0..10 while typing
        try {
            const el = document.getElementById('rottenTomatoesMinimumScore');
            if (el) {
                const snap = () => {
                    const raw = el.value;
                    if (raw == null || raw === '') return; // allow clearing while editing
                    const n = Number(raw);
                    if (!Number.isFinite(n)) return;
                    // If users paste a 0–100 value, downscale to 0–10 UX first
                    const ui = n <= 10 ? n : n / 10;
                    const clamped = Math.min(10, Math.max(0, ui));
                    const snapped = Math.round(clamped * 2) / 2; // .0 or .5
                    if (Math.abs(snapped - n) > 1e-9) {
                        // Keep consistent formatting: one decimal place at most
                        el.value = String(snapped);
                    }
                };
                ['input', 'change', 'blur'].forEach(ev => el.addEventListener(ev, snap));
            }
        } catch (_) {
            /* rotten tomatoes snap logic failed (raw value still usable) */
        }

        // -------------------------------------------------------------
        // Global number input enhancement (outside Display section)
        // Applies custom wrapper + steppers for plain <input type=number>
        // in source panels (plex/jellyfin/tmdb), operations modal,
        // and cache size modal without altering existing semantics.
        // -------------------------------------------------------------
        try {
            const enhanceNumberInput = input => {
                if (!input) return;
                const wrapped = !!input.closest('.number-input-wrapper');
                // If previously marked enhanced but wrapper got removed (orphan), allow re-wrap by clearing flag
                if (input.dataset.enhanced === '1' && !wrapped) {
                    try {
                        delete input.dataset.enhanced;
                    } catch (_) {
                        /* slider bar re-render (change event) failed (cosmetic) */
                    }
                }
                // If now wrapped, just normalize flag and exit
                if (wrapped) {
                    input.dataset.enhanced = '1';
                    return;
                }
                if (input.dataset.enhanced === '1') return; // fully done case
                const wrapper = document.createElement('div');
                wrapper.className = 'number-input-wrapper niw-compact';
                const parent = input.parentElement;
                if (!parent) return;
                parent.replaceChild(wrapper, input);
                wrapper.appendChild(input);
                const controls = document.createElement('div');
                controls.className = 'number-controls';
                const btnUp = document.createElement('button');
                btnUp.type = 'button';
                btnUp.className = 'number-btn number-inc';
                btnUp.setAttribute('aria-label', 'Increase value');
                btnUp.innerHTML = '<i class="fas fa-chevron-up"></i>';
                const btnDown = document.createElement('button');
                btnDown.type = 'button';
                btnDown.className = 'number-btn number-dec';
                btnDown.setAttribute('aria-label', 'Decrease value');
                btnDown.innerHTML = '<i class="fas fa-chevron-down"></i>';
                controls.appendChild(btnUp);
                controls.appendChild(btnDown);
                wrapper.appendChild(controls);
                input.dataset.enhanced = '1';
                // Apply a compact width class for known small fields so wrappers don't fill the grid
                try {
                    // Width buckets: xs (very short like single port), sm (short numeric), md (wider rating ranges)
                    const id = input.id;
                    if (id === 'plex_port') {
                        wrapper.classList.add('niw-sized-xs');
                    } else if (
                        id === 'plex.recentDays' ||
                        id === 'jf.port' ||
                        id === 'jf.recentDays' ||
                        id === 'tmdb.minRating' ||
                        id === 'streamingSources.minRating'
                    ) {
                        wrapper.classList.add('niw-sized-sm');
                    }
                } catch (_) {
                    /* slider label update failed (non-critical) */
                }
                // End width bucket sizing
                const snap = (val, s) => Math.round(val / s) * s;
                // Local helpers for increment/decrement controls (mirrors late fallback delegate logic)
                const step = () => {
                    const raw = input.step || '1';
                    const n = Number(raw);
                    return Number.isFinite(n) && n > 0 ? n : 1;
                };
                const decimalsForStep = s => {
                    const str = String(s);
                    if (str.includes('e') || str.includes('E')) return 6;
                    const i = str.indexOf('.');
                    return i === -1 ? 0 : Math.min(6, str.length - i - 1);
                };
                const clamp = v => {
                    let val = v;
                    const min = input.min === '' ? null : Number(input.min);
                    const max = input.max === '' ? null : Number(input.max);
                    if (min != null && !Number.isNaN(min)) val = Math.max(val, min);
                    if (max != null && !Number.isNaN(max)) val = Math.min(val, max);
                    return val;
                };
                btnUp.addEventListener('click', e => {
                    try {
                        e.stopPropagation();
                    } catch (_) {
                        /* preset 4k apply failed (user can set manually) */
                    }
                    const cur = Number(input.value || '0') || 0;
                    const s = step();
                    const out = clamp(snap(cur + s, s));
                    const d = decimalsForStep(s);
                    input.value = d > 0 ? Number(out).toFixed(d) : String(Math.round(out));
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                });
                btnDown.addEventListener('click', e => {
                    try {
                        e.stopPropagation();
                    } catch (_) {
                        /* preset full-hd apply failed (manual adjustment still possible) */
                    }
                    const cur = Number(input.value || '0') || 0;
                    const s = step();
                    const out = clamp(snap(cur - s, s));
                    const d = decimalsForStep(s);
                    input.value = d > 0 ? Number(out).toFixed(d) : String(Math.round(out));
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                });
                // Mark wrapper as wired to prevent duplicate listeners elsewhere (and to let delegated handler bail)
                try {
                    wrapper.dataset.wired = '1';
                    wrapper.dataset.directHandlers = '1';
                } catch (_) {
                    /* wrapper lost-wiring repair pass failed (subsequent attempts continue) */
                }
            };
            // Target specific IDs explicitly to avoid unexpected layout shifts
            const numberIds = [
                'plex.recentDays',
                'plex_port',
                'jf.port',
                'jf.recentDays',
                'tmdb.minRating',
                'streamingSources.minRating',
                'SERVER_PORT',
                'siteServer.port',
                'input-cache-size-gb',
                // Operations: automatic updates & backups & media refresh
                'input-keep-backups',
                'input-keep-cfg-backups',
                'ops.backgroundRefreshMinutes',
            ];
            numberIds.forEach(id => enhanceNumberInput(document.getElementById(id)));
            // Repair pass: if any target number input lost its wrapper after initial enhancement, re-wrap it
            try {
                numberIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    if (el.dataset.enhanced === '1' && !el.closest('.number-input-wrapper')) {
                        try {
                            delete el.dataset.enhanced;
                        } catch (_) {
                            /* mutation observer setup (media sources section) failed (global observer remains) */
                        }
                        enhanceNumberInput(el);
                    }
                });
            } catch (_) {
                /* display section lazy init failed */
            }
            // Expose so other flows (like panel routing) can enhance late-mounted or hidden inputs
            window.admin2 = window.admin2 || {};
            window.admin2.enhanceNumberInput = enhanceNumberInput;

            // Dedupe nested wrappers (in case fallback wrapped first, then main tried to wrap again earlier in lifecycle)
            const dedupeNumberWrappers = (scope = document) => {
                try {
                    scope
                        .querySelectorAll('.number-input-wrapper .number-input-wrapper')
                        .forEach(inner => {
                            const outer = inner.parentElement;
                            if (!outer) return;
                            // Move all children of inner out before removing
                            while (inner.firstChild) outer.insertBefore(inner.firstChild, inner);
                            inner.remove();
                        });
                } catch (_) {
                    /* mutation observer global setup failed (hashchange triggers still run) */
                }
            };
            dedupeNumberWrappers();
            try {
                window.admin2.dedupeNumberWrappers = dedupeNumberWrappers;
            } catch (_) {
                /* posterpack plex library fill fallback rebuild failed (will retry on next user action) */
            }
            window.addEventListener('load', () => setTimeout(() => dedupeNumberWrappers(), 30));
            window.addEventListener('hashchange', () =>
                setTimeout(() => dedupeNumberWrappers(), 60)
            );

            // --- Unified reliability layer (instrumented) for Media Sources numeric inputs ---
            (function ensureMediaSourceNumberWrappers() {
                const IDS = [
                    'plex_port',
                    'plex.recentDays',
                    'jf.port',
                    'jf.recentDays',
                    'tmdb.minRating',
                    'streamingSources.minRating',
                ];
                const MAX_ATTEMPTS = 20;
                const INTERVAL = 80;
                let attempts = 0;
                let fullyDone = false;
                const attemptHistory = [];
                const debugEnabled = () =>
                    !!(window.__MS_NUM_DEBUG || window.localStorage?.getItem('MS_NUM_DEBUG'));
                const debugLog = (...args) => {
                    if (debugEnabled()) {
                        try {
                            console.debug('[MediaNumWrap]', ...args);
                        } catch (_) {
                            /* debug console output failed (dev only) */
                        }
                    }
                };

                const manualWrap = el => {
                    if (!el || el.closest('.number-input-wrapper')) return true;
                    try {
                        const parent = el.parentElement;
                        if (!parent) return false;
                        const wrapper = document.createElement('div');
                        wrapper.className = 'number-input-wrapper niw-compact';
                        parent.replaceChild(wrapper, el);
                        wrapper.appendChild(el);
                        const controls = document.createElement('div');
                        controls.className = 'number-controls';
                        const mk = (cls, dir) => {
                            const b = document.createElement('button');
                            b.type = 'button';
                            b.className = 'number-btn ' + cls;
                            b.setAttribute(
                                'aria-label',
                                dir === 'up' ? 'Increase value' : 'Decrease value'
                            );
                            b.innerHTML = '<i class="fas fa-chevron-' + dir + '"></i>';
                            return b;
                        };
                        const btnUp = mk('number-inc', 'up');
                        const btnDown = mk('number-dec', 'down');
                        controls.appendChild(btnUp);
                        controls.appendChild(btnDown);
                        wrapper.appendChild(controls);
                        const step = () => Number(el.step || '1') || 1;
                        const decimalsForStep = s => {
                            const str = String(s);
                            const i = str.indexOf('.');
                            return i === -1 ? 0 : Math.min(6, str.length - i - 1);
                        };
                        const snap = (val, s) => Math.round(val / s) * s;
                        const clamp = v => {
                            let val = v;
                            const min = el.min === '' ? null : Number(el.min);
                            const max = el.max === '' ? null : Number(el.max);
                            if (min != null && !Number.isNaN(min)) val = Math.max(val, min);
                            if (max != null && !Number.isNaN(max)) val = Math.min(val, max);
                            return val;
                        };
                        const applyChange = dir => {
                            const cur = Number(el.value || '0') || 0;
                            const s = step();
                            const out = clamp(snap(cur + (dir === 'up' ? s : -s), s));
                            const d = decimalsForStep(s);
                            el.value = d > 0 ? Number(out).toFixed(d) : String(Math.round(out));
                            el.dispatchEvent(new Event('input', { bubbles: true }));
                            el.dispatchEvent(new Event('change', { bubbles: true }));
                        };
                        btnUp.addEventListener('click', e => {
                            try {
                                e.stopPropagation();
                            } catch (_) {
                                /* number inc button stopPropagation failed (benign) */
                            }
                            applyChange('up');
                        });
                        btnDown.addEventListener('click', e => {
                            try {
                                e.stopPropagation();
                            } catch (_) {
                                /* number dec button stopPropagation failed (benign) */
                            }
                            applyChange('down');
                        });
                        try {
                            wrapper.dataset.wired = '1';
                            wrapper.dataset.directHandlers = '1';
                        } catch (_) {
                            /* number wrapper dataset flagging failed (non-critical) */
                        }
                        try {
                            el.dataset.enhanced = '1';
                        } catch (_) {
                            /* number input enhanced flag set failed (visual only) */
                        }
                        return true;
                    } catch (_) {
                        return false;
                    }
                };

                const wrapOne = id => {
                    const el = document.getElementById(id);
                    if (!el) return false;
                    const hasWrapper = !!el.closest('.number-input-wrapper');
                    if (el.dataset.enhanced === '1' && !hasWrapper) {
                        try {
                            delete el.dataset.enhanced;
                        } catch (_) {
                            /* cleanup orphan enhanced flag failed (safe to ignore) */
                        }
                    }
                    if (!hasWrapper) {
                        try {
                            enhanceNumberInput(el);
                        } catch (_) {
                            /* primary number enhance failed (fallback manual wrap) */
                        }
                    }
                    if (!el.closest('.number-input-wrapper')) manualWrap(el);
                    return !!el.closest('.number-input-wrapper');
                };

                const attemptAll = (reason = 'tick') => {
                    const snapshot = { reason, attempt: attempts, ts: Date.now(), statuses: {} };
                    let allDone = true;
                    IDS.forEach(id => {
                        const success = wrapOne(id);
                        try {
                            window.__MS_WRAP_STATE = {
                                fullyDone,
                                attempts,
                                last: snapshot,
                                history: attemptHistory.slice(-20),
                            };
                        } catch (_) {
                            /* debug state export failed (dev only) */
                        }
                        snapshot.statuses[id] = success;
                        if (!success) allDone = false;
                    });
                    attemptHistory.push(snapshot);
                    debugLog('attempt', snapshot.attempt, reason, snapshot.statuses);
                    if (!allDone) schedule();
                    else debugLog('all wrapped after attempt', snapshot.attempt, 'reason', reason);
                };
                const schedule = () => {
                    if (attempts++ >= MAX_ATTEMPTS) {
                        debugLog('max attempts reached');
                        return;
                    }
                    setTimeout(() => attemptAll('retry-' + attempts), INTERVAL);
                };

                attemptAll('initial');

                const allWrapped = () =>
                    IDS.every(id => {
                        const el = document.getElementById(id);
                        return el && el.closest('.number-input-wrapper');
                    });
                const finishIfComplete = () => {
                    if (!fullyDone && allWrapped()) {
                        fullyDone = true;
                        debugLog('fullyDone=true');
                    }
                };
                finishIfComplete();

                try {
                    const section = document.getElementById('section-media-sources');
                    if (section && !section.__msNumObs) {
                        const obs = new MutationObserver(muts => {
                            if (fullyDone) return;
                            for (const m of muts) {
                                if (m.type === 'childList') {
                                    attemptAll('section-mutation');
                                    finishIfComplete();
                                }
                            }
                        });
                        obs.observe(section, { childList: true, subtree: true });
                        section.__msNumObs = obs;
                    }
                } catch (_) {
                    /* hashchange numeric wrap retry scheduling failed (later user actions still wrap) */
                }

                try {
                    if (!document.__msGlobalWrapObs) {
                        const gObs = new MutationObserver(muts => {
                            if (fullyDone) return;
                            let relevant = false;
                            for (const m of muts) {
                                if (m.type === 'childList') {
                                    for (const n of m.addedNodes) {
                                        if (n.nodeType === 1) {
                                            const id = n.id || '';
                                            if (
                                                IDS.includes(id) ||
                                                IDS.some(tid =>
                                                    n.querySelector?.('#' + CSS.escape(tid))
                                                )
                                            ) {
                                                relevant = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            if (relevant) {
                                attemptAll('global-mutation');
                                finishIfComplete();
                            }
                        });
                        gObs.observe(document.documentElement, { childList: true, subtree: true });
                        document.__msGlobalWrapObs = gObs;
                    }
                } catch (_) {
                    /* panelActivated numeric wrap attempt failed (other triggers remain) */
                }

                window.addEventListener('hashchange', () => {
                    if (fullyDone) return;
                    const h = location.hash || '';
                    if (/plex|jelly|tmdb|media/i.test(h))
                        setTimeout(() => {
                            attemptAll('hashchange');
                            finishIfComplete();
                        }, 35);
                });
                window.addEventListener('panelActivated', ev => {
                    if (fullyDone) return;
                    try {
                        if (ev?.detail?.id && /plex|jelly|tmdb|media/i.test(String(ev.detail.id))) {
                            attemptAll('panelActivated');
                            setTimeout(() => {
                                attemptAll('panelActivated-delayed');
                                finishIfComplete();
                            }, 25);
                        }
                    } catch (_) {
                        /* posterpack plex primary fallback fetch failed (continue best-effort) */
                    }
                });

                try {
                    const section = document.getElementById('section-media-sources');
                    if (section && typeof IntersectionObserver === 'function') {
                        const io = new IntersectionObserver(entries => {
                            if (fullyDone) return;
                            entries.forEach(ent => {
                                if (ent.isIntersecting) {
                                    attemptAll('io-visible');
                                    setTimeout(() => {
                                        attemptAll('io-visible-55');
                                        finishIfComplete();
                                    }, 55);
                                    setTimeout(() => {
                                        attemptAll('io-visible-230');
                                        finishIfComplete();
                                    }, 230);
                                }
                            });
                        });
                        io.observe(section);
                    }
                } catch (_) {
                    /* intersection observer for media sources failed (other triggers attempt wrapping) */
                }

                try {
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', () => {
                            if (fullyDone) return;
                            attemptAll('domcontentloaded');
                            finishIfComplete();
                            queueMicrotask(() => {
                                if (fullyDone) return;
                                attemptAll('domcontentloaded-microtask');
                                finishIfComplete();
                            });
                            requestAnimationFrame(() => {
                                if (fullyDone) return;
                                attemptAll('domcontentloaded-raf');
                                finishIfComplete();
                            });
                            setTimeout(() => {
                                if (fullyDone) return;
                                attemptAll('domcontentloaded-60ms');
                                finishIfComplete();
                            }, 60);
                        });
                    }
                } catch (_) {
                    /* DOMContentLoaded numeric wrap sequence failed (raf/timeouts still attempt) */
                }

                window.addEventListener('load', () => {
                    if (fullyDone) return;
                    attemptAll('window-load');
                    finishIfComplete();
                    setTimeout(() => {
                        if (fullyDone) return;
                        attemptAll('window-load-120ms');
                        finishIfComplete();
                    }, 120);
                    setTimeout(() => {
                        if (fullyDone) return;
                        attemptAll('window-load-400ms');
                        finishIfComplete();
                    }, 400);
                });

                try {
                    window.admin2 = window.admin2 || {};
                    const apiFn = () => ({
                        fullyDone,
                        attempts,
                        ids: [...IDS],
                        lastStatus: attemptHistory[attemptHistory.length - 1],
                        history: attemptHistory.slice(-10),
                    });
                    Object.defineProperty(window.admin2, 'mediaSourceWrapDebug', {
                        configurable: true,
                        enumerable: false,
                        writable: true,
                        value: apiFn,
                    });
                    if (!window.mediaSourceWrapDebug) window.mediaSourceWrapDebug = apiFn; // direct global alias
                    if (!window.enhanceNumberInput && typeof enhanceNumberInput === 'function')
                        window.enhanceNumberInput = enhanceNumberInput;
                } catch (_) {
                    /* final mediaSourceWrapDebug export failed (diagnostic only) */
                }
            })();
            try {
                // If overwritten later, keep last known state reference
                if (
                    window.admin2 &&
                    !window.admin2.mediaSourceWrapDebug &&
                    window.__lastMediaSourceWrapState
                ) {
                    window.admin2.mediaSourceWrapDebug = () => window.__lastMediaSourceWrapState;
                }
            } catch (_) {
                /* posterpack plex library fetch failed (lists may remain empty) */
            }
            // Plex port now enhanced like others; retain sanitization post-enhancement
            try {
                const plexPort = document.getElementById('plex_port');
                if (plexPort) {
                    const clampPort = () => {
                        const raw = plexPort.value.replace(/[^0-9]/g, '');
                        if (raw === '') return; // allow clearing temporarily
                        let n = parseInt(raw, 10);
                        if (Number.isNaN(n)) n = '';
                        else n = Math.max(1, Math.min(65535, n));
                        plexPort.value = n === '' ? '' : String(n);
                    };
                    plexPort.addEventListener('input', () => {
                        const v = plexPort.value;
                        const digits = v.replace(/[^0-9]/g, '');
                        if (digits !== v) plexPort.value = digits;
                    });
                    ['change', 'blur'].forEach(ev => plexPort.addEventListener(ev, clampPort));
                }
            } catch (_) {
                /* ensureMediaSourceNumberWrappers outer setup failed (wrappers still progressively applied) */
            }
        } catch (_) {
            /* mode pill indicator create/update failed */
        }

        // Wire number steppers for statically-defined wrappers (e.g., pre-wrapped inputs in Media Sources)
        // Expose as a helper and call initially and on panel visibility
        try {
            const wireNumberWrappers = scope => {
                if (!scope) return;
                scope.querySelectorAll('.number-input-wrapper').forEach(wrapper => {
                    if (!wrapper || wrapper.dataset.wired === '1') return;
                    // Wire anywhere (including Media Sources) if not already wired
                    const input = wrapper.querySelector('input[type="number"]');
                    const inc = wrapper.querySelector('.number-inc');
                    const dec = wrapper.querySelector('.number-dec');
                    if (!input || !inc || !dec) return;
                    const step = () => Number(input.step || '1') || 1;
                    const decimalsForStep = s => {
                        const str = String(s);
                        if (str.includes('e') || str.includes('E')) return 6;
                        const i = str.indexOf('.');
                        return i === -1 ? 0 : Math.min(6, str.length - i - 1);
                    };
                    const snap = (val, s) => Math.round(val / s) * s;
                    const clamp = v => {
                        let val = v;
                        const min = input.min === '' ? null : Number(input.min);
                        const max = input.max === '' ? null : Number(input.max);
                        if (min != null && !Number.isNaN(min)) val = Math.max(val, min);
                        if (max != null && !Number.isNaN(max)) val = Math.min(val, max);
                        return val;
                    };
                    inc.addEventListener('click', e => {
                        try {
                            e.stopPropagation();
                            e.stopImmediatePropagation?.();
                        } catch (_) {
                            /* number inc delegated stopPropagation failed (duplicate bubbling harmless) */
                        }
                        const cur = Number(input.value || '0') || 0;
                        const s = step();
                        const out = clamp(snap(cur + s, s));
                        const d = decimalsForStep(s);
                        input.value = d > 0 ? Number(out).toFixed(d) : String(Math.round(out));
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    });
                    dec.addEventListener('click', e => {
                        try {
                            e.stopPropagation();
                            e.stopImmediatePropagation?.();
                        } catch (_) {
                            /* number dec delegated stopPropagation failed (duplicate bubbling harmless) */
                        }
                        const cur = Number(input.value || '0') || 0;
                        const s = step();
                        const out = clamp(snap(cur - s, s));
                        const d = decimalsForStep(s);
                        input.value = d > 0 ? Number(out).toFixed(d) : String(Math.round(out));
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    });
                    wrapper.dataset.wired = '1';
                    wrapper.dataset.directHandlers = '1';
                });
            };
            // Initial pass for the whole Media Sources section
            const scope = document.getElementById('section-media-sources');
            if (scope) wireNumberWrappers(scope);
            // Expose helper for use on panel activation
            window.admin2 = window.admin2 || {};
            window.admin2.wireNumberWrappers = wireNumberWrappers;
            // Global delegated click handler (capture) so spinner buttons always work
            // Works across all sections (Display, Media Sources, Operations, Modals)
            if (!document.__niwDelegated) {
                document.addEventListener(
                    'click',
                    e => {
                        const btn = e.target?.closest?.('.number-input-wrapper .number-btn');
                        if (!btn) return;
                        const wrapper = btn.closest('.number-input-wrapper');
                        if (!wrapper) return;
                        const input = wrapper.querySelector('input[type="number"]');
                        if (!input) return;
                        // If direct wiring already attached handlers and marked wired, skip to avoid duplicate increments
                        if (wrapper.dataset.directHandlers === '1') return;
                        try {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation?.();
                        } catch (_) {
                            /* number wrapper stopPropagation suppression failed (harmless) */
                        }
                        if (btn.__handledOnce) return; // guard per tick
                        btn.__handledOnce = true;
                        setTimeout(() => {
                            try {
                                delete btn.__handledOnce;
                            } catch (_) {
                                /* notify min-level icon click refresh failed (will retry) */
                            }
                        }, 0);
                        const stepVal = (() => Number(input.step || '1') || 1)();
                        const min = input.min === '' ? null : Number(input.min);
                        const max = input.max === '' ? null : Number(input.max);
                        const decimalsForStep = s => {
                            const str = String(s);
                            if (str.includes('e') || str.includes('E')) return 6;
                            const i = str.indexOf('.');
                            return i === -1 ? 0 : Math.min(6, str.length - i - 1);
                        };
                        const snap = (val, s) => Math.round(val / s) * s;
                        const clamp = v => {
                            let val = v;
                            if (min != null && !Number.isNaN(min)) val = Math.max(val, min);
                            if (max != null && !Number.isNaN(max)) val = Math.min(val, max);
                            return val;
                        };
                        const cur = Number(input.value || '0') || 0;
                        let out;
                        if (btn.classList.contains('number-inc')) {
                            out = clamp(snap(cur + stepVal, stepVal));
                        } else if (btn.classList.contains('number-dec')) {
                            out = clamp(snap(cur - stepVal, stepVal));
                        } else return;
                        const d = decimalsForStep(stepVal);
                        input.value = d > 0 ? Number(out).toFixed(d) : String(Math.round(out));
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    },
                    true
                );
                document.__niwDelegated = true;
            }
        } catch (_) {
            /* radio indicator resize realignment failed */
        }

        // Screensaver: live summary + presets (affect global Effect/Playback/Clock)
        try {
            const elInterval = document.getElementById('transitionIntervalSeconds');
            const elEffect = document.getElementById('transitionEffect');
            const elPause = document.getElementById('effectPauseTime');
            const elClock = document.getElementById('clockWidget');
            const pillInt = document.getElementById('saver-summary-interval');
            const pillEff = document.getElementById('saver-summary-effect');
            const pillPause = document.getElementById('saver-summary-pause');
            const pillClock = document.getElementById('saver-summary-clock');

            const effLabel = val => {
                switch (val) {
                    case 'kenburns':
                        return 'Ken Burns';
                    case 'fade':
                        return 'Fade In/Out';
                    case 'slide':
                        return 'Slide';
                    default:
                        return String(val || '—');
                }
            };
            const pauseRow = elPause?.closest('.form-row') || null;
            const applyPauseVisibility = () => {
                const isKB = String(elEffect?.value || '').toLowerCase() === 'kenburns';
                if (pauseRow) pauseRow.style.display = isKB ? 'none' : '';
                if (elPause) elPause.disabled = isKB;
            };
            const applySummary = () => {
                if (pillInt && elInterval)
                    pillInt.textContent = `Every ${elInterval.value || '—'} s`;
                if (pillEff && elEffect)
                    pillEff.textContent = `Effect: ${effLabel(elEffect.value)}`;
                if (pillPause && elPause) {
                    const isKB = String(elEffect?.value || '').toLowerCase() === 'kenburns';
                    pillPause.textContent = isKB
                        ? 'Pause: —'
                        : `Pause: ${elPause.value != null && elPause.value !== '' ? elPause.value : '—'} s`;
                }
                if (pillClock && elClock)
                    pillClock.textContent = `Clock: ${elClock.checked ? 'On' : 'Off'}`;
            };
            ['input', 'change'].forEach(ev => {
                elInterval?.addEventListener(ev, () => {
                    applySummary();
                    // Trigger preview update when interval changes
                    try {
                        window.__displayPreviewInit && (window.__forcePreviewUpdate?.() || 0);
                    } catch (_) {
                        /* slider bar width update failed (visual only) */
                    }
                });
                elEffect?.addEventListener(ev, () => {
                    applyPauseVisibility();
                    applySummary();
                    // Trigger preview update when transition effect changes
                    try {
                        window.__displayPreviewInit && (window.__forcePreviewUpdate?.() || 0);
                    } catch (_) {
                        /* posterpack jellyfin primary fallback fetch failed (will attempt other sources) */
                    }
                });
                elPause?.addEventListener(ev, () => {
                    applySummary();
                    // Trigger preview update when pause time changes
                    try {
                        window.__displayPreviewInit && (window.__forcePreviewUpdate?.() || 0);
                    } catch (_) {
                        /* preset ultrawide apply failed (manual adjustment still possible) */
                    }
                });
                elClock?.addEventListener(ev, () => {
                    applySummary();
                    // Trigger preview update when clock setting changes
                    try {
                        window.__displayPreviewInit && (window.__forcePreviewUpdate?.() || 0);
                    } catch (_) {
                        /* UI scaling reset preset failed (values unchanged) */
                    }
                });
            });
            applyPauseVisibility();
            applySummary();

            // Presets
            const btnChill = document.getElementById('saver-preset-chill');
            const btnStd = document.getElementById('saver-preset-standard');
            const btnLively = document.getElementById('saver-preset-lively');
            const btnReset = document.getElementById('saver-preset-reset');
            const setVals = ({ interval, effect, pause }) => {
                if (typeof interval === 'number' && elInterval) {
                    elInterval.value = String(interval);
                    elInterval.dispatchEvent(new Event('input', { bubbles: true }));
                    elInterval.dispatchEvent(new Event('change', { bubbles: true }));
                }
                if (typeof effect === 'string' && elEffect) {
                    elEffect.value = effect;
                    elEffect.dispatchEvent(new Event('change', { bubbles: true }));
                }
                if (typeof pause === 'number' && elPause) {
                    elPause.value = String(pause);
                    elPause.dispatchEvent(new Event('input', { bubbles: true }));
                    elPause.dispatchEvent(new Event('change', { bubbles: true }));
                }
                applySummary();
            };
            const onPreset = vals => {
                setVals(vals);
                // Nudge preview update if initialized
                try {
                    window.__displayPreviewInit && (window.__forcePreviewUpdate?.() || 0);
                } catch (_) {
                    /* poster->metadata dependency apply failed (user can toggle manually) */
                }
            };
            btnChill?.addEventListener('click', () =>
                onPreset({ interval: 30, effect: 'kenburns', pause: 0 })
            );
            btnStd?.addEventListener('click', () =>
                onPreset({ interval: 15, effect: 'fade', pause: 2 })
            );
            btnLively?.addEventListener('click', () =>
                onPreset({ interval: 8, effect: 'slide', pause: 0.5 })
            );
            btnReset?.addEventListener('click', () =>
                onPreset({ interval: 12, effect: 'kenburns', pause: 1 })
            );
        } catch (_) {
            /* screensaver summary/preset wiring failed (form still editable) */
        }

        // Wallart: live summary + presets
        try {
            const elDensity = document.getElementById('wallartMode_density');
            const elLayout = document.getElementById('wallartMode_layoutVariant');
            const elAnim = document.getElementById('wallartMode_animationType');
            const elRefresh = document.getElementById('wallartMode_refreshRate');
            const elRand = document.getElementById('wallartMode_randomness');
            const elAmbient = document.getElementById('wallartMode_ambientGradient');
            const elBias = document.getElementById('wallartMode_biasAmbientToHero');
            const elHeroSide = document.getElementById('wallartMode_heroSide');
            const elHeroRot = document.getElementById('wallartMode_heroRotationMinutes');
            const heroCard = document.getElementById('wallart-hero-card');

            const pillDensity = document.getElementById('wallart-summary-density');
            const pillLayout = document.getElementById('wallart-summary-layout');
            const pillAnim = document.getElementById('wallart-summary-anim');
            const pillTempo = document.getElementById('wallart-summary-tempo');

            const labelDensity = v =>
                ({ low: 'Low', medium: 'Medium', high: 'High', ludicrous: 'Ludicrous' })[
                    String(v)
                ] || String(v || '—');
            const labelLayout = v =>
                ({ heroGrid: 'Hero Grid', classic: 'Classic' })[String(v)] || String(v || '—');
            const labelAnim = v =>
                ({
                    random: 'Random',
                    fade: 'Fade',
                    slideLeft: 'Slide Left',
                    slideUp: 'Slide Up',
                    zoom: 'Zoom',
                    flip: 'Flip',
                    staggered: 'Staggered',
                    ripple: 'Ripple',
                    scanline: 'Scanline',
                    parallax: 'Parallax',
                    neonPulse: 'Neon Pulse',
                    chromaticShift: 'Chromatic Shift',
                    mosaicShatter: 'Mosaic Shatter',
                })[String(v)] || String(v || '—');
            const labelTempo = () => `R${elRefresh?.value || '—'} / J${elRand?.value || '—'}`; // Refresh/Randomness shorthand

            const applyHeroVisibility = () => {
                const isHero = String(elLayout?.value || '') === 'heroGrid';
                if (heroCard) heroCard.style.display = isHero ? '' : 'none';
            };
            const applySummary = () => {
                if (pillDensity && elDensity)
                    pillDensity.textContent = `Density: ${labelDensity(elDensity.value)}`;
                if (pillLayout && elLayout)
                    pillLayout.textContent = `Layout: ${labelLayout(elLayout.value)}`;
                if (pillAnim && elAnim) pillAnim.textContent = `Anim: ${labelAnim(elAnim.value)}`;
                if (pillTempo) pillTempo.textContent = `Tempo: ${labelTempo()}`;
            };
            ['input', 'change'].forEach(ev => {
                elDensity?.addEventListener(ev, applySummary);
                elLayout?.addEventListener(ev, () => {
                    applyHeroVisibility();
                    applySummary();
                });
                elAnim?.addEventListener(ev, applySummary);
                elRefresh?.addEventListener(ev, applySummary);
                elRand?.addEventListener(ev, applySummary);
                elAmbient?.addEventListener(ev, applySummary);
                elBias?.addEventListener(ev, applySummary);
                elHeroSide?.addEventListener(ev, applySummary);
                elHeroRot?.addEventListener(ev, applySummary);
            });
            applyHeroVisibility();
            applySummary();

            // Presets
            const btnGallery = document.getElementById('wallart-preset-gallery');
            const btnHero = document.getElementById('wallart-preset-hero');
            const btnVibe = document.getElementById('wallart-preset-vibe');
            const btnResetW = document.getElementById('wallart-preset-reset');
            const setVal = (id, value, evs = ['input', 'change']) => {
                const el = document.getElementById(id);
                if (!el) return;
                if (el.type === 'checkbox') el.checked = !!value;
                else el.value = String(value);
                evs.forEach(e => el.dispatchEvent(new Event(e, { bubbles: true })));
            };
            const onPreset = p => {
                // Density, Layout, Anim, Refresh, Randomness, Ambient, Hero
                setVal('wallartMode_density', p.density ?? 'medium', ['change']);
                setVal('wallartMode_layoutVariant', p.layout ?? 'heroGrid', ['change']);
                setVal('wallartMode_animationType', p.animation ?? 'fade', ['change']);
                setVal('wallartMode_refreshRate', p.refresh ?? 5);
                setVal('wallartMode_randomness', p.randomness ?? 3);
                setVal('wallartMode_ambientGradient', !!p.ambient, ['change']);
                setVal('wallartMode_biasAmbientToHero', !!p.biasHero, ['change']);
                if (p.heroSide) setVal('wallartMode_heroSide', p.heroSide, ['change']);
                if (typeof p.heroRotationMinutes === 'number')
                    setVal('wallartMode_heroRotationMinutes', p.heroRotationMinutes, [
                        'input',
                        'change',
                    ]);
                applyHeroVisibility();
                applySummary();
                try {
                    window.__displayPreviewInit && (window.__forcePreviewUpdate?.() || 0);
                } catch (_) {
                    /* clock row visibility enforcement failed (layout ok) */
                }
            };
            btnGallery?.addEventListener('click', () =>
                onPreset({
                    density: 'high',
                    layout: 'classic',
                    animation: 'staggered',
                    refresh: 4,
                    randomness: 2,
                    ambient: false,
                    biasHero: false,
                })
            );
            btnHero?.addEventListener('click', () =>
                onPreset({
                    density: 'medium',
                    layout: 'heroGrid',
                    animation: 'fade',
                    refresh: 6,
                    randomness: 3,
                    ambient: true,
                    biasHero: true,
                    heroSide: 'left',
                    heroRotationMinutes: 8,
                })
            );
            btnVibe?.addEventListener('click', () =>
                onPreset({
                    density: 'low',
                    layout: 'classic',
                    animation: 'neonPulse',
                    refresh: 8,
                    randomness: 5,
                    ambient: true,
                    biasHero: false,
                })
            );
            btnResetW?.addEventListener('click', () =>
                onPreset({
                    density: 'medium',
                    layout: 'heroGrid',
                    animation: 'fade',
                    refresh: 5,
                    randomness: 3,
                    ambient: false,
                    biasHero: true,
                    heroSide: 'left',
                    heroRotationMinutes: 10,
                })
            );
        } catch (_) {
            /* wallart summary/preset wiring failed (form still editable) */
        }
    }

    function collectDisplayFormPatch() {
        const val = id => {
            const el = getVal(id);
            if (!el) return undefined;
            if (el.type === 'checkbox') return !!el.checked;
            if (el.type === 'number' || el.type === 'range') return Number(el.value);
            return el.value;
        };
        const active = document.querySelector('input[name="display.mode"]:checked')?.value;
        const wallartEnabled = active === 'wallart';
        const cinemaEnabled = active === 'cinema';
        // Build nested patch
        const patch = {
            // Global
            transitionIntervalSeconds: val('transitionIntervalSeconds'),
            transitionEffect: val('transitionEffect'),
            effectPauseTime: val('effectPauseTime'),
            clockWidget: val('clockWidget'),
            clockFormat: val('clockFormat'),
            clockTimezone: val('clockTimezone'),
            showPoster: val('showPoster'),
            showMetadata: val('showMetadata'),
            showClearLogo: val('showClearLogo'),
            showRottenTomatoes: val('showRottenTomatoes'),
            // Map 0–10 UI -> 0–100 schema; snap to nearest 0.5 and clamp 0..10; tolerate already-100 scale
            rottenTomatoesMinimumScore: (function () {
                const v = val('rottenTomatoesMinimumScore');
                if (v == null) return 0;
                const n = Number(v);
                if (!Number.isFinite(n)) return 0;
                const ui = n <= 10 ? n : n / 10;
                const clamped = Math.min(10, Math.max(0, ui));
                const snapped = Math.round(clamped * 2) / 2;
                return Math.round(snapped * 10);
            })(),
            uiScaling: {
                global: val('uiScaling_global'),
                content: val('uiScaling_content'),
                clearlogo: val('uiScaling_clearlogo'),
                clock: val('uiScaling_clock'),
            },
            // Sync
            syncEnabled: val('syncEnabled'),
            syncAlignMaxDelayMs: val('syncAlignMaxDelayMs'),
            // Modes
            cinemaMode: cinemaEnabled,
            cinemaOrientation: val('cinemaOrientation'),
            wallartMode: {
                enabled: wallartEnabled,
                density: val('wallartMode_density'),
                refreshRate: val('wallartMode_refreshRate'),
                randomness: val('wallartMode_randomness'),
                animationType: val('wallartMode_animationType'),
                layoutVariant: val('wallartMode_layoutVariant'),
                ambientGradient: val('wallartMode_ambientGradient'),
                layoutSettings: {
                    heroGrid: {
                        heroSide: val('wallartMode_heroSide'),
                        heroRotationMinutes: val('wallartMode_heroRotationMinutes'),
                        biasAmbientToHero: val('wallartMode_biasAmbientToHero'),
                    },
                },
            },
            // Cinema configuration collected from the modular UI
            cinema: (function () {
                try {
                    if (typeof window.__collectCinemaConfig === 'function') {
                        const cc = window.__collectCinemaConfig();
                        if (cc && typeof cc === 'object') return cc;
                    }
                } catch (_) {
                    /* number wrapper width bucket classification failed (defaults) */
                }
                return undefined; // let server merge preserve existing if UI not loaded
            })(),
            // Screensaver specific: none (backgroundRefreshMinutes managed in Operations)
        };
        // Root Route (landing vs redirect)
        try {
            const behavior = (
                document.getElementById('rootRoute_behavior')?.value || 'landing'
            ).trim();
            const defaultMode = (
                document.getElementById('rootRoute_defaultMode')?.value || 'screensaver'
            ).trim();
            const statusCodeStr = (
                document.getElementById('rootRoute_statusCode')?.value || '302'
            ).trim();
            const bypassParam = (
                document.getElementById('rootRoute_bypassParam')?.value || 'landing'
            ).trim();
            const statusCode = Number(statusCodeStr) === 307 ? 307 : 302;
            patch.rootRoute = { behavior, defaultMode, statusCode, bypassParam };
        } catch (_) {
            /* rootRoute UI not present; skip adding to patch */
        }
        // If screensaver active, ensure other modes disabled
        if (active === 'screensaver') {
            patch.cinemaMode = false;
            patch.wallartMode.enabled = false;
        }
        return patch;
    }

    async function initDisplaySection() {
        try {
            // Prefill
            const cfg = await loadAdminConfig();
            hydrateDisplayForm(cfg);
            // Hydrate Root Route UI
            try {
                const c = cfg?.config || cfg || {};
                const rr = c.rootRoute || {};
                const setSel = (id, val) => {
                    const el = document.getElementById(id);
                    if (el && val != null) el.value = String(val);
                };
                setSel('rootRoute_behavior', rr.behavior || 'landing');
                setSel('rootRoute_defaultMode', rr.defaultMode || 'screensaver');
                setSel('rootRoute_statusCode', String(rr.statusCode == 307 ? 307 : 302));
                const bp = document.getElementById('rootRoute_bypassParam');
                if (bp) bp.value = rr.bypassParam || 'landing';
            } catch (_) {
                /* missing rootRoute UI elements - safe to ignore */
            }

            // Default radio based on cfg
            const w = (cfg?.config || cfg)?.wallartMode || {};
            const mode = (cfg?.config || cfg)?.cinemaMode
                ? 'cinema'
                : w.enabled
                  ? 'wallart'
                  : 'screensaver';
            const radio = document.getElementById(`mode-${mode}`);
            if (radio && !radio.checked) {
                radio.checked = true;
            }
            // Ensure badges/cards reflect the chosen mode immediately
            setRadioGroupActive(mode);
            updateModeBadges(mode);

            // If cinema is selected at load time, force the preview iframe to initialize in portrait
            // by sending an early nudge after the frame wires up (handled later in initDisplayPreviewV2)
            try {
                window.__forcePreviewUpdate && window.__forcePreviewUpdate();
            } catch (_) {
                /* forcePreviewUpdate best-effort (preview will refresh on next interaction) */
            }

            // Save handler
            const saveBtn = document.getElementById('btn-save-display');
            saveBtn?.addEventListener('click', async () => {
                try {
                    saveBtn.classList.add('btn-loading');
                    const patch = collectDisplayFormPatch();
                    await (typeof saveConfigPatch === 'function'
                        ? saveConfigPatch(patch, {})
                        : (async () => {
                              const r = await fetch('/api/admin/config', {
                                  method: 'POST',
                                  headers: { 'Content-Type': 'application/json' },
                                  credentials: 'include',
                                  body: JSON.stringify({ config: patch, env: {} }),
                              });
                              if (!r.ok) throw new Error('Save failed');
                              try {
                                  if (typeof miniCache?.delete === 'function')
                                      miniCache.delete('/api/admin/config|GET');
                                  if (typeof inflight?.delete === 'function')
                                      inflight.delete('/api/admin/config|GET');
                              } catch (_) {
                                  /* config cache invalidation best-effort (non-fatal) */
                              }
                          })());

                    // Notify all tabs/windows to reload config via BroadcastChannel
                    try {
                        const channel = new BroadcastChannel('posterrama-config');
                        channel.postMessage({
                            type: 'config-updated',
                            timestamp: Date.now(),
                            settings: patch,
                        });
                        channel.close();
                    } catch (e) {
                        console.warn('[Admin] BroadcastChannel not supported or failed:', e);
                    }

                    window.notify?.toast({
                        type: 'success',
                        title: 'Display saved',
                        message: 'Settings saved successfully',
                        duration: 2000,
                    });
                } catch (e) {
                    window.notify?.toast({
                        type: 'error',
                        title: 'Save failed',
                        message: e?.message || 'Could not save display settings',
                        duration: 3500,
                    });
                } finally {
                    saveBtn?.classList.remove('btn-loading');
                }
            });
        } catch (e) {
            window.notify?.toast({
                type: 'error',
                title: 'Load failed',
                message: e?.message || 'Could not load display settings',
            });
        }
    }

    // ------- Admin v2 Display: Floating Live Preview wiring -------
    function initDisplayPreviewV2() {
        const container = document.getElementById('display-preview-container');
        const frame = document.getElementById('display-preview-frame');
        // Zoom removed per request
        const orientBtn = document.getElementById('toggle-preview-orientation');
        const zoomBtn = document.getElementById('toggle-preview-zoom');
        if (!container || !frame) return; // HTML not present, nothing to do

        // Debug instrumentation removed

        let previewWin = null;
        let lastPayload = null;
        let debounceTimer = null;
        // Track whether the user has manually moved the PiP; if so, don't auto-reanchor
        let userHasMovedPreview = false;
        // Preview-only orientation state for non-cinema modes
        let previewOrientation = 'landscape'; // 'landscape' | 'portrait'
        // Remember user's custom anchor after drag so we can preserve it across changes
        let lastUserAnchor = null; // { ax, ay }
        // Remember the last precise auto-anchor we placed to (when not user-moved)
        let lastAutoAnchor = null; // { ax, ay }
        // Anchor padding inside the Active Mode section (top-right inset)
        const ANCHOR_INSET = 8;

        // Compute the current visual top-right anchor point of the preview shell (window content)
        function getTopRightAnchorPoint() {
            const shell = container.querySelector('.preview-shell');
            const srect = shell?.getBoundingClientRect?.();
            if (!srect) {
                const crect = container.getBoundingClientRect();
                return { ax: crect.right, ay: crect.top };
            }
            return { ax: srect.right, ay: srect.top };
        }

        // Compute the desired anchor at the Active Mode card (top-right with padding)
        function getActiveModeAnchorPoint(inset = ANCHOR_INSET) {
            const card =
                document.getElementById('card-active-mode') ||
                document.getElementById('section-display');
            if (!card) return getTopRightAnchorPoint();
            const r = card.getBoundingClientRect();
            return { ax: r.right - inset, ay: r.top + inset };
        }

        // Position the container so that its visual top-right corner sits at the given anchor
        function setPositionFromTopRightAnchor(anchor) {
            if (!anchor) return;
            // Measure current visual top-right of the preview shell, then correct by the delta to target
            const crect = container.getBoundingClientRect();
            const shell = container.querySelector('.preview-shell');
            const srect = shell?.getBoundingClientRect?.() || crect;
            const currentAx = srect.right;
            const currentAy = srect.top;
            const dx = anchor.ax - currentAx;
            const dy = anchor.ay - currentAy;
            // Prefer existing computed left/top if available to avoid snapping relative to 0,0
            const cs = window.getComputedStyle(container);
            const parsedLeft = parseFloat(cs.left);
            const parsedTop = parseFloat(cs.top);
            const baseLeft = isFinite(parsedLeft)
                ? parsedLeft
                : isFinite(parseFloat(container.style.left))
                  ? parseFloat(container.style.left)
                  : crect.left;
            const baseTop = isFinite(parsedTop)
                ? parsedTop
                : isFinite(parseFloat(container.style.top))
                  ? parseFloat(container.style.top)
                  : crect.top;
            const l = baseLeft + dx;
            const t = baseTop + dy;
            container.style.left = l + 'px';
            container.style.top = t + 'px';
            container.style.right = 'auto';
            container.style.bottom = 'auto';
            // Post-set micro-correction to eliminate any fractional drift after layout settles
            requestAnimationFrame(() => {
                try {
                    const s2 = shell?.getBoundingClientRect?.();
                    if (!s2) return;
                    const fixDx = anchor.ax - s2.right;
                    const fixDy = anchor.ay - s2.top;
                    if (Math.abs(fixDx) > 0.1 || Math.abs(fixDy) > 0.1) {
                        const curLeft = parseFloat(container.style.left) || 0;
                        const curTop = parseFloat(container.style.top) || 0;
                        container.style.left = curLeft + fixDx + 'px';
                        container.style.top = curTop + fixDy + 'px';
                    }
                    // Ensure final position respects header and Display content bounds
                    clampWithinViewport(0);
                } catch (_) {
                    /* plex port sanitization setup failed (user input still validated server-side) */
                }
            });
        }

        function setVisible(on) {
            container.style.display = on ? 'block' : 'none';
            if (on) positionAtActiveMode();
        }

        // Compute visual metrics for the preview shell (accounts for CSS transform scale)
        function getVisualShellMetrics() {
            const shell = container.querySelector('.preview-shell');
            const Lw = shell?.clientWidth || container.offsetWidth || 420; // layout width (shell)
            const Lh = shell?.clientHeight || container.offsetHeight || 250; // layout height (shell)
            const srect = shell?.getBoundingClientRect?.() || {
                width: Lw,
                height: Lh,
                left: 0,
                top: 0,
            };
            const crect = container.getBoundingClientRect?.() || { left: 0, top: 0 };
            const Vw = srect.width || Lw; // visual width after scale
            const Vh = srect.height || Lh; // visual height after scale
            // With transform-origin set to 'top right', the visual box's top-right corner anchors
            // to the shell's top-right. The offset between the visual box and the container is
            // fully represented by the shell's boundingClientRect vs container rect.
            const offsetX = srect.left - crect.left || 0;
            const offsetY = srect.top - crect.top || 0;
            return { Vw, Vh, offsetX, offsetY };
        }

        // Clamp the current container position so the visual box stays below the navbar
        // and within the left/right edges of the Display Settings content. Bottom is
        // still clamped to the viewport as before.
        function clampWithinViewport(margin = 0) {
            try {
                const { Vw, Vh, offsetX, offsetY } = getVisualShellMetrics();
                const vw = window.innerWidth;
                const vh = window.innerHeight;

                // Top bound: below the fixed navbar plus a small inset
                const nav = document.querySelector('.navbar');
                const navRect = nav?.getBoundingClientRect?.();
                const headerBottom = navRect ? navRect.bottom : 0;
                const topInset = 8; // visual breathing room from navbar

                // Horizontal bounds: constrain to Display Settings content outer border
                const contentEl =
                    document.querySelector('#panel-display .panel-content') ||
                    document.querySelector('#section-display .panel-content') ||
                    document.getElementById('section-display');
                const contentRect = contentEl?.getBoundingClientRect?.();

                const boundLeft = contentRect ? contentRect.left : 0;
                const boundRight = contentRect ? contentRect.right : vw;

                const minLeft = boundLeft - offsetX; // keep visual box's left >= content left
                const maxLeft = Math.max(minLeft, boundRight - offsetX - Vw); // keep right <= content right
                const minTop = Math.max(0, headerBottom + topInset - offsetY); // below navbar
                const maxTop = Math.max(minTop, vh - margin - offsetY - Vh); // bottom to viewport
                const rect = container.getBoundingClientRect();
                const left = Math.min(Math.max(rect.left, minLeft), maxLeft);
                const top = Math.min(Math.max(rect.top, minTop), maxTop);
                const l = Math.round(left);
                const t = Math.round(top);
                container.style.top = t + 'px';
                container.style.left = l + 'px';
                container.style.right = 'auto';
                container.style.bottom = 'auto';
            } catch (_) {
                /* posterpack jellyfin library fetch failed (lists may remain empty) */
            }
        }

        // Position the preview near the top-right of the Active Mode card
        function positionAtActiveMode() {
            try {
                // If the user has manually moved the preview, do not re-anchor; just ensure it's clamped
                if (userHasMovedPreview) {
                    clampWithinViewport(0);
                    return;
                }
                const anchor = getActiveModeAnchorPoint(ANCHOR_INSET);
                setPositionFromTopRightAnchor(anchor);
                lastAutoAnchor = anchor;
            } catch (_) {
                /* header toggle text wiring failed (visual label remains static) */
            }
        }

        // Unified re-anchor helper used by resize/transition handlers
        function reanchorToCorrectPoint() {
            try {
                const anchor = userHasMovedPreview
                    ? lastUserAnchor || getTopRightAnchorPoint()
                    : getActiveModeAnchorPoint(ANCHOR_INSET);
                setPositionFromTopRightAnchor(anchor);
                if (!userHasMovedPreview) lastAutoAnchor = anchor;
            } catch (_) {
                /* force header toggle text refresh failed (non-critical) */
            }
        }

        // Expose a safe global nudge for re-anchoring after section navigation.
        // Waits for the Active Mode card to be measurable to avoid anchoring to a fallback.
        window.__previewReanchor = () => {
            try {
                // Make sure Display section is actually active and fully visible
                const section = document.getElementById('section-display');
                if (!section || !section.classList.contains('active')) return;

                // Ensure container reflects the current form mode and scale before measuring
                try {
                    const payload = collectPreviewPayload();
                    applyContainerMode(payload);
                    updateFrameScale();
                } catch (_) {
                    /* ensure jf libs discovery attempt failed (genre counts may be incomplete) */
                }

                // Disable transitions briefly to avoid visual drift when snapping
                container.classList.add('no-transition');
                setTimeout(() => container.classList.remove('no-transition'), 80);

                // If we have a remembered precise auto-anchor and the user hasn't moved it,
                // apply it immediately while we wait for the card to stabilize.
                if (!userHasMovedPreview && lastAutoAnchor) {
                    try {
                        setPositionFromTopRightAnchor(lastAutoAnchor);
                        clampWithinViewport(0);
                    } catch (_) {
                        /* jellyfin genre counts fetch (selected libs) failed - falling back */
                    }
                }

                let tries = 0;
                const maxTries = 24; // allow a few frames for layout/transition
                let lastRect = null;
                const tol = 0.5; // px tolerance for rect stability

                const isStable = (a, b) => {
                    if (!a || !b) return false;
                    return (
                        Math.abs(a.left - b.left) < tol &&
                        Math.abs(a.top - b.top) < tol &&
                        Math.abs(a.right - b.right) < tol &&
                        Math.abs(a.bottom - b.bottom) < tol
                    );
                };

                const tryAnchor = () => {
                    try {
                        // Wait for the section to be fully opaque (avoid measuring mid-transition)
                        const st = window.getComputedStyle(section);
                        if (parseFloat(st.opacity || '1') < 0.99) {
                            return requestAnimationFrame(tryAnchor);
                        }

                        const card = document.getElementById('card-active-mode');
                        const rect = card?.getBoundingClientRect?.();
                        const cardReady = !!rect && rect.width > 1 && rect.height > 1;

                        if (!userHasMovedPreview && cardReady) {
                            // Check stability across frames
                            if (lastRect && isStable(lastRect, rect)) {
                                const anchor = {
                                    ax: rect.right - ANCHOR_INSET,
                                    ay: rect.top + ANCHOR_INSET,
                                };
                                setPositionFromTopRightAnchor(anchor);
                                clampWithinViewport(0);
                                lastAutoAnchor = anchor;
                                return; // done
                            }
                            lastRect = rect;
                        } else if (userHasMovedPreview) {
                            // Preserve user anchor immediately, but ignore invalid/zero anchors
                            let anchor = lastUserAnchor;
                            const valid =
                                !!anchor &&
                                isFinite(anchor.ax) &&
                                isFinite(anchor.ay) &&
                                (anchor.ax !== 0 || anchor.ay !== 0);
                            if (!valid) {
                                // Try to measure current shell; if not valid yet, retry next frame
                                const p = getTopRightAnchorPoint();
                                const ok =
                                    !!p &&
                                    isFinite(p.ax) &&
                                    isFinite(p.ay) &&
                                    (p.ax !== 0 || p.ay !== 0);
                                if (ok) anchor = p;
                            }
                            if (anchor) {
                                setPositionFromTopRightAnchor(anchor);
                                clampWithinViewport(0);
                                return; // done
                            }
                            if (tries++ < maxTries) return requestAnimationFrame(tryAnchor);
                        }

                        if (tries++ < maxTries) {
                            requestAnimationFrame(() => {
                                // Keep scale updated in case layout changed
                                try {
                                    updateFrameScale();
                                } catch (_) {
                                    /* preview scale refresh failed (will retry on next frame) */
                                }
                                tryAnchor();
                            });
                        } else {
                            // Final fallback: if we have a remembered anchor, use it; else standard re-anchor
                            if (!userHasMovedPreview && lastAutoAnchor) {
                                setPositionFromTopRightAnchor(lastAutoAnchor);
                                clampWithinViewport(0);
                            } else {
                                reanchorToCorrectPoint();
                                clampWithinViewport(0);
                            }
                        }
                    } catch (_) {
                        /* nested wrapper collapse (dedupe) failed (benign) */
                    }
                };

                // Kick off the retry loop on the next frame
                requestAnimationFrame(tryAnchor);
            } catch (_) {
                /* aria-hidden attribute set failed (cosmetic only) */
            }
        };

        function collectPreviewPayload() {
            // Reuse existing patch builder; it produces the shape expected by /preview runtime
            return collectDisplayFormPatch();
        }

        function shouldHardReset(prev, next) {
            if (!prev) return false;
            // ONLY hard-reset when the active MODE changes (cinema/wallart/screensaver transitions)
            // All other setting changes should be applied live via applySettings
            const prevCinema = !!prev.cinemaMode;
            const nextCinema = !!next.cinemaMode;
            const prevWallart = !!(prev.wallartMode && prev.wallartMode.enabled);
            const nextWallart = !!(next.wallartMode && next.wallartMode.enabled);

            // Determine previous and next modes
            const prevMode = prevCinema ? 'cinema' : prevWallart ? 'wallart' : 'screensaver';
            const nextMode = nextCinema ? 'cinema' : nextWallart ? 'wallart' : 'screensaver';

            // Only reset if mode changed
            return prevMode !== nextMode;
        }

        function hardReset() {
            try {
                // Determine the target display route based on current mode
                const payload = collectPreviewPayload();
                const isCinema = !!payload.cinemaMode;
                const isWallart = !!(payload.wallartMode && payload.wallartMode.enabled);

                let targetPath = '/screensaver';
                if (isCinema) targetPath = '/cinema';
                else if (isWallart) targetPath = '/wallart';

                // Set iframe src to the actual display page with preview flag
                const newSrc = `${targetPath}?preview=1&cb=${Date.now()}`;
                frame.setAttribute('src', newSrc);
            } catch (_) {
                // Fallback: reload current page
                try {
                    frame.contentWindow?.location.reload();
                } catch (_) {
                    const src = frame.getAttribute('src') || '/screensaver?preview=1';
                    frame.setAttribute('src', src.split('?')[0] + '?preview=1&cb=' + Date.now());
                }
            }
        }

        function applyContainerMode(payload) {
            const isCinema = !!payload.cinemaMode;
            const isWallart = !!(payload.wallartMode && payload.wallartMode.enabled);
            container.classList.toggle('cinema-mode', isCinema);
            container.classList.toggle('wallart-mode', isWallart);
            container.classList.toggle('screensaver-mode', !isCinema && !isWallart);
            // In Cinema preview, orientation follows the form selection; the toggle button is hidden
            if (orientBtn) orientBtn.style.display = isCinema ? 'none' : '';
            // Cinema preview MUST always be portrait (window and content), regardless of form selection
            const portrait = isCinema ? true : previewOrientation === 'portrait';
            container.classList.toggle('portrait', portrait);
            container.classList.toggle('landscape', !portrait);
        }

        function updateFrameScale() {
            const isPortrait = container.classList.contains('portrait');
            // Simulate device resolution base for correct proportions in all modes
            const baseW = isPortrait ? 1080 : 1920;
            const baseH = isPortrait ? 1920 : 1080;
            const shell = container.querySelector('.preview-shell');
            const frameEl = container.querySelector('.preview-frame');
            if (!shell || !frameEl) return;
            // Compute available inner size (shell itself is sized via aspect-ratio and CSS), then scale iframe content
            // We set iframe to base size and scale down to fit shell
            frameEl.style.width = baseW + 'px';
            frameEl.style.height = baseH + 'px';
            // shell content box
            const cw = shell.clientWidth;
            const ch = shell.clientHeight;
            // Slight overscan to hide thin black edges and make the switch seamless
            const overscan = 1.015; // ~1.5%
            const scale = Math.max(0.01, Math.min(cw / baseW, ch / baseH)) * overscan;
            frameEl.style.transform = `translate(-50%, -50%) scale(${scale})`;
            frameEl.style.transformOrigin = 'center center';
            frameEl.style.left = '50%';
            frameEl.style.top = '50%';
        }

        function ensureCorrectPreviewRoute(payload) {
            // Ensure iframe is pointing to the correct display route for the current mode
            const isCinema = !!payload.cinemaMode;
            const isWallart = !!(payload.wallartMode && payload.wallartMode.enabled);

            let expectedPath = '/screensaver';
            if (isCinema) expectedPath = '/cinema';
            else if (isWallart) expectedPath = '/wallart';

            // Check current iframe src
            const currentSrc = frame.getAttribute('src') || '';
            const currentPath = currentSrc.split('?')[0];

            // If path doesn't match, update it
            if (currentPath !== expectedPath) {
                const newSrc = `${expectedPath}?preview=1&cb=${Date.now()}`;
                frame.setAttribute('src', newSrc);
                return true; // Indicates we did a route change
            }
            return false; // No route change needed
        }

        function sendUpdate() {
            if (!previewWin) return;
            const payload = collectPreviewPayload();

            // Check if we need to switch to a different display route
            const didRouteChange = ensureCorrectPreviewRoute(payload);
            if (didRouteChange) {
                // Route changed, iframe will reload - wait for it
                lastPayload = payload;
                return;
            }

            if (shouldHardReset(lastPayload, payload)) {
                lastPayload = payload;
                return hardReset();
            }

            lastPayload = payload;
            // Reflect mode/orientation on the container so aspect and scale update smoothly
            applyContainerMode(payload);
            // Wait a frame then rescale to accommodate CSS transitions
            requestAnimationFrame(() => {
                updateFrameScale();
                // After scale change, re-anchor to corner to account for visual size
                positionAtActiveMode();
            });
            try {
                // Force portrait for Cinema in the preview content regardless of form value
                const postPayload =
                    typeof structuredClone === 'function'
                        ? structuredClone(payload)
                        : JSON.parse(JSON.stringify(payload));
                if (postPayload.cinemaMode) {
                    postPayload.cinemaOrientation = 'portrait';
                }
                previewWin.postMessage(
                    { type: 'posterrama.preview.update', payload: postPayload },
                    window.location.origin
                );
            } catch (_) {
                /* update modal aria-hidden sync failed (visual state still closed) */
            }
        }
        // Expose a minimal hook for other UI parts to nudge the preview
        window.__forcePreviewUpdate = () => {
            try {
                sendUpdate();
            } catch (_) {
                /* aria-hidden attribute sync failed (modal accessibility may be stale) */
            }
        };

        function debouncedSend() {
            if (debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = setTimeout(sendUpdate, 120);
        }

        frame.addEventListener('load', () => {
            previewWin = frame.contentWindow;
            // Initial sync after iframe is ready
            sendUpdate();
            positionAtActiveMode();
            // Listen to container/shell size changes for smooth updates
            try {
                const onResizeOrShell = () => {
                    updateFrameScale();
                    reanchorToCorrectPoint();
                };
                if (window.ResizeObserver) {
                    const shell = container.querySelector('.preview-shell');
                    const ro = new ResizeObserver(onResizeOrShell);
                    if (shell) ro.observe(shell);
                    // Also re-anchor precisely after width/height/transform transitions settle
                    shell?.addEventListener('transitionend', e => {
                        if (
                            e &&
                            (e.propertyName === 'width' ||
                                e.propertyName === 'height' ||
                                e.propertyName === 'transform')
                        ) {
                            // Allow final style to apply, then rescale and re-anchor
                            requestAnimationFrame(() => {
                                updateFrameScale();
                                reanchorToCorrectPoint();
                            });
                        }
                    });
                }
                window.addEventListener('resize', onResizeOrShell);
            } catch (_) {
                /* aria-hidden attribute sync failed (modal accessibility may be stale) */
            }
        });

        // If the iframe already loaded before this wiring, use current contentWindow and try an initial send
        try {
            if (frame.contentWindow) {
                previewWin = frame.contentWindow;
                // Fire two staged attempts to cover document ready timing inside preview
                setTimeout(sendUpdate, 0);
                setTimeout(sendUpdate, 200);
            }
        } catch (_) {
            /* poster->metadata dependency wiring failed */
        }

        // Wire global input/change handlers within Display section
        const section = document.getElementById('section-display');
        if (section) {
            const handler = () => debouncedSend();
            section.addEventListener('input', handler, true);
            section.addEventListener('change', handler, true);
        }

        // Extra targeted listeners for cinema toggles where structural reset is needed
        const cinemaToggle = document.getElementById('mode-cinema');
        cinemaToggle?.addEventListener('change', () => {
            const next = collectPreviewPayload();
            if (shouldHardReset(lastPayload, next)) {
                lastPayload = next;
                hardReset();
            } else {
                debouncedSend();
            }
        });
        const orientSel = document.getElementById('cinemaOrientation');
        orientSel?.addEventListener('change', () => {
            const next = collectPreviewPayload();
            if (shouldHardReset(lastPayload, next)) {
                lastPayload = next;
                hardReset();
            } else {
                // Orientation change: maintain anchor
                try {
                    const anchor = userHasMovedPreview
                        ? lastUserAnchor || getTopRightAnchorPoint()
                        : getActiveModeAnchorPoint(ANCHOR_INSET);
                    setPositionFromTopRightAnchor(anchor);
                } catch (_) {
                    /* device metrics inline update failed (non-critical) */
                }
                debouncedSend();
            }
        });

        // Zoom toggle: default 0.8x → 1.4x (and back). Preserve top-right anchor across zoom changes.
        zoomBtn?.addEventListener('click', () => {
            try {
                const shell = container.querySelector('.preview-shell');
                if (!shell) return;
                // Capture current anchor before changing scale
                const anchor = userHasMovedPreview
                    ? lastUserAnchor || getTopRightAnchorPoint()
                    : getActiveModeAnchorPoint(ANCHOR_INSET);
                const current = getComputedStyle(shell).getPropertyValue('--preview-scale').trim();
                const currVal = current ? parseFloat(current) : 0.8;
                const nextVal = Math.abs(currVal - 1.4) < 0.01 ? 0.8 : 1.4;
                shell.style.setProperty('--preview-scale', String(nextVal));
                // After transform, re-anchor twice to account for async layout/transform
                requestAnimationFrame(() => {
                    setPositionFromTopRightAnchor(anchor);
                    requestAnimationFrame(() => setPositionFromTopRightAnchor(anchor));
                });
            } catch (_) {
                /* aria-hidden attribute sync failed (modal accessibility may be stale) */
            }
        });

        // Orientation toggle for non-cinema modes: landscape <-> portrait
        orientBtn?.addEventListener('click', () => {
            // Only applies in Screensaver/Wallart; hidden in Cinema
            // Capture the current anchor before changing orientation; if we're
            // in landscape now, remember it for exact restoration
            // Capture user anchor only if they had previously dragged
            if (userHasMovedPreview) {
                try {
                    lastUserAnchor = getTopRightAnchorPoint();
                } catch (_) {
                    /* device metrics refresh scheduling failed (dashboard still usable) */
                }
            }
            previewOrientation = previewOrientation === 'portrait' ? 'landscape' : 'portrait';
            // Update container immediately for visual aspect switch
            try {
                const payload = collectPreviewPayload();
                applyContainerMode(payload);
            } catch (_) {
                /* slider bar initial width calc failed (visual only) */
            }
            requestAnimationFrame(() => {
                updateFrameScale();
                // After dimensions settle, keep the same visual top-right anchor
                reanchorToCorrectPoint();
                // Extra nudge on next frame in case transform finishes one frame later
                requestAnimationFrame(reanchorToCorrectPoint);
            });
            // No config change needed; just update the preview
            sendUpdate();
        });

        // Keep orientation control visibility and shell aspect in sync with active mode
        const modeRadios = document.querySelectorAll('input[name="display.mode"]');
        modeRadios.forEach(r => {
            r.addEventListener('change', () => {
                // Apply immediately and rescale
                try {
                    const payload = collectPreviewPayload();
                    applyContainerMode(payload);
                } catch (_) {
                    /* populate existing locations failed (datalist will simply be empty) */
                }
                requestAnimationFrame(() => {
                    updateFrameScale();
                    // Maintain the anchor across mode switches
                    reanchorToCorrectPoint();
                    requestAnimationFrame(reanchorToCorrectPoint);
                });
                // Update the preview content too
                sendUpdate();
            });
        });

        // Ensure visibility aligns with current section on init
        const isDisplayActive = document
            .getElementById('section-display')
            ?.classList.contains('active');
        setVisible(!!isDisplayActive);
        if (isDisplayActive) {
            // Avoid initial pop: disable transitions for a tick
            container.classList.add('no-transition');
            setTimeout(() => container.classList.remove('no-transition'), 80);
            positionAtActiveMode();
            // One more nudge next frame for absolute parity
            requestAnimationFrame(() => reanchorToCorrectPoint());
        }
        // Initialize container classes based on current form for correct aspect immediately
        try {
            const payload0 = collectPreviewPayload();
            applyContainerMode(payload0);
        } catch (_) {
            /* clock timezone/format row visibility enforcement failed */
        }
        // Initial scale sync
        requestAnimationFrame(updateFrameScale);

        // ----- Draggable behavior for the preview (container moves) -----
        (function makeDraggable() {
            const grip = container.querySelector('.preview-drag-handle');
            if (!grip) return;

            let dragging = false;
            let startX = 0;
            let startY = 0;
            let startTop = 0;
            let startLeft = 0;
            let minTop = 0;
            let maxTop = 0;
            let minLeft = 0;
            let maxLeft = 0;
            let rafId = null;
            let pending = null; // {left, top}

            function computeBounds() {
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                // Use the same visual metrics helper to account for scale and chrome offsets
                const { Vw, Vh, offsetX, offsetY } = getVisualShellMetrics();

                // Top bound: below navbar
                const nav = document.querySelector('.navbar');
                const navRect = nav?.getBoundingClientRect?.();
                const headerBottom = navRect ? navRect.bottom : 0;
                const topInset = 8;

                // Left/right bounds: Display Settings content area
                const contentEl =
                    document.querySelector('#panel-display .panel-content') ||
                    document.querySelector('#section-display .panel-content') ||
                    document.getElementById('section-display');
                const contentRect = contentEl?.getBoundingClientRect?.();

                const boundLeft = contentRect ? contentRect.left : 0;
                const boundRight = contentRect ? contentRect.right : vw;

                minTop = Math.max(0, headerBottom + topInset - offsetY);
                maxTop = Math.max(minTop, vh - 8 - offsetY - Vh); // keep existing bottom clamp to viewport
                minLeft = boundLeft - offsetX;
                maxLeft = Math.max(minLeft, boundRight - offsetX - Vw);
            }

            function setPos(left, top) {
                container.style.top = top + 'px';
                container.style.left = left + 'px';
                container.style.right = 'auto';
                container.style.bottom = 'auto';
            }

            function scheduleMove(left, top) {
                pending = { left, top };
                if (rafId) return;
                rafId = requestAnimationFrame(() => {
                    rafId = null;
                    if (!pending) return;
                    setPos(pending.left, pending.top);
                    pending = null;
                });
            }

            function onPointerDown(e) {
                try {
                    // Use pointer events for unified mouse/touch/pen handling
                    grip.setPointerCapture?.(e.pointerId);
                    dragging = true;
                    container.classList.add('dragging');
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = container.getBoundingClientRect();
                    startTop = rect.top;
                    startLeft = rect.left;
                    computeBounds();
                    e.preventDefault();
                } catch (_) {
                    /* overlay rect debug logging failed (diagnostic only) */
                }
            }

            function onPointerMove(e) {
                if (!dragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                let left = startLeft + dx;
                let top = startTop + dy;
                // Clamp to precomputed bounds
                if (left < minLeft) left = minLeft;
                else if (left > maxLeft) left = maxLeft;
                if (top < minTop) top = minTop;
                else if (top > maxTop) top = maxTop;
                scheduleMove(left, top);
                e.preventDefault();
            }

            function onPointerUp(e) {
                const wasDragging = dragging;
                dragging = false;
                container.classList.remove('dragging');
                if (wasDragging) {
                    // Mark that the user has intentionally moved the PiP; suppress future auto-reanchors
                    userHasMovedPreview = true;
                    try {
                        // Snap to integer pixel positions before storing anchor
                        const rect = container.getBoundingClientRect();
                        container.style.left = Math.round(rect.left) + 'px';
                        container.style.top = Math.round(rect.top) + 'px';
                        lastUserAnchor = getTopRightAnchorPoint();
                    } catch (_) {
                        /* hovercard status live-refresh failed (will retry next cycle) */
                    }
                }
                try {
                    grip.releasePointerCapture?.(e.pointerId);
                } catch (_) {
                    /* live reconcile diff check failed (non-fatal; will retry next cycle) */
                }
            }

            // Prefer Pointer Events; fall back to mouse/touch if not supported
            const supportsPointer = 'onpointerdown' in window;
            if (supportsPointer) {
                grip.addEventListener('pointerdown', onPointerDown);
                window.addEventListener('pointermove', onPointerMove, { passive: false });
                window.addEventListener('pointerup', onPointerUp);
                window.addEventListener('pointercancel', onPointerUp);
            } else {
                // Fallback (rare)
                const onDown = ev => {
                    dragging = true;
                    container.classList.add('dragging');
                    const e = ev.touches ? ev.touches[0] : ev;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = container.getBoundingClientRect();
                    startTop = rect.top;
                    startLeft = rect.left;
                    computeBounds();
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onUp);
                    ev.preventDefault();
                };
                const onMove = ev => {
                    if (!dragging) return;
                    const e = ev.touches ? ev.touches[0] : ev;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    let left = startLeft + dx;
                    let top = startTop + dy;
                    if (left < minLeft) left = minLeft;
                    else if (left > maxLeft) left = maxLeft;
                    if (top < minTop) top = minTop;
                    else if (top > maxTop) top = maxTop;
                    scheduleMove(left, top);
                    if (ev.cancelable) ev.preventDefault();
                };
                const onUp = () => {
                    const wasDragging = dragging;
                    dragging = false;
                    container.classList.remove('dragging');
                    if (wasDragging) userHasMovedPreview = true;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onUp);
                };
                grip.addEventListener('mousedown', onDown);
                grip.addEventListener('touchstart', onDown, { passive: false });
            }
        })();

        // Optional: developer hook to reset/snap back to the corner on demand
        window.__resetPreviewPosition = () => {
            try {
                userHasMovedPreview = false;
                positionAtActiveMode();
            } catch (_) {
                /* slider preset button click failed (user can adjust manually) */
            }
        };
    }

    async function refreshApiKeyStatus() {
        try {
            // API key status
            const statusRes = await fetch('/api/admin/api-key/status', { credentials: 'include' });
            const status = statusRes.ok ? await statusRes.json() : { hasKey: false };
            const hasKey = !!status?.hasKey;
            const statusText = document.getElementById('api-key-status-text');
            const statusPill = document.getElementById('api-key-status-pill');
            const display = document.getElementById('api-key-display');
            const revokeBtn = document.getElementById('revoke-api-key-button');
            if (statusText) statusText.textContent = hasKey ? 'Present' : 'None';
            if (statusPill) {
                statusPill.classList.remove('status-success', 'status-warning');
                statusPill.classList.add(hasKey ? 'status-success' : 'status-warning');
            }
            if (display) display.classList.toggle('is-hidden', !hasKey);
            if (revokeBtn) revokeBtn.disabled = !hasKey;
            if (hasKey) {
                // Fetch the masked value (we'll still show as password field)
                const keyRes = await fetch('/api/admin/api-key', { credentials: 'include' });
                const keyData = keyRes.ok ? await keyRes.json() : { apiKey: '' };
                const input = document.getElementById('api-key-input');
                if (input) input.value = keyData.apiKey || '';
            }
        } catch (e) {
            console.warn('API key status refresh failed', e);
        }
    }

    async function refreshSecurity() {
        // Note: Security panel has been removed, this function is kept for compatibility
        // with existing 2FA handlers in the user menu
        // Security panel refresh requested (panel removed, skipping)
    }

    function openModal(id) {
        const m = document.getElementById(id);
        if (!m) return;
        m.classList.add('open');
        m.removeAttribute('hidden');
        m.setAttribute('aria-hidden', 'false');
        const isOverlay = m.classList.contains('modal-overlay');
        if (isOverlay) {
            // Ensure overlay container is visible
            // Record original inline styles (only once) so we can restore on close
            if (!m.__origStyle) m.__origStyle = m.getAttribute('style') || '';
            m.style.display = 'flex';
            m.style.pointerEvents = 'auto';
            m.style.visibility = 'visible';
            m.style.opacity = '1';
            m.style.zIndex = '14000';
            // Also enforce inner modal if present
            const inner = m.querySelector('.modal');
            if (inner) {
                if (!inner.__origStyle) inner.__origStyle = inner.getAttribute('style') || '';
                inner.style.opacity = '1';
                inner.style.transform = 'translateY(0) scale(1)';
                inner.style.pointerEvents = 'auto';
            }
        }
        // Fallback ensureVisible (shared utility)
        try {
            window.__ensureVisible?.(m, 'modal');
        } catch (_) {
            /* initial mode indicator frame deferred layout failed (will self-correct on next resize) */
        }
        // If still zero-sized, attempt to clone structure into body (portal) while keeping original for reference
        try {
            const r = m.getBoundingClientRect();
            if ((r.width === 0 || r.height === 0) && m.parentElement !== document.body) {
                document.body.appendChild(m);
                m.setAttribute('data-portal', 'true');
                window.__ensureVisible?.(m, 'modal');
            }
        } catch (_) {
            /* portal relocation after showOverlay failed (overlay remains visible) */
        }
        // Focus first focusable element inside modal for accessibility
        try {
            const first = m.querySelector(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            first?.focus?.();
        } catch (_) {
            /* focus-first element not found (accessibility enhancement optional) */
        }
    }
    // Unified overlay show helper (for legacy direct handlers using classList only)
    function __showOverlay(el, label = 'overlay') {
        if (!el) return;
        try {
            if (el.__origStyle === undefined) {
                el.__origStyle = el.getAttribute('style') || '';
            }
            if (el.hasAttribute('hidden')) el.removeAttribute('hidden');
            el.setAttribute('aria-hidden', 'false');
            el.classList.add('open');
            if (window.__ensureVisible) window.__ensureVisible(el, 'modal');
            const r = el.getBoundingClientRect();
            if (r.width === 0 || r.height === 0) {
                console.warn('[ModalDebug] zero-rect after showOverlay', label, r.toJSON());
                // Force minimal sizing try
                try {
                    el.style.minWidth = el.style.minWidth || '320px';
                    el.style.minHeight = el.style.minHeight || '160px';
                    el.style.display = 'flex';
                    el.style.position = 'fixed';
                    el.style.inset = '0';
                    el.style.zIndex = '14000';
                    // Diagnostics: log ancestor display chain
                    const chain = [];
                    let p = el.parentElement;
                    while (p && chain.length < 8) {
                        const cs = getComputedStyle(p);
                        chain.push({
                            tag: p.tagName.toLowerCase(),
                            id: p.id,
                            cls: p.className,
                            display: cs.display,
                            visibility: cs.visibility,
                            opacity: cs.opacity,
                            transform: cs.transform,
                        });
                        p = p.parentElement;
                    }
                    console.warn('[ModalDebug] ancestor chain', label, chain);
                    // If parent chain suggests any ancestor has display:none, portal to body
                    const hiddenAncestor = chain.find(a => a.display === 'none');
                    if (hiddenAncestor || el.parentElement !== document.body) {
                        try {
                            document.body.appendChild(el);
                            el.setAttribute('data-portal', 'true');
                            console.warn(
                                '[ModalDebug] portal relocation applied',
                                label,
                                hiddenAncestor
                            );
                        } catch (_) {
                            /* portalize attempt failed; keep original parent */
                        }
                    }
                    // Retry measurement after potential portal
                    requestAnimationFrame(() => {
                        try {
                            const r2 = el.getBoundingClientRect();
                            if (r2.width === 0 || r2.height === 0) {
                                // Final hard style attempt
                                el.style.width = '100vw';
                                el.style.height = '100vh';
                                el.style.alignItems = 'center';
                                el.style.justifyContent = 'center';
                                console.error(
                                    '[ModalDebug] still zero-rect after portal & hard sizing',
                                    label,
                                    r2.toJSON()
                                );
                            } else {
                                console.info(
                                    '[ModalDebug] rect recovered after portal sizing',
                                    label,
                                    r2.toJSON()
                                );
                            }
                        } catch (_) {
                            /* retry measurement failed (diagnostic only) */
                        }
                    });
                } catch (_) {
                    /* hard sizing attempt failed (will remain at default sizing) */
                }
            }
        } catch (e) {
            console.warn('[ModalDebug] showOverlay failed', label, e);
        }
    }

    // Media source enablement helpers
    function isJellyfinEnabledCached() {
        try {
            if (window.__jfEnabledCache !== undefined) return window.__jfEnabledCache;
            const cfg = window.__adminConfig || window.__appConfig || {};
            const servers = Array.isArray(cfg?.config?.mediaServers)
                ? cfg.config.mediaServers
                : Array.isArray(cfg?.mediaServers)
                  ? cfg.mediaServers
                  : [];
            const jf = servers.find(s => (s.type || '').toLowerCase() === 'jellyfin');
            const enabled = !!jf && jf.enabled !== false; // default true unless explicitly false
            window.__jfEnabledCache = enabled;
            return enabled;
        } catch (_) {
            return true; // fail open (will attempt, backend still validates)
        }
    }
    // Expose for external callers / guards
    try {
        if (!window.__showOverlay) window.__showOverlay = __showOverlay;
    } catch (_) {
        /* expose __showOverlay best-effort (not critical) */
    }
    try {
        // Removed legacy __ensureVisible exposure (debug helper) – no longer needed
    } catch (_) {
        /* legacy __ensureVisible exposure intentionally disabled */
    }
    try {
        window.forceModalPortal = function (id) {
            const el = document.getElementById(id);
            if (!el) return false;
            document.body.appendChild(el);
            el.setAttribute('data-portal', 'true');
            __showOverlay(el, id + ':force');
            return true;
        };
        window.disableNotifWatchdog = () => {
            if (window.__notifPortalWatch) {
                clearInterval(window.__notifPortalWatch);
                window.__notifPortalWatch = null;
                // debug removed
            }
        };
    } catch (_) {
        /* modal helpers exposure failed (optional) */
    }
    function closeModal(id) {
        const m = document.getElementById(id);
        if (!m) return;
        try {
            // If a focused element is inside, blur it first to avoid aria-hidden warning
            const active = document.activeElement;
            if (active && m.contains(active)) {
                active.blur();
            }
        } catch (_) {
            /* posterpack server filter options load failed (user can retry) */
        }
        m.classList.remove('open');
        m.setAttribute('aria-hidden', 'true');
        // Restore original inline styles if we overrode them
        try {
            if (m.__origStyle !== undefined) {
                if (m.__origStyle) m.setAttribute('style', m.__origStyle);
                else m.removeAttribute('style');
            }
            const inner = m.querySelector('.modal');
            if (inner && inner.__origStyle !== undefined) {
                if (inner.__origStyle) inner.setAttribute('style', inner.__origStyle);
                else inner.removeAttribute('style');
            }
            // If portal relocation added sizing overrides but no original style existed, enforce hidden
            if (!m.__origStyle) {
                m.style.display = 'none';
            }
        } catch (_) {
            /* awaiting posterpack filter preload failed (safe to reset in future attempt) */
        }
        // Keep DOM footprint small; rely on CSS .open to show. If it had explicit hidden originally, restore.
        if (m.hasAttribute('data-auto-hidden')) {
            m.setAttribute('hidden', '');
        }
    }
    // Expose for any legacy or inline triggers
    try {
        window.openModal = openModal;
        window.closeModal = closeModal;
    } catch (_) {
        /* exposing modal open/close helpers failed (non-critical) */
    }
    // Global backdrop click handler (capture outside inner modal)
    document.addEventListener('click', e => {
        try {
            const target = e.target;
            if (!(target instanceof Element)) return;
            const overlay = target.closest('.modal-overlay');
            if (!overlay) return; // not inside an overlay
            const inner = target.closest('.modal');
            if (!inner && overlay.classList.contains('open')) {
                // Click directly on backdrop area
                const id = overlay.id;
                if (id) closeModal(id);
            }
        } catch (_) {
            /* backdrop click-to-close failed (ignored) */
        }
    });
    async function confirmAction({
        title = 'Confirm',
        message = 'Are you sure?',
        okText = 'Confirm',
        okClass = 'btn-primary',
        okIcon = null, // override icon (font-awesome name, without fa-). If null auto-selects.
    } = {}) {
        return new Promise(resolve => {
            const overlay = document.getElementById('modal-confirm');
            if (!overlay) return resolve(false);
            __showOverlay(overlay, 'modal-confirm');
            let titleEl = document.getElementById('modal-confirm-title');
            let bodyEl = document.getElementById('modal-confirm-body');
            let okBtn = document.getElementById('modal-confirm-ok');

            function applyContent() {
                // Re-query in case DOM changed
                titleEl = document.getElementById('modal-confirm-title');
                bodyEl = document.getElementById('modal-confirm-body');
                okBtn = document.getElementById('modal-confirm-ok');
                if (titleEl) titleEl.innerHTML = `<i class="fas fa-question-circle"></i> ${title}`;
                if (bodyEl) {
                    // Allow simple HTML (strong, em) in message
                    bodyEl.innerHTML = message;
                }
                if (okBtn) {
                    // Preserve foundational button classes (btn + btn-secondary btn-sm) while applying accent override.
                    // okClass may be passed as a legacy single class (e.g., 'btn-magenta-solid') or multiple.
                    const baseClasses = ['btn', 'btn-secondary', 'btn-sm'];
                    const extra = (okClass || '')
                        .split(/\s+/)
                        .filter(Boolean)
                        .filter(c => !baseClasses.includes(c));
                    okBtn.className = [...baseClasses, ...extra].join(' ');
                    const isDanger =
                        String(okClass || '').includes('btn-error') ||
                        String(okClass || '').includes('btn-danger') ||
                        /delete|remove|clear/i.test(okText || '');
                    const icon = okIcon || (isDanger ? 'trash' : 'check');
                    okBtn.innerHTML = `<i class="fas fa-${icon}"></i><span>${okText}</span>`;
                }
            }
            applyContent();
            // If elements weren't present yet (rare), retry on next frame
            if (!okBtn || !titleEl) {
                requestAnimationFrame(() => applyContent());
            }
            function cleanup(val) {
                overlay.classList.remove('open');
                overlay.setAttribute('hidden', '');
                okBtn?.removeEventListener('click', onOk);
                cancelBtn?.removeEventListener('click', onCancel);
                closeBtns.forEach(b => b.removeEventListener('click', onCancel));
                resolve(val);
            }
            function onOk() {
                cleanup(true);
            }
            function onCancel() {
                cleanup(false);
            }
            const cancelBtn = overlay.querySelector('[data-close-modal]');
            const closeBtns = overlay.querySelectorAll('[data-close-modal]');
            okBtn?.addEventListener('click', onOk);
            closeBtns.forEach(b => b.addEventListener('click', onCancel));
            // Esc key support
            overlay.addEventListener(
                'keydown',
                e => {
                    if (e.key === 'Escape') {
                        e.stopPropagation();
                        onCancel();
                    }
                },
                { once: true }
            );
            // Focus the primary action for accessibility
            setTimeout(() => {
                try {
                    okBtn?.focus();
                } catch (_) {
                    /* focus on OK button failed (accessibility enhancement optional) */
                }
            }, 0);
            overlay.classList.add('open');
        });
    }

    // Expose confirmAction globally so section scripts (e.g., Cinema UI) can use the themed modal
    try {
        window.confirmAction = confirmAction;
    } catch (_) {
        /* expose confirmAction is best-effort; ignore in hardened environments */
    }

    function wireEvents() {
        // Prevent duplicate wiring (DOMContentLoaded + immediate call race)
        if (window.__admin2Wired) return;
        window.__admin2Wired = true;
        // Live updates via SSE (logs). Falls back to polling below.
        (function initAdminEvents() {
            try {
                // Debounced notifier used by all SSE events
                const pump = debounce(() => {
                    try {
                        if (typeof window.refreshAdminBadge === 'function') {
                            window.refreshAdminBadge();
                        }
                    } catch (_) {
                        /* nested slider bar update failed (skip this input) */
                    }
                }, 2000);

                // Create/restore SSE with backoff when closed
                let reconnectTimer = null;
                const establishSSE = () => {
                    try {
                        const existing = window.__adminSSE;
                        if (existing && existing.readyState !== 2 /* CLOSED */) return;
                    } catch (_) {
                        /* hovercard media live-refresh failed (will retry next cycle) */
                    }

                    try {
                        const src = new EventSource('/api/admin/events');
                        window.__adminSSE = src;

                        src.addEventListener('log', () => pump());
                        src.addEventListener('hello', () => pump());
                        // Generic message fallback
                        src.addEventListener('message', () => pump());
                        // Some servers emit keepalive pings; treat as an update nudge
                        src.addEventListener('ping', () => pump());
                        src.onopen = () => {
                            // Clear any planned reconnect attempts and nudge UI
                            if (reconnectTimer) {
                                clearTimeout(reconnectTimer);
                                reconnectTimer = null;
                            }
                            pump();
                        };
                        // When config changes (e.g., cache size), refresh cache stats panel immediately
                        src.addEventListener('config-updated', async () => {
                            try {
                                await refreshCacheStatsV2();
                            } catch (_) {
                                /* ignore */
                            }
                        });
                        src.onerror = () => {
                            // If the stream is fully closed, clear handle and try to re-establish
                            try {
                                if (src.readyState === 2 /* CLOSED */) {
                                    try {
                                        src.close();
                                    } catch (_) {
                                        /* best-effort: closing EventSource may fail in some browsers */
                                    }
                                    if (window.__adminSSE === src) window.__adminSSE = null;
                                    if (!reconnectTimer) {
                                        reconnectTimer = setTimeout(() => {
                                            reconnectTimer = null;
                                            establishSSE();
                                        }, 3000);
                                    }
                                }
                            } catch (_) {
                                /* applying active devices metric shortcut failed (non-fatal) */
                            }
                        };
                    } catch (_) {
                        // If creation fails (e.g., endpoint down), retry with backoff
                        if (!reconnectTimer) {
                            reconnectTimer = setTimeout(() => {
                                reconnectTimer = null;
                                establishSSE();
                            }, 5000);
                        }
                    }
                };

                establishSSE();
                // When SSE is available, listen for device updates and reconcile immediately
                try {
                    const attachDeviceListeners = () => {
                        const s = window.__adminSSE;
                        if (!s) return;
                        const onNudge = async _evtName => {
                            try {
                                const sec = document.getElementById('section-devices');
                                if (!sec || !sec.classList.contains('active')) return;
                                const t0 = performance.now();
                                const list = await fetchJSON('/api/devices').catch(() => null);
                                if (Array.isArray(list)) {
                                    window.admin2?.reconcileDevicesNow?.(list);
                                    try {
                                        const dt = Math.round(performance.now() - t0);
                                        ddbg(
                                            'reconcileDeviceToolbarStatesOnce duration',
                                            dt + 'ms',
                                            `(${list.length} devices)`
                                        );
                                    } catch (_) {
                                        /* debug timing log is optional; proceed silently */
                                    }
                                }
                            } catch (_) {
                                /* scheduled overview counts retry failed (will self-correct later) */
                            }
                        };
                        // Store on the instance so we can remove on reconnect
                        s.__onDeviceNudge = onNudge;
                        try {
                            s.addEventListener('device-updated', () => onNudge('device-updated'));
                        } catch (_) {
                            /* decrement stopPropagation failed (harmless) */
                        }
                        try {
                            s.addEventListener('device-ws', () => onNudge('device-ws'));
                        } catch (_) {
                            /* delegated spinner increment stopPropagation failed (minor) */
                        }
                    };
                    const detachDeviceListeners = () => {
                        const s = window.__adminSSE;
                        if (!s || !s.__onDeviceNudge) return;
                        try {
                            s.removeEventListener('device-updated', s.__onDeviceNudge);
                        } catch (_) {
                            /* delegated spinner decrement stopPropagation failed (minor) */
                        }
                        try {
                            s.removeEventListener('device-ws', s.__onDeviceNudge);
                        } catch (_) {
                            /* number wrapper stopPropagation suppression failed (harmless) */
                        }
                        try {
                            delete s.__onDeviceNudge;
                        } catch (_) {
                            /* number wrapper dataset flagging failed (non-critical) */
                        }
                    };
                    // Attach now
                    attachDeviceListeners();
                    // Re-attach on SSE reconnect by polling for handle changes
                    let lastSse = window.__adminSSE;
                    setInterval(() => {
                        if (window.__adminSSE !== lastSse) {
                            ddbg('SSE handle changed → reattach');
                            detachDeviceListeners();
                            lastSse = window.__adminSSE;
                            attachDeviceListeners();
                        }
                    }, 1500);
                } catch (_) {
                    /* plex recentOnly days toggle wiring failed (user can still edit days manually) */
                }
            } catch (_) {
                // Ignore if EventSource not available or endpoint not reachable; polling remains
            }
        })();

        // Mobile sidebar toggle demo behavior
        const toggle = $('#mobile-nav-toggle');
        const overlay = $('#sidebar-overlay');
        const sidebar = document.querySelector('.sidebar');
        toggle?.addEventListener('click', () => {
            const open = sidebar?.classList.toggle('open');
            overlay && (overlay.hidden = !open);
            toggle.setAttribute('aria-expanded', String(!!open));
        });
        overlay?.addEventListener('click', () => {
            sidebar?.classList.remove('open');
            overlay.hidden = true;
            toggle?.setAttribute('aria-expanded', 'false');
        });

        // Settings dropdown
        const settingsBtn = document.getElementById('settings-btn');
        const settingsMenu = document.getElementById('settings-menu');

        // Compute a shared Y baseline for header menus so they match the Notifications panel
        function getHeaderDropdownTop() {
            try {
                const nav = document.querySelector('.navbar');
                const rootStyle = getComputedStyle(document.documentElement);
                const innerShiftRaw = rootStyle.getPropertyValue('--navbar-inner-shift') || '0';
                const innerShift = parseFloat(String(innerShiftRaw).trim()) || 0;
                if (nav) {
                    const navRect = nav.getBoundingClientRect();
                    return Math.round(navRect.bottom + innerShift);
                }
                // Fallback to CSS var --navbar-height if navbar element missing
                const navHRaw = rootStyle.getPropertyValue('--navbar-height') || '68px';
                const navH = parseFloat(String(navHRaw).trim()) || 68;
                return Math.round(navH + innerShift);
            } catch (_) {
                return 72; // safe default (68 + ~4 shift)
            }
        }

        // Simple portal helpers to escape stacking contexts
        function portalize(el) {
            try {
                if (!el || el.__portalized) return;
                el.__portal = { parent: el.parentElement, next: el.nextSibling };
                document.body.appendChild(el);
                el.__portalized = true;
            } catch (_) {
                /* slider preset button click failed (user can adjust manually) */
            }
        }
        function unportalize(el) {
            try {
                if (!el || !el.__portal || !el.__portal.parent) return;
                el.__portal.parent.insertBefore(el, el.__portal.next || null);
                el.__portalized = false;
            } catch (_) {
                /* slider preset button click failed (user can adjust manually) */
            }
        }

        function closeMenu() {
            if (!settingsMenu) return;
            settingsBtn?.setAttribute('aria-expanded', 'false');
            settingsMenu?.setAttribute('aria-hidden', 'true');
            settingsMenu?.classList.remove('show');
            // Hide the menu properly
            settingsMenu.style.display = 'none';
            settingsMenu.style.opacity = '0';
            settingsMenu.style.pointerEvents = 'none';
            // Restore to original DOM to keep structure tidy
            unportalize(settingsMenu);
        }

        // Click-to-open only; hover-open removed
        settingsBtn?.addEventListener('click', e => {
            e.stopPropagation();
            if (!settingsMenu) return;
            const willOpen = !settingsMenu?.classList.contains('show');
            if (willOpen) {
                // Ensure the user menu is closed when opening settings
                try {
                    typeof closeUserMenu === 'function' && closeUserMenu();
                } catch (_) {
                    /* jellyfin recentOnly days toggle wiring failed (user can still edit days manually) */
                }
                // Also ensure notifications panel is closed when opening settings
                try {
                    if (window.__closeNotifyCenter) window.__closeNotifyCenter();
                    else {
                        const panel = document.getElementById('notify-center');
                        const btn = document.getElementById('notif-btn');
                        panel?.classList.remove('open');
                        btn?.setAttribute('aria-expanded', 'false');
                    }
                } catch (_) {
                    /* filter diff comparison failed (will re-evaluate next reconcile) */
                }
                // Show (hidden) and dynamically position using fixed coordinates (escape parent stacking context)
                settingsMenu.style.display = 'block';
                settingsMenu.style.position = 'fixed';
                settingsMenu.style.zIndex = '12000'; // above preview PiP
                settingsMenu.style.opacity = '0';
                settingsMenu.style.pointerEvents = 'none';
                settingsMenu.style.visibility = 'hidden';
                // Reset anchors then compute from trigger viewport rect
                settingsMenu.style.left = '0';
                settingsMenu.style.right = 'auto';
                settingsMenu.style.top = '0';
                // Move into body to avoid clipping by transformed/overflow ancestors
                portalize(settingsMenu);
                const prevTransSM = settingsMenu.style.transition;
                settingsMenu.style.transition = 'none';
                requestAnimationFrame(() => {
                    try {
                        const vw = Math.max(
                            document.documentElement.clientWidth,
                            window.innerWidth || 0
                        );
                        const rect = settingsBtn?.getBoundingClientRect();
                        const menuRect = settingsMenu.getBoundingClientRect();
                        // Use a shared top aligned with the Notifications panel height
                        const top = getHeaderDropdownTop();
                        let left = Math.max(8, rect?.left || 0);
                        if (left + menuRect.width > vw - 8) {
                            left = Math.max(8, (rect?.right || vw) - menuRect.width);
                        }
                        left = Math.min(left, Math.max(8, vw - menuRect.width - 8));
                        settingsMenu.style.top = `${top}px`;
                        settingsMenu.style.left = `${left}px`;
                    } catch (err) {
                        console.warn('Settings menu positioning error', err);
                    }
                    requestAnimationFrame(() => {
                        settingsMenu.style.transition = prevTransSM || '';
                        settingsMenu.style.visibility = 'visible';
                        settingsMenu.style.opacity = '1';
                        settingsMenu.style.pointerEvents = 'auto';
                        settingsMenu?.classList.add('show');
                    });
                });
            } else {
                closeMenu();
            }
            settingsBtn.setAttribute('aria-expanded', String(willOpen));
            settingsMenu?.setAttribute('aria-hidden', String(!willOpen));
        });
        // Hover-based auto-close removed; menus are click-to-toggle only
        document.addEventListener('click', e => {
            if (!settingsMenu) return;
            if (!e.target.closest('#settings-dropdown')) closeMenu();
        });
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') closeMenu();
        });
        // Close settings menu when any item is clicked (restart is now single-click)
        settingsMenu?.addEventListener('click', e => {
            const item = e.target.closest('a.dropdown-item');
            if (!item) return;
            closeMenu();
        });

        // Notifications bell: themed Notification Center panel (matches theme-demo)
        (function initNotifications() {
            const btn = document.getElementById('notif-btn');
            const badge = document.getElementById('notif-count');
            // const menu = document.getElementById('notif-menu'); // legacy, unused
            const panel = document.getElementById('notify-center');
            const list = document.getElementById('notify-list');
            // const btnMarkAll = document.getElementById('notify-mark-all');
            // const btnClose = document.getElementById('notify-close');
            if (!btn || !badge || !panel || !list) return;

            // Helper to always get fresh references (soft refresh safe)
            function getRefs() {
                return {
                    btn: document.getElementById('notif-btn'),
                    badge: document.getElementById('notif-count'),
                    panel: document.getElementById('notify-center'),
                    list: document.getElementById('notify-list'),
                };
            }

            // Keep a dismissed set (persisted) so items don't bounce back after refresh
            const dismissed = new Set();
            const DISMISS_STORE = 'admin2:dismissedNotifications';
            // Dismiss TTLs: alerts linger longer; logs (repetitive) return sooner
            const DISMISS_TTL_ALERT_MS = 7 * 24 * 60 * 60 * 1000; // 7 days
            const DISMISS_TTL_LOG_MS = 60 * 60 * 1000; // 1 hour for logs (prevents long-term suppression of WARN spam)
            const CLEAR_SUPPRESS_KEY = 'admin2:notifClearedUntil';
            const CLEAR_SUPPRESS_MS = 15000; // 15s grace to avoid racey repaints
            // Notification data cache to avoid hammering endpoints
            const FETCH_TTL_MS = 10000; // 10s TTL for alerts/logs
            let __notifCache = { data: null, ts: 0 };
            let __notifInflight = null;
            // Unified badge updater to avoid lingering empty badge visuals
            function setBadge(count) {
                try {
                    const { badge } = getRefs();
                    if (!badge) return;
                    const n = Math.max(0, Number(count) || 0);
                    if (n > 0) {
                        badge.textContent = String(n);
                        badge.hidden = false;
                        badge.style.display = '';
                        badge.setAttribute('aria-hidden', 'false');
                    } else {
                        badge.textContent = '';
                        badge.hidden = true;
                        badge.style.display = 'none';
                        badge.setAttribute('aria-hidden', 'true');
                    }
                } catch (_) {
                    /* filter re-evaluation compare failed (benign; will re-render next tick) */
                }
            }
            function loadDismissed() {
                try {
                    const raw = localStorage.getItem(DISMISS_STORE);
                    const list = raw ? JSON.parse(raw) : [];
                    const now = Date.now();
                    if (Array.isArray(list)) {
                        list.forEach(entry => {
                            if (!entry || typeof entry.key !== 'string') return;
                            const k = entry.key;
                            const isAlert = k.startsWith('A|');
                            const isLog = k.startsWith('L|');
                            const ttl = isAlert
                                ? DISMISS_TTL_ALERT_MS
                                : isLog
                                  ? DISMISS_TTL_LOG_MS
                                  : DISMISS_TTL_ALERT_MS; // default to longer
                            if (now - (entry.t || 0) < ttl) {
                                dismissed.add(k);
                            }
                        });
                    }
                } catch (_) {
                    /* filter re-evaluation failed (non-fatal; will recompute on next tick) */
                }
            }
            function persistDismissed() {
                try {
                    const now = Date.now();
                    const arr = Array.from(dismissed).map(key => ({ key, t: now }));
                    localStorage.setItem(DISMISS_STORE, JSON.stringify(arr));
                } catch (_) {
                    /* devices filter change diff check failed (re-render skipped) */
                }
            }
            // Load persisted dismissed notifications on init
            loadDismissed();

            const normalize = s =>
                String(s || '')
                    .toLowerCase()
                    .replace(/\s+/g, ' ')
                    .trim();
            const makeAlertKey = a => {
                const base = String(a?.id || a?.name || '');
                const msg = normalize(a?.message || a?.description || '');
                return `A|${base}|${msg}`;
            };
            // Use level + normalized message + minute bucket so dismissing doesn't hide future occurrences forever
            const makeLogKey = l => {
                let ms = 0;
                try {
                    const t = l?.timestamp;
                    ms = typeof t === 'number' ? t : Date.parse(String(t));
                    if (!Number.isFinite(ms)) ms = 0;
                } catch (_) {
                    /* devices filter change diff check failed (re-render skipped) */
                }
                const bucket = Math.floor(ms / 60000); // minute-level bucket
                return `L|${String(l?.level || 'warn')}|${normalize(l?.message || '')}|${bucket}`;
            };
            function applyDismissedFilter(alerts, logs) {
                const fa = (Array.isArray(alerts) ? alerts : []).filter(
                    a => !dismissed.has(makeAlertKey(a))
                );
                const fl = (Array.isArray(logs) ? logs : []).filter(
                    l => !dismissed.has(makeLogKey(l))
                );
                return { alerts: fa, logs: fl };
            }
            function updateBadgeFromList() {
                const { list } = getRefs();
                if (!list) return setBadge(0);
                const unread = list.querySelectorAll('.notify-item[data-unread="true"]').length;
                setBadge(unread);
            }

            const NOTIF_MAX_ITEMS_KEY = 'admin2:notifMaxItems';
            function getNotifMaxItems() {
                try {
                    const v = Number(localStorage.getItem(NOTIF_MAX_ITEMS_KEY));
                    if (Number.isFinite(v) && v > 0 && v <= 100) return Math.floor(v);
                } catch (_) {
                    /* plex days checkbox toggle wire failed (user can toggle manually) */
                }
                return 100; // default increased
            }

            async function fetchAlertsAndLogs(opts = {}) {
                const force = !!opts.force;
                const now = Date.now();
                try {
                    if (!force) {
                        if (__notifInflight) return __notifInflight;
                        if (__notifCache.data && now - __notifCache.ts < FETCH_TTL_MS) {
                            return __notifCache.data;
                        }
                    }
                } catch (_) {
                    /* jellyfin days checkbox toggle wire failed (user can toggle manually) */
                }

                // Build a single-flight promise for both alerts and logs
                __notifInflight = (async () => {
                    // Dedup + backoff for dashboard metrics inside notifications too
                    if (!window.__metricsCooldownUntil) window.__metricsCooldownUntil = 0;
                    const nowInner = Date.now();
                    const useCooldown = nowInner < window.__metricsCooldownUntil;
                    let alerts = [];
                    let logs = [];
                    try {
                        let data = null;
                        if (!useCooldown) {
                            if (typeof window.dedupJSON === 'function') {
                                const res = await window.dedupJSON('/api/v1/metrics/dashboard');
                                if (res && res.status === 429) {
                                    window.__metricsCooldownUntil = Date.now() + 30_000; // 30s
                                } else if (res && res.ok) {
                                    data = await res.json();
                                }
                            } else {
                                data = await fetchJSON('/api/v1/metrics/dashboard').catch(
                                    () => null
                                );
                            }
                        }
                        alerts = Array.isArray(data?.alerts) ? data.alerts : [];
                    } catch (_) {
                        /* delegated spinner guard flag reset failed (non-critical) */
                    }
                    try {
                        // Respect user-selected minimum level for logs in the bell
                        const levelKey = 'admin2:notifMinLevel';
                        let minLevel = (localStorage.getItem(levelKey) || 'warn').toLowerCase();
                        if (minLevel === 'warning') minLevel = 'warn';
                        const levelParam = ['info', 'warn', 'error'].includes(minLevel)
                            ? minLevel
                            : 'warn';
                        const limit = getNotifMaxItems();
                        const r = await fetch(
                            `/api/admin/logs?level=${levelParam}&limit=${limit}`,
                            {
                                credentials: 'include',
                            }
                        );
                        if (r.ok) {
                            const jr = (await r.json()) || [];
                            logs = Array.isArray(jr)
                                ? jr
                                : Array.isArray(jr?.logs)
                                  ? jr.logs
                                  : Array.isArray(jr?.items)
                                    ? jr.items
                                    : [];
                        }
                    } catch (_) {
                        /* bulk delete modal portal fallback failed (overlay still usable) */
                    }
                    return { alerts, logs };
                })();

                try {
                    const res = await __notifInflight;
                    __notifInflight = null;
                    if (res) {
                        __notifCache = { data: res, ts: Date.now() };
                    }
                    return res || { alerts: [], logs: [] };
                } catch (e) {
                    __notifInflight = null;
                    return { alerts: [], logs: [] };
                }
            }

            function renderPanel({ alerts, logs }) {
                const parts = [];
                const maxItems = getNotifMaxItems();
                // Local time formatter for this panel
                function fmtAgoLite(ms) {
                    if (!ms || Number.isNaN(ms)) return '';
                    const now = Date.now();
                    const diff = Math.max(0, now - ms);
                    const sec = Math.floor(diff / 1000);
                    if (sec < 5) return 'Just now';
                    if (sec < 60) return `${sec}s ago`;
                    const min = Math.floor(sec / 60);
                    if (min < 60) return `${min}m ago`;
                    const hr = Math.floor(min / 60);
                    if (hr < 24) return `${hr}h ago`;
                    const day = Math.floor(hr / 24);
                    return `${day}d ago`;
                }
                function toMs(ts) {
                    if (!ts && ts !== 0) return 0;
                    const ms = typeof ts === 'number' ? ts : Date.parse(String(ts));
                    return Number.isFinite(ms) ? ms : 0;
                }
                function formatWhenMs(ms) {
                    if (!Number.isFinite(ms) || ms <= 0) return '';
                    return fmtAgoLite(ms);
                }
                function iconForLevel(st) {
                    switch (st) {
                        case 'success':
                            return 'fa-check';
                        case 'error':
                            return 'fa-exclamation';
                        case 'info':
                            return 'fa-circle-info';
                        case 'warning':
                        default:
                            return 'fa-triangle-exclamation';
                    }
                }
                if (Array.isArray(alerts) && alerts.length) {
                    for (const a of alerts.slice(0, maxItems)) {
                        const raw = String(a?.status || 'warn').toLowerCase();
                        const st =
                            raw === 'error'
                                ? 'error'
                                : raw === 'info'
                                  ? 'info'
                                  : raw === 'success' || raw === 'ok' || raw === 'done'
                                    ? 'success'
                                    : 'warning';
                        const icon = iconForLevel(st);
                        const title = escapeHtml(String(a?.name || a?.id || 'Alert'));
                        const msg = escapeHtml(String(a?.message || a?.description || ''));
                        const ms = toMs(a?.timestamp || a?.time || a?.date);
                        const when = formatWhenMs(ms);
                        const meta = [when, msg].filter(Boolean).join(' \u00B7 ');
                        const rawKey = makeAlertKey(a);
                        const key = encodeURIComponent(rawKey);
                        parts.push({
                            ts: ms,
                            html: `<div class="notify-item notify-${st}" data-unread="true" data-key="${key}">
                                    <i class="fas ${icon}" aria-hidden="true"></i>
                                    <div>
                                        <div class="notify-title">${title}</div>
                                        ${meta ? `<div class="notify-meta">${meta}</div>` : ''}
                                    </div>
                                    <button class="notify-close" title="Dismiss"><i class="fas fa-xmark"></i></button>
                                 </div>`,
                        });
                    }
                }
                if (Array.isArray(logs) && logs.length) {
                    for (const l of logs.slice(0, maxItems)) {
                        const raw = String(l?.level || l?.severity || 'warn').toLowerCase();
                        const st = raw === 'error' ? 'error' : raw === 'info' ? 'info' : 'warning';
                        const icon = iconForLevel(st);
                        const msg = escapeHtml(String(l?.message || ''));
                        const ms = toMs(l?.timestamp);
                        const when = formatWhenMs(ms);
                        const rawKey = makeLogKey(l);
                        const key = encodeURIComponent(rawKey);
                        parts.push({
                            ts: ms,
                            html: `<div class="notify-item notify-${st}" data-unread="true" data-key="${key}">
                                    <i class="fas ${icon}" aria-hidden="true"></i>
                                    <div>
                                        <div class="notify-title">${msg || 'Log'}</div>
                                        ${when ? `<div class="notify-meta">${when}</div>` : ''}
                                    </div>
                                    <button class="notify-close" title="Dismiss"><i class="fas fa-xmark"></i></button>
                                 </div>`,
                        });
                    }
                }
                const { list } = getRefs();
                if (list) {
                    if (parts.length) {
                        const html = parts
                            .sort((a, b) => (b.ts || 0) - (a.ts || 0))
                            .map(p => p.html)
                            .join('');
                        list.innerHTML = html;
                    } else {
                        list.innerHTML =
                            '<div class="notify-item notify-empty"><div class="notify-title" style="grid-column:1 / -1; text-align:center; opacity:.85;">No notifications</div></div>';
                    }
                } else {
                    setBadge(0);
                }
            }
            async function refreshBadge(force = false) {
                try {
                    const nowThrottle = Date.now();
                    if (!window.__notifLastRun) window.__notifLastRun = 0;
                    if (!window.__notifRunCount) window.__notifRunCount = 0;
                    if (!force && nowThrottle - window.__notifLastRun < 1500) return;
                    window.__notifLastRun = nowThrottle;
                    window.__notifRunCount++;
                    if (window.__notifRunCount > 500) return;
                    // Suppression window after user clears notifications (avoid bounce-back)
                    try {
                        const until = Number(localStorage.getItem(CLEAR_SUPPRESS_KEY) || 0);
                        if (Date.now() < until) {
                            setBadge(0);
                            const { list } = getRefs();
                            if (list)
                                list.innerHTML =
                                    '<div class="notify-item notify-empty"><div class="notify-title" style="grid-column:1 / -1; text-align:center; opacity:.85;">No notifications</div></div>';
                            return;
                        }
                    } catch (_) {
                        /* active devices metric shortcut navigation failed (benign) */
                    }
                    let { alerts, logs } = await fetchAlertsAndLogs({ force });
                    // Apply session dismissals so cleared items don't bounce back immediately
                    ({ alerts, logs } = applyDismissedFilter(alerts, logs));
                    const maxItems = getNotifMaxItems();
                    const shownAlerts = Math.min(
                        Array.isArray(alerts) ? alerts.length : 0,
                        maxItems
                    );
                    const shownLogs = Math.min(Array.isArray(logs) ? logs.length : 0, maxItems);
                    const count = shownAlerts + shownLogs;
                    setBadge(count);
                    try {
                        window.__notifRendering = true;
                    } catch (_) {
                        /* bulk action overlay portalization failed (size fallback applied) */
                    }
                    renderPanel({ alerts, logs });
                    try {
                        window.__notifRendering = false;
                    } catch (_) {
                        /* previous enabled state detection failed (restart decision may be skipped) */
                    }
                } catch (_) {
                    setBadge(0);
                    const { list } = getRefs();
                    if (list)
                        list.innerHTML =
                            '<div class="notify-item notify-empty"><div class="notify-title" style="grid-column:1 / -1; text-align:center; opacity:.85;">No notifications</div></div>';
                }
            }
            // Expose to global shim so SSE can trigger it without scoping issues
            try {
                window.refreshAdminBadge = refreshBadge;
            } catch (_) {
                /* UI scaling reset button failed (values unchanged) */
            }

            function openPanel() {
                const { panel, btn } = getRefs();
                try {
                    if (panel && panel.parentElement !== document.body) {
                        // If panel is accidentally nested inside other layout (e.g., form/modal), detach to body.
                        document.body.appendChild(panel);
                        panel.setAttribute('data-portal', 'true');
                    }
                } catch (_) {
                    /* group assign modal debug rect failed (non-fatal) */
                }
                panel?.classList.add('open');
                if (panel) panel.setAttribute('aria-hidden', 'false');
                btn?.setAttribute('aria-expanded', 'true');
                try {
                    window.__notifUserOpenedOnce = true;
                } catch (_) {
                    /* group assign modal debug rect failed (non-fatal) */
                }
                if (panel) {
                    // Reusable visibility enforcement for panel or modal elements
                    // (Will be extracted for modals too.)
                    if (!window.__ensureVisible) {
                        window.__ensureVisible = function ensureVisible(el, kind = 'generic') {
                            try {
                                if (!el) return;
                                const r = el.getBoundingClientRect();
                                const zero = r.width === 0 || r.height === 0;
                                if (zero) {
                                    console.warn(
                                        '[UIEnsureVisible] zero-rect detected for',
                                        kind,
                                        r.toJSON ? r.toJSON() : r
                                    );
                                    if (el.parentElement !== document.body && kind === 'notify') {
                                        try {
                                            document.body.appendChild(el);
                                            el.setAttribute('data-portal', 'true');
                                        } catch (_) {
                                            /* integrity post-check failed (selections remain as-is) */
                                        }
                                    }
                                    el.style.overflow = el.style.overflow || 'auto';
                                    el.style.visibility = 'visible';
                                    el.style.opacity = '1';
                                    el.style.pointerEvents = 'auto';
                                    el.style.transform = 'translateY(0) scale(1)';
                                    el.style.zIndex = kind === 'modal' ? '14000' : '13000';
                                }
                            } catch (evErr) {
                                console.warn('[UIEnsureVisible] failed for', kind, evErr);
                            }
                        };
                    }
                    panel.style.opacity = '1';
                    panel.style.pointerEvents = 'auto';
                    panel.style.transform = 'translateY(0) scale(1)';
                    panel.style.visibility = 'visible';
                    panel.style.zIndex = '13000';
                    // If collapsed (width/height 0) enforce base dimensions
                    try {
                        const r = panel.getBoundingClientRect();
                        if (r.width === 0 || r.height === 0) {
                            panel.style.width = '360px';
                            panel.style.minHeight = '160px';
                            panel.style.padding = '8px 0 4px';
                            panel.style.overflow = 'auto';
                            console.warn(
                                '[NotifDebug] panel had zero rect, applied fallback sizing'
                            );
                        } else {
                            // Secondary guard: still run generic ensureVisible in case of race conditions
                            try {
                                window.__ensureVisible?.(panel, 'notify');
                            } catch (_) {
                                /* manual width bucket sizing failed (non-blocking) */
                            }
                        }
                    } catch (_) {
                        /* preset apply API failed for device (continue others) */
                    }
                }
            }
            function closePanel() {
                const { panel, btn } = getRefs();
                panel?.classList.remove('open');
                if (panel) panel.setAttribute('aria-hidden', 'true');
                btn?.setAttribute('aria-expanded', 'false');
                if (panel) {
                    panel.style.opacity = '';
                    panel.style.pointerEvents = '';
                    panel.style.transform = '';
                    panel.style.visibility = '';
                    panel.style.zIndex = '';
                }
            }

            // Expose close/open so other header menus can close notifications when they open
            try {
                window.__closeNotifyCenter = closePanel;
                window.__openNotifyCenter = openPanel;
            } catch (_) {
                /* expose reconcileDevicesNow hook failed (SSE still triggers periodic reconcile) */
            }

            // Initialize min-level selector (hidden) + compact icon filter bindings
            (function initMinLevelControl() {
                try {
                    const key = 'admin2:notifMinLevel';
                    const sel = document.getElementById('notify-min-level');
                    const container = document.getElementById('notify-min-level-icons');
                    let saved = (localStorage.getItem(key) || 'warn').toLowerCase();
                    if (saved === 'warning') saved = 'warn';
                    // Sync hidden select if present
                    if (sel && [...sel.options].some(o => o.value === saved)) sel.value = saved;
                    // Helper to update aria-checked on icon buttons
                    const paint = v => {
                        if (!container) return;
                        container.querySelectorAll('.nf-btn').forEach(btn => {
                            btn.setAttribute('aria-checked', String(btn.dataset.level === v));
                        });
                    };
                    paint(saved);
                    // Click handling on compact icons
                    container?.addEventListener('click', e => {
                        const btn = e.target.closest?.('.nf-btn');
                        if (!btn) return;
                        const v = String(btn.dataset.level || '').toLowerCase();
                        if (!v) return;
                        localStorage.setItem(key, v);
                        if (sel) sel.value = v;
                        paint(v);
                        // Force-refresh to reflect new min level immediately
                        try {
                            refreshBadge(true);
                        } catch (_) {
                            /* number input enhanced dataset flag failed (visual only) */
                        }
                    });
                    // Keep existing change binding on hidden select as fallback (e.g., accessibility tools)
                    sel?.addEventListener('change', () => {
                        try {
                            const v = sel.value;
                            localStorage.setItem(key, v);
                            paint(v);
                            refreshBadge(true);
                        } catch (_) {
                            /* orphan enhanced flag cleanup failed (minor) */
                        }
                    });
                } catch (_) {
                    /* bulk pair debug log failed (non-critical) */
                }
            })();

            // Guard to avoid duplicate bindings if init runs again
            if (!window.__notifHandlersAdded) {
                window.__notifHandlersAdded = true;
                // Capture-phase guard: ensure notif button click can't be swallowed by generic close handlers
                try {
                    document.addEventListener(
                        'click',
                        ev => {
                            const btn = ev.target.closest?.('#notif-btn');
                            if (btn) {
                                // Mark event so other listeners know it originated from notif toggle
                                ev.__fromNotifBtn = true;
                            }
                        },
                        true
                    );
                } catch (_) {
                    /* bulk override debug log failed (non-critical) */
                }
                // Delegated toggle open on bell
                document.addEventListener('click', async e => {
                    const notifBtn = e.target.closest?.('#notif-btn');
                    if (notifBtn) {
                        e.stopPropagation();
                        const { panel } = getRefs();
                        const isOpen = panel?.classList.contains('open');
                        if (isOpen) {
                            // Toggle: if open, close it
                            closePanel();
                        } else {
                            window.__notifJustOpened = true;
                            // Ensure other header menus are closed when opening notifications
                            try {
                                typeof closeMenu === 'function' && closeMenu();
                            } catch (_) {
                                /* closeMenu optional; ignore if unavailable */
                            }
                            try {
                                typeof closeUserMenu === 'function' && closeUserMenu();
                            } catch (_) {
                                /* closeUserMenu optional; ignore if unavailable */
                            }
                            // Force bypass TTL when the user explicitly opens the panel
                            // Resilient open: ensure panel opens even if refreshBadge fails
                            console.debug('NOTIFY_OPEN_ATTEMPT');
                            let rbErr = null;
                            try {
                                await refreshBadge(true);
                            } catch (err) {
                                rbErr = err;
                                console.warn(
                                    'refreshBadge(true) failed (continuing to open panel)',
                                    err
                                );
                            } finally {
                                try {
                                    openPanel();
                                    console.debug('NOTIFY_PANEL_OPEN_CALLED', {
                                        hadRefreshError: !!rbErr,
                                    });
                                } catch (openErr) {
                                    console.error('openPanel() threw', openErr);
                                }
                            }
                            // Post-open confirmation & self-heal if styles were overridden
                            setTimeout(() => {
                                try {
                                    const { panel } = getRefs();
                                    if (!panel) return;
                                    if (!panel.classList.contains('open')) {
                                        console.warn(
                                            'NOTIFY_PANEL_NOT_OPEN_AFTER_DELAY - forcing inline styles'
                                        );
                                        try {
                                            panel.classList.add('open');
                                        } catch (_) {
                                            /* force-open class add failed; allow next cycle to retry */
                                        }
                                    }
                                    // If computed style still hiding it, force critical visibility properties
                                    const cs = getComputedStyle(panel);
                                    if (
                                        cs &&
                                        (cs.display === 'none' ||
                                            cs.visibility === 'hidden' ||
                                            parseFloat(cs.opacity) === 0)
                                    ) {
                                        console.warn('NOTIFY_PANEL_INVISIBLE_COMPUTED_STATE', {
                                            display: cs.display,
                                            visibility: cs.visibility,
                                            opacity: cs.opacity,
                                            pointerEvents: cs.pointerEvents,
                                            zIndex: cs.zIndex,
                                        });
                                        panel.style.display = 'block';
                                        panel.style.visibility = 'visible';
                                        panel.style.opacity = '1';
                                        panel.style.pointerEvents = 'auto';
                                        panel.style.zIndex = '13000';
                                        panel.style.transform = 'translateY(0)';
                                    } else {
                                        console.debug('NOTIFY_PANEL_CONFIRMED_OPEN');
                                    }
                                } catch (confirmErr) {
                                    console.error('Post-open confirm logic failed', confirmErr);
                                }
                            }, 60);
                            // Reset flag end of tick
                            setTimeout(() => {
                                window.__notifJustOpened = false;
                            }, 0);
                        }
                        return;
                    }
                    // Close when clicking outside
                    const { panel } = getRefs();
                    if (panel && !panel.contains(e.target) && !e.target.closest('#notif-btn')) {
                        if (e.__fromNotifBtn) return; // guard: same originating click
                        if (window.__notifJustOpened) {
                            // Skip immediate close on same originating click
                            return;
                        }
                        closePanel();
                    }
                    // Close via header X
                    const closeBtn = e.target.closest?.('#notify-close');
                    if (closeBtn) {
                        e.preventDefault();
                        closePanel();
                        return;
                    }
                });
                document.addEventListener('keydown', e => {
                    if (e.key === 'Escape') closePanel();
                });
                // Refresh when tab becomes visible again (soft refresh/resume)
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        try {
                            refreshBadge();
                        } catch (_) {
                            /* best-effort refresh on tab visible; ignore errors */
                        }
                    }
                });
                // Refresh on pageshow (including back/forward cache restores)
                window.addEventListener('pageshow', () => {
                    try {
                        refreshBadge();
                    } catch (_) {
                        /* best-effort refresh on pageshow; ignore errors */
                    }
                });

                // Observe DOM mutations to handle soft DOM swaps (e.g., partial renders)
                try {
                    if (!window.__notifMO) {
                        const mo = new MutationObserver(
                            debounce(() => {
                                if (window.__notifRendering) return; // skip self-triggered
                                const center = document.getElementById('notify-center');
                                const countEl = document.getElementById('notif-count');
                                if (center || countEl) {
                                    try {
                                        refreshBadge();
                                    } catch (_) {
                                        /* best-effort badge refresh; ignore transient failures */
                                    }
                                }
                            }, 300)
                        );
                        mo.observe(document.body, { childList: true, subtree: true });
                        window.__notifMO = mo;
                    }
                } catch (_) {
                    /* ignore */
                }
            }

            // Delegated actions for dismiss and mark-all to survive soft refreshes/DOM swaps
            document.addEventListener('click', e => {
                const dismissBtn = e.target.closest?.('.notify-item .notify-close');
                if (dismissBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const item = dismissBtn.closest('.notify-item');
                    const { list } = getRefs();
                    if (item) {
                        const keyAttr = item.getAttribute('data-key');
                        const key = keyAttr ? decodeURIComponent(keyAttr) : null;
                        if (key) dismissed.add(key);
                        item.remove();
                        // If list is now empty, show the empty state explicitly
                        if (list && !list.querySelector('.notify-item[data-unread="true"]')) {
                            list.innerHTML =
                                '<div class="notify-item notify-empty"><div class="notify-title" style="grid-column:1 / -1; text-align:center; opacity:.85;">No notifications</div></div>';
                        }
                        updateBadgeFromList();
                        persistDismissed();
                    }
                    return;
                }
                const markAllBtn = e.target.closest?.('#notify-mark-all');
                if (markAllBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const { list } = getRefs();
                    list?.querySelectorAll('.notify-item[data-unread="true"]').forEach(item => {
                        const keyAttr = item.getAttribute('data-key');
                        const key = keyAttr ? decodeURIComponent(keyAttr) : null;
                        if (key) dismissed.add(key);
                    });
                    persistDismissed();
                    if (list)
                        list.innerHTML =
                            '<div class="notify-item notify-empty"><div class="notify-title" style="grid-column:1 / -1; text-align:center; opacity:.85;">No notifications</div></div>';
                    // Hide and clear the badge explicitly after marking all
                    setBadge(0);
                    updateBadgeFromList();
                    try {
                        localStorage.setItem(
                            CLEAR_SUPPRESS_KEY,
                            String(Date.now() + CLEAR_SUPPRESS_MS)
                        );
                    } catch (_) {
                        /* media sources overview metric shortcut failed (non-fatal) */
                    }
                    // Re-sync from source after a short delay to respect suppression
                    setTimeout(() => {
                        try {
                            refreshBadge();
                        } catch (_) {
                            /* down button stopPropagation failed (no side effects) */
                        }
                    }, 250);
                }
            });
            // The delegated handler above covers mark-all; avoid double-binding here

            // Periodically refresh the badge regardless of active section (tab-visible only)
            const badgeTick = debounce(() => {
                try {
                    if (document.visibilityState !== 'visible') return;
                    if (typeof window.refreshAdminBadge === 'function') window.refreshAdminBadge();
                    else refreshBadge();
                } catch (_) {
                    /* bulk sendcmd debug log failed (non-critical) */
                }
            }, 500);
            setInterval(badgeTick, 15000);

            // While the notification panel is open, refresh more frequently for a live feel
            setInterval(() => {
                try {
                    if (document.visibilityState !== 'visible') return;
                    const { panel } = getRefs();
                    if (panel && panel.classList.contains('open')) {
                        if (typeof window.refreshAdminBadge === 'function')
                            window.refreshAdminBadge();
                        else refreshBadge();
                    }
                } catch (_) {
                    /* plex days checkbox toggle wire failed (user can toggle manually) */
                }
            }, 5000);

            // Initial paint so users see counts without clicking
            try {
                refreshBadge();
            } catch (_) {
                /* initial badge refresh failed (non-critical, will retry on timers) */
            }

            // Refresh aggressively on network regain and window focus
            try {
                window.addEventListener('online', () => {
                    try {
                        refreshBadge(true);
                    } catch (_) {
                        /* preset clear API failed for device (continue others) */
                    }
                });
                window.addEventListener('focus', () => {
                    try {
                        refreshBadge();
                    } catch (_) {
                        /* bulk delete overlay rect/portal guard failed (fallback sizing applies) */
                    }
                });
            } catch (_) {
                /* event listener registration best-effort; ignore in non-window contexts */
            }
        })();

        // User dropdown (Account)
        const userBtn = document.getElementById('user-btn');
        const userMenu = document.getElementById('user-menu');

        function closeUserMenu() {
            if (!userMenu) return;
            userBtn?.setAttribute('aria-expanded', 'false');
            userMenu?.setAttribute('aria-hidden', 'true');
            userMenu?.classList.remove('show');
            // Hide the menu properly
            userMenu.style.display = 'none';
            userMenu.style.opacity = '0';
            userMenu.style.pointerEvents = 'none';
            // Restore to original DOM to keep structure tidy
            unportalize(userMenu);
        }
        userBtn?.addEventListener('click', e => {
            e.stopPropagation();
            if (!userMenu) return;
            const willOpen = !userMenu?.classList.contains('show');
            if (willOpen) {
                // Ensure the settings menu is closed when opening user menu
                try {
                    typeof closeMenu === 'function' && closeMenu();
                } catch (_) {
                    /* jellyfin days checkbox toggle wire failed (user can toggle manually) */
                }
                // Also ensure notifications panel is closed when opening user menu
                try {
                    if (window.__closeNotifyCenter) window.__closeNotifyCenter();
                    else {
                        const panel = document.getElementById('notify-center');
                        const btn = document.getElementById('notif-btn');
                        panel?.classList.remove('open');
                        btn?.setAttribute('aria-expanded', 'false');
                    }
                } catch (_) {
                    /* group assign modal debug rect failed (non-fatal) */
                }
                // Use fixed positioning like settings to escape stacking contexts
                userMenu.style.display = 'block';
                userMenu.style.position = 'fixed';
                userMenu.style.zIndex = '12000'; // above preview PiP
                userMenu.style.opacity = '0';
                userMenu.style.pointerEvents = 'none';
                userMenu.style.visibility = 'hidden';
                userMenu.style.left = '0';
                userMenu.style.right = 'auto';
                userMenu.style.top = '0';
                // Move into body to avoid clipping by transformed/overflow ancestors
                portalize(userMenu);
                const prevTransUM = userMenu.style.transition;
                userMenu.style.transition = 'none';
                requestAnimationFrame(() => {
                    try {
                        const vw = Math.max(
                            document.documentElement.clientWidth,
                            window.innerWidth || 0
                        );
                        const rect = userBtn?.getBoundingClientRect();
                        const menuRect = userMenu.getBoundingClientRect();
                        // Use a shared top aligned with the Notifications panel height
                        const top = getHeaderDropdownTop();
                        // Prefer aligning the right edge of the menu to the trigger's right edge
                        let left = Math.max(8, (rect?.right || vw) - menuRect.width);
                        // Clamp to viewport
                        if (left + menuRect.width > vw - 8)
                            left = Math.max(8, vw - menuRect.width - 8);
                        left = Math.min(left, Math.max(8, vw - menuRect.width - 8));
                        userMenu.style.top = `${top}px`;
                        userMenu.style.left = `${left}px`;
                    } catch (err) {
                        console.warn('User menu positioning error', err);
                    }
                    requestAnimationFrame(() => {
                        userMenu.style.transition = prevTransUM || '';
                        userMenu.style.visibility = 'visible';
                        userMenu.style.opacity = '1';
                        userMenu.style.pointerEvents = 'auto';
                        userMenu.classList.add('show');
                    });
                });
            } else {
                userMenu.classList.remove('show');
            }
            userBtn.setAttribute('aria-expanded', String(willOpen));
            userMenu?.setAttribute('aria-hidden', String(!willOpen));
        });
        document.addEventListener('click', e => {
            if (!userMenu) return;
            if (!e.target.closest('#user-dropdown')) closeUserMenu();
        });
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') closeUserMenu();
        });
        // Hover-based auto-close removed; user menu is click-to-toggle only
        // Route account actions to modals (with graceful fallbacks)
        document.getElementById('user-change-password')?.addEventListener('click', e => {
            e.preventDefault();
            closeUserMenu();
            const modal = document.getElementById('modal-change-password');
            if (modal) {
                openModal('modal-change-password');
            } else {
                window.notify?.toast?.({
                    type: 'info',
                    title: 'Account',
                    message: 'Change password is not available in this build.',
                    duration: 2400,
                });
            }
        });
        document.getElementById('user-two-fa')?.addEventListener('click', e => {
            e.preventDefault();
            closeUserMenu();
            // Open the appropriate modal based on current 2FA status
            (async () => {
                try {
                    const cfg = await fetch('/api/admin/config', { credentials: 'include' })
                        .then(r => r.json())
                        .catch(() => ({}));
                    const is2FA = !!cfg?.security?.is2FAEnabled;

                    if (is2FA) {
                        // 2FA is enabled, open disable modal
                        const m = document.getElementById('modal-2fa-disable');
                        if (m) openModal('modal-2fa-disable');
                        else
                            window.notify?.toast?.({
                                type: 'info',
                                title: 'Two‑Factor',
                                message: '2FA disable UI is not available in this build.',
                                duration: 2400,
                            });
                    } else {
                        // 2FA is disabled, generate QR and open enable modal
                        const r = await fetch('/api/admin/2fa/generate', {
                            method: 'POST',
                            credentials: 'include',
                        });
                        if (r.ok) {
                            const j = await r.json().catch(() => ({}));
                            const qr = document.getElementById('qr-code-container');
                            if (qr) {
                                qr.innerHTML = j.qrCodeDataUrl
                                    ? `<img src="${j.qrCodeDataUrl}" alt="Scan QR code" style="background:#fff;padding:8px;border-radius:8px;" />`
                                    : '<span>QR unavailable</span>';
                            }
                        }
                        const m = document.getElementById('modal-2fa');
                        if (m) openModal('modal-2fa');
                        else
                            window.notify?.toast?.({
                                type: 'info',
                                title: 'Two‑Factor',
                                message: '2FA setup UI is not available in this build.',
                                duration: 2400,
                            });
                    }
                } catch (e) {
                    console.warn('2FA menu action failed:', e);
                    // Fallback: just open settings section
                    showSection('settings');
                }
            })();
        });

        // Profile photo menu
        document.getElementById('user-profile-photo')?.addEventListener('click', async e => {
            e.preventDefault();
            closeUserMenu();
            // Reset input
            const input = document.getElementById('avatar-file');
            if (input) input.value = '';
            // Load current avatar preview
            try {
                const resp = await fetch('/api/admin/profile/photo', {
                    cache: 'no-store',
                    credentials: 'include',
                });
                const img = document.getElementById('avatar-image-preview');
                const fallback = document.getElementById('avatar-initials-fallback');
                if (resp.status === 200 && img) {
                    const blob = await resp.blob();
                    img.src = URL.createObjectURL(blob);
                    img.style.display = 'block';
                    if (fallback) fallback.style.display = 'none';
                } else {
                    if (img) {
                        img.removeAttribute('src');
                        img.style.display = 'none';
                    }
                    if (fallback) fallback.style.display = '';
                }
            } catch (_) {
                // ignore
            }
            const m = document.getElementById('modal-avatar');
            if (m) {
                // Reset button states when opening modal
                resetAvatarModalState();
                openModal('modal-avatar');
            } else
                window.notify?.toast?.({
                    type: 'info',
                    title: 'Profile',
                    message: 'Profile photo editor is not available in this build.',
                    duration: 2400,
                });
        });

        // Build avatar initials for user button (fallback to AD) with theme-friendly cool palette
        try {
            const hashCode = str => {
                let h = 0;
                for (let i = 0; i < str.length; i++) h = (h << 5) - h + str.charCodeAt(i);
                return h >>> 0;
            };
            const btn = document.getElementById('user-btn');
            if (btn) {
                (async () => {
                    const nameEl = btn.querySelector('span');
                    const label = (nameEl?.textContent || 'Admin').trim();
                    try {
                        const r = await fetch('/api/admin/profile/photo', {
                            cache: 'no-store',
                            credentials: 'include',
                        });
                        if (r.status === 200) {
                            const blob = await r.blob();
                            const url = URL.createObjectURL(blob);
                            const icon = btn.querySelector('i.fas.fa-user-circle');
                            const existingInitials = btn.querySelector('.avatar-initials');
                            if (icon || existingInitials) {
                                const img = document.createElement('img');
                                img.className = 'avatar-img';
                                img.alt = 'Profile photo';
                                img.src = url;
                                (icon || existingInitials).replaceWith(img);
                                return;
                            }
                        }
                    } catch (_) {
                        /* ignore */
                    }
                    // Fallback to initials if no image available
                    const parts = label.split(/\s+/).filter(Boolean);
                    const initials =
                        parts.length >= 2
                            ? (parts[0][0] + parts[parts.length - 1][0]).toUpperCase()
                            : (label.slice(0, 2) || 'AD').toUpperCase();
                    const icon = btn.querySelector('i.fas.fa-user-circle');
                    if (icon && !btn.querySelector('.avatar-initials')) {
                        const av = document.createElement('span');
                        av.className = 'avatar-initials';
                        av.textContent = initials;
                        const palette = [
                            'hsl(226 72% 52%)',
                            'hsl(248 65% 55%)',
                            'hsl(210 80% 52%)',
                            'hsl(262 55% 52%)',
                            'hsl(192 60% 42%)',
                            'hsl(222 50% 40%)',
                        ];
                        const idx = hashCode(label) % palette.length;
                        av.style.backgroundColor = palette[idx];
                        av.style.color = '#ffffff';
                        av.style.border = '1px solid var(--color-border)';
                        icon.replaceWith(av);
                    }
                })();
            }
        } catch (_) {
            /* ignore */
        }

        // Reset avatar modal button states
        function resetAvatarModalState() {
            const uploadBtn = document.getElementById('avatar-upload-btn');
            const removeBtn = document.getElementById('avatar-remove-btn');
            const cropBtn = document.getElementById('avatar-crop-btn');
            const selectedFileDisplay = document.getElementById('selected-file-display');
            const cropInterface = document.getElementById('crop-interface');

            // Reset upload button to normal state
            if (uploadBtn) {
                uploadBtn.style.background = '';
                uploadBtn.style.height = '';
                uploadBtn.style.minHeight = '';
                uploadBtn.innerHTML = '<i class="fas fa-upload"></i><span>Upload</span>';
            }

            // Reset crop button to normal state
            if (cropBtn) {
                cropBtn.style.display = 'none';
                cropBtn.style.background = '';
                cropBtn.disabled = false;
                cropBtn.innerHTML = '<i class="fas fa-crop"></i> <span>Crop</span>';
            }

            // Hide file selection display
            if (selectedFileDisplay) selectedFileDisplay.style.display = 'none';

            // Hide crop interface
            if (cropInterface) cropInterface.style.display = 'none';

            // Check if user has existing avatar to show/hide remove button
            const previewImg = document.getElementById('avatar-image-preview');
            if (removeBtn) {
                removeBtn.style.display =
                    previewImg && previewImg.src && !previewImg.src.includes('blob:')
                        ? 'inline-block'
                        : 'none';
            }
        }

        // Reset crop button to original state (when selection changes)
        function resetCropButton() {
            const cropBtn = document.getElementById('avatar-crop-btn');
            if (cropBtn) {
                cropBtn.classList.remove('state-success');
                cropBtn.innerHTML = '<i class="fas fa-crop"></i> <span>Crop</span>';
                cropBtn.style.background = '';
                cropBtn.disabled = false;
            }
        }

        // Avatar modal actions
        const uploadBtn = document.getElementById('avatar-upload-btn');
        const removeBtn = document.getElementById('avatar-remove-btn');
        const cropBtn = document.getElementById('avatar-crop-btn');
        const fileInput = document.getElementById('avatar-file');
        const fileTrigger = document.getElementById('avatar-file-trigger');
        const fileNameEl = document.getElementById('avatar-file-name');
        const previewImg = document.getElementById('avatar-image-preview');
        const previewFallback = document.getElementById('avatar-initials-fallback');
        const uploadDropZone = document.getElementById('upload-drop-zone');
        const selectedFileDisplay = document.getElementById('selected-file-display');

        // Open native file picker from themed button
        fileTrigger?.addEventListener('click', () => fileInput?.click());

        // Drag and drop functionality
        uploadDropZone?.addEventListener('dragover', e => {
            e.preventDefault();
            uploadDropZone.classList.add('drag-active');
        });

        uploadDropZone?.addEventListener('dragleave', e => {
            e.preventDefault();
            uploadDropZone.classList.remove('drag-active');
        });

        uploadDropZone?.addEventListener('drop', e => {
            e.preventDefault();
            uploadDropZone.classList.remove('drag-active');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('image/')) {
                    handleFileSelection(file);
                } else {
                    window.notify?.toast({
                        type: 'warning',
                        title: 'Invalid File',
                        message: 'Please select an image file (PNG, JPG, or WebP)',
                        duration: 3000,
                    });
                }
            }
        });

        // Click to upload on drop zone (only if not clicking on the button)
        uploadDropZone?.addEventListener('click', e => {
            // Don't trigger if user clicked on the actual file trigger button
            if (e.target.id === 'avatar-file-trigger' || e.target.closest('#avatar-file-trigger')) {
                return;
            }
            fileInput?.click();
        });

        // File input change handler
        fileInput?.addEventListener('change', () => {
            const f = fileInput.files?.[0];
            if (f) {
                handleFileSelection(f);
            }
        });

        function handleFileSelection(file) {
            // Check file size (2MB limit)
            if (file.size > 2 * 1024 * 1024) {
                window.notify?.toast({
                    type: 'error',
                    title: 'File Too Large',
                    message: 'File size must be less than 2 MB',
                    duration: 3000,
                });
                return;
            }

            // Update file name display
            if (fileNameEl) fileNameEl.textContent = file.name;
            if (selectedFileDisplay) selectedFileDisplay.style.display = 'block';

            // Show crop button now that we have a file
            if (cropBtn) cropBtn.style.display = 'inline-block';

            // Show cropping interface instead of direct preview
            showCroppingInterface(file);

            // Set the file input for later upload
            const dt = new DataTransfer();
            dt.items.add(file);
            fileInput.files = dt.files;
        }

        // Live preview when selecting a file
        uploadBtn?.addEventListener('click', async () => {
            // Check if we have a cropped image or fall back to original file
            if (currentImageFile && cropImage) {
                // Use cropped image
                getCroppedImageBlob(async croppedBlob => {
                    if (!croppedBlob) {
                        window.notify?.toast({
                            type: 'error',
                            title: 'Profile',
                            message: 'Failed to process cropped image',
                            duration: 3000,
                        });
                        return;
                    }

                    await uploadAvatarBlob(croppedBlob, currentImageFile.name);
                });
            } else {
                // Fallback to original file upload
                const fileInput = document.getElementById('avatar-file');
                const files = fileInput?.files;
                if (!files || !files[0]) {
                    window.notify?.toast({
                        type: 'warning',
                        title: 'Profile',
                        message: 'Select an image first',
                        duration: 2000,
                    });
                    return;
                }

                await uploadAvatarBlob(files[0], files[0].name);
            }
        });

        async function uploadAvatarBlob(blob, originalFileName) {
            const form = new FormData();
            form.append('avatar', blob, originalFileName);
            uploadBtn.setAttribute('aria-busy', 'true');
            uploadBtn.disabled = true;
            uploadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Uploading...</span>';
            try {
                const r = await fetch('/api/admin/profile/photo', {
                    method: 'POST',
                    body: form,
                    credentials: 'include',
                });
                if (!r.ok) {
                    const err = await r.json().catch(() => ({}));
                    throw new Error(err?.error || 'Upload failed');
                }
                // Update navbar image immediately
                try {
                    const navBtn = document.getElementById('user-btn');
                    const imgExisting = navBtn?.querySelector('img.avatar-img');
                    const resp = await fetch('/api/admin/profile/photo', {
                        cache: 'no-store',
                        credentials: 'include',
                    });
                    if (resp.status === 200) {
                        const blob = await resp.blob();
                        const url = URL.createObjectURL(blob);
                        if (imgExisting) {
                            imgExisting.src = url;
                        } else if (navBtn) {
                            const icon =
                                navBtn.querySelector('i.fas.fa-user-circle') ||
                                navBtn.querySelector('.avatar-initials');
                            const img = document.createElement('img');
                            img.className = 'avatar-img';
                            img.alt = 'Profile photo';
                            img.src = url;
                            if (icon) icon.replaceWith(img);
                        }
                    }
                } catch (_) {
                    /* ignore */
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Profile',
                    message: 'Photo updated successfully',
                    duration: 2500,
                });
                closeModal('modal-avatar');
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Profile',
                    message: e.message || 'Upload failed',
                    duration: 3000,
                });
            } finally {
                uploadBtn.removeAttribute('aria-busy');
                uploadBtn.disabled = false;
                uploadBtn.innerHTML = '<i class="fas fa-upload"></i><span>Upload</span>';
                uploadBtn.style.background = ''; // Reset background
            }
        }

        // Crop button functionality
        cropBtn?.addEventListener('click', async () => {
            if (!currentImageFile || !cropImage) {
                window.notify?.toast({
                    type: 'warning',
                    title: 'No Image',
                    message: 'Please select an image first',
                    duration: 2000,
                });
                return;
            }

            cropBtn.setAttribute('aria-busy', 'true');
            cropBtn.disabled = true;
            cropBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Cropping...</span>';

            try {
                // Generate cropped image
                getCroppedImageBlob(croppedBlob => {
                    if (!croppedBlob) {
                        throw new Error('Failed to generate cropped image');
                    }

                    // Create URL for the cropped image
                    const croppedUrl = URL.createObjectURL(croppedBlob);

                    // Update the main preview to show cropped result
                    if (previewImg) {
                        previewImg.src = croppedUrl;
                        previewImg.style.display = 'block';
                    }
                    if (previewFallback) previewFallback.style.display = 'none';

                    // Store the cropped blob for upload
                    currentImageFile = new File([croppedBlob], currentImageFile.name, {
                        type: 'image/jpeg',
                        lastModified: Date.now(),
                    });

                    window.notify?.toast({
                        type: 'success',
                        title: 'Image Cropped',
                        message: 'Your image has been cropped successfully. Click Upload to save.',
                        duration: 3000,
                    });

                    // Update Crop button to show it's been used
                    if (cropBtn) {
                        cropBtn.classList.add('state-success');
                        cropBtn.innerHTML = '<i class="fas fa-check"></i> <span>Cropped</span>';
                        // Keep neutral surface; no inline background
                        cropBtn.style.background = '';
                        cropBtn.disabled = true; // Prevent multiple crops of same selection
                    }

                    // Keep Upload button simple and normal
                    if (uploadBtn) {
                        // Don't change the upload button styling or text - keep it simple
                        uploadBtn.style.background = '';
                        uploadBtn.style.height = '';
                        uploadBtn.style.minHeight = '';
                    }

                    // Clean up the URL after a delay
                    setTimeout(() => URL.revokeObjectURL(croppedUrl), 1000);
                });
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Crop Failed',
                    message: e.message || 'Failed to crop image',
                    duration: 3000,
                });
            } finally {
                cropBtn.removeAttribute('aria-busy');
                // If we reached success state, keep the button in that state
                if (!cropBtn.classList.contains('state-success')) {
                    cropBtn.disabled = false;
                    cropBtn.innerHTML = '<i class="fas fa-crop"></i><span>Crop</span>';
                }
            }
        });

        removeBtn?.addEventListener('click', async () => {
            if (!confirm('Are you sure you want to remove your profile photo?')) {
                return;
            }

            removeBtn.setAttribute('aria-busy', 'true');
            removeBtn.disabled = true;
            removeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Removing...</span>';
            try {
                const r = await fetch('/api/admin/profile/photo', {
                    method: 'DELETE',
                    credentials: 'include',
                });
                if (!r.ok) throw new Error('Remove failed');
                // Swap navbar to initials
                const navBtn = document.getElementById('user-btn');
                if (navBtn) {
                    const existing = navBtn.querySelector('img.avatar-img');
                    if (existing) {
                        const nameEl = navBtn.querySelector('span');
                        const label = (nameEl?.textContent || 'Admin').trim();
                        const parts = label.split(/\s+/).filter(Boolean);
                        const initials =
                            parts.length >= 2
                                ? (parts[0][0] + parts[parts.length - 1][0]).toUpperCase()
                                : (label.slice(0, 2) || 'AD').toUpperCase();
                        const span = document.createElement('span');
                        span.className = 'avatar-initials';
                        span.textContent = initials;
                        const palette = [
                            'hsl(226 72% 52%)',
                            'hsl(248 65% 55%)',
                            'hsl(210 80% 52%)',
                            'hsl(262 55% 52%)',
                            'hsl(192 60% 42%)',
                            'hsl(222 50% 40%)',
                        ];
                        const idx =
                            (function hc(s) {
                                let h = 0;
                                for (let i = 0; i < s.length; i++)
                                    h = (h << 5) - h + s.charCodeAt(i);
                                return h >>> 0;
                            })(label) % palette.length;
                        span.style.backgroundColor = palette[idx];
                        span.style.color = '#ffffff';
                        span.style.border = '1px solid var(--color-border)';
                        existing.replaceWith(span);
                    }
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Profile',
                    message: 'Photo removed successfully',
                    duration: 2000,
                });
                closeModal('modal-avatar');
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Profile',
                    message: e.message || 'Remove failed',
                    duration: 2500,
                });
            } finally {
                removeBtn.removeAttribute('aria-busy');
                removeBtn.disabled = false;
                removeBtn.innerHTML = '<i class="fas fa-trash"></i><span>Remove</span>';
            }
        });

        // Image Cropping Functionality
        let currentImageFile = null;
        let cropCanvas = null;
        let cropImage = null;
        const cropData = {
            x: 0,
            y: 0,
            width: 200,
            height: 200,
            scale: 1,
            imageWidth: 0,
            imageHeight: 0,
        };
        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let cropStartX = 0;
        let cropStartY = 0;

        function showCroppingInterface(file) {
            currentImageFile = file;
            const cropInterface = document.getElementById('crop-interface');
            const canvas = document.getElementById('crop-canvas');
            const previewCanvas = document.getElementById('crop-preview');

            if (!cropInterface || !canvas || !previewCanvas) return;

            // Show the cropping interface
            cropInterface.style.display = 'block';

            // Load image into canvas
            const img = new Image();
            const url = URL.createObjectURL(file);

            img.onload = function () {
                // Calculate canvas size to fit image while maintaining aspect ratio
                const maxWidth = 500;
                const maxHeight = 350;
                let canvasWidth, canvasHeight;

                if (img.width > img.height) {
                    canvasWidth = Math.min(img.width, maxWidth);
                    canvasHeight = (img.height * canvasWidth) / img.width;
                } else {
                    canvasHeight = Math.min(img.height, maxHeight);
                    canvasWidth = (img.width * canvasHeight) / img.height;
                }

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                canvas.style.width = canvasWidth + 'px';
                canvas.style.height = canvasHeight + 'px';

                cropCanvas = canvas;
                cropImage = img;

                // Store image dimensions
                cropData.imageWidth = img.width;
                cropData.imageHeight = img.height;

                // Initialize crop area (centered square)
                const size = Math.min(canvasWidth, canvasHeight) * 0.8;
                cropData.width = size;
                cropData.height = size;
                cropData.x = (canvasWidth - size) / 2;
                cropData.y = (canvasHeight - size) / 2;
                cropData.scale = canvasWidth / img.width;

                // Draw image and crop overlay
                drawCropCanvas();
                updateCropOverlay();
                updateCropPreview();

                // Also update the main avatar preview to show original image
                if (previewImg) {
                    previewImg.src = url;
                    previewImg.style.display = 'block';
                }
                if (previewFallback) previewFallback.style.display = 'none';

                // Clean up object URL will be done later after preview is updated
                setTimeout(() => URL.revokeObjectURL(url), 100);
            };

            img.onerror = function () {
                URL.revokeObjectURL(url);
                window.notify?.toast({
                    type: 'error',
                    title: 'Error',
                    message: 'Failed to load image',
                    duration: 3000,
                });
            };

            img.src = url;

            // Setup crop controls
            setupCropControls();
        }

        function drawCropCanvas() {
            if (!cropCanvas || !cropImage) return;

            const ctx = cropCanvas.getContext('2d');
            ctx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);

            // Just draw the image - overlay is handled by CSS
            ctx.drawImage(cropImage, 0, 0, cropCanvas.width, cropCanvas.height);
        }

        function updateCropOverlay() {
            const selection = document.getElementById('crop-selection');
            const overlay = document.getElementById('crop-overlay');
            if (!selection || !overlay || !cropCanvas) return;

            // Reset crop button when selection changes
            resetCropButton();

            // Get canvas position within its container
            const container = document.getElementById('crop-container');
            const canvasRect = cropCanvas.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            // Calculate canvas offset relative to container
            const canvasOffsetX = canvasRect.left - containerRect.left;
            const canvasOffsetY = canvasRect.top - containerRect.top;

            // Position overlay to match canvas exactly
            overlay.style.left = canvasOffsetX + 'px';
            overlay.style.top = canvasOffsetY + 'px';
            overlay.style.width = cropCanvas.width + 'px';
            overlay.style.height = cropCanvas.height + 'px';

            // Position selection within the overlay
            selection.style.left = cropData.x + 'px';
            selection.style.top = cropData.y + 'px';
            selection.style.width = cropData.width + 'px';
            selection.style.height = cropData.height + 'px';
        }

        function updateCropPreview() {
            const previewCanvas = document.getElementById('crop-preview');
            if (!previewCanvas || !cropImage) return;

            const ctx = previewCanvas.getContext('2d');
            ctx.clearRect(0, 0, 80, 80);

            // Calculate source coordinates in original image
            const scaleX = cropData.imageWidth / cropCanvas.width;
            const scaleY = cropData.imageHeight / cropCanvas.height;

            const sourceX = cropData.x * scaleX;
            const sourceY = cropData.y * scaleY;
            const sourceWidth = cropData.width * scaleX;
            const sourceHeight = cropData.height * scaleY;

            // Draw cropped area to preview
            ctx.drawImage(cropImage, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, 80, 80);
        }

        function setupCropControls() {
            const zoomSlider = document.getElementById('crop-zoom');
            const zoomValue = document.getElementById('crop-zoom-value');
            const resetBtn = document.getElementById('crop-reset');
            const selection = document.getElementById('crop-selection');
            const handles = document.querySelectorAll('.crop-handle');

            // Zoom control
            zoomSlider?.addEventListener('input', e => {
                const zoom = parseFloat(e.target.value);
                zoomValue.textContent = Math.round(zoom * 100) + '%';

                // Adjust crop area size based on zoom - always maintain square
                const centerX = cropData.x + cropData.width / 2;
                const centerY = cropData.y + cropData.height / 2;
                // Invert the zoom logic: higher zoom = smaller crop area (more zoomed in)
                const newSize = Math.min(cropCanvas.width, cropCanvas.height) * 0.8 * zoom;

                // Ensure square crop by using same value for width and height
                const size = Math.min(newSize, cropCanvas.width - 20, cropCanvas.height - 20);
                cropData.width = size;
                cropData.height = size;

                cropData.x = Math.max(
                    10,
                    Math.min(centerX - cropData.width / 2, cropCanvas.width - cropData.width - 10)
                );
                cropData.y = Math.max(
                    10,
                    Math.min(
                        centerY - cropData.height / 2,
                        cropCanvas.height - cropData.height - 10
                    )
                );

                drawCropCanvas();
                updateCropOverlay();
                updateCropPreview();
            });

            // Reset crop
            resetBtn?.addEventListener('click', () => {
                const size = Math.min(cropCanvas.width, cropCanvas.height) * 0.8;
                cropData.width = size;
                cropData.height = size;
                cropData.x = (cropCanvas.width - size) / 2;
                cropData.y = (cropCanvas.height - size) / 2;

                if (zoomSlider) {
                    zoomSlider.value = 1;
                    zoomValue.textContent = '100%';
                }

                drawCropCanvas();
                updateCropOverlay();
                updateCropPreview();
            });

            // Square crop is no longer needed - all crops are automatically square

            // Drag crop area
            selection?.addEventListener('mousedown', e => {
                if (e.target.classList.contains('crop-handle')) return;

                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                cropStartX = cropData.x;
                cropStartY = cropData.y;

                selection.style.cursor = 'grabbing';
                e.preventDefault();
            });

            // Handle resizing
            handles.forEach(handle => {
                handle.addEventListener('mousedown', e => {
                    isResizing = true;
                    resizeHandle = e.target.getAttribute('data-handle');
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    cropStartX = cropData.x;
                    cropStartY = cropData.y;

                    e.stopPropagation();
                    e.preventDefault();
                });
            });

            // Mouse move handling
            document.addEventListener('mousemove', e => {
                if (isDragging) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;

                    cropData.x = Math.max(
                        0,
                        Math.min(cropStartX + deltaX, cropCanvas.width - cropData.width)
                    );
                    cropData.y = Math.max(
                        0,
                        Math.min(cropStartY + deltaY, cropCanvas.height - cropData.height)
                    );

                    drawCropCanvas();
                    updateCropOverlay();
                    updateCropPreview();
                } else if (isResizing && resizeHandle) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;

                    // Handle different resize directions - always maintain square aspect ratio
                    switch (resizeHandle) {
                        case 'se': // Southeast
                            {
                                const newWidth = Math.max(
                                    50,
                                    Math.min(
                                        cropStartX + cropData.width + deltaX,
                                        cropCanvas.width
                                    ) - cropData.x
                                );
                                const newHeight = Math.max(
                                    50,
                                    Math.min(
                                        cropStartY + cropData.height + deltaY,
                                        cropCanvas.height
                                    ) - cropData.y
                                );

                                // Use the smaller dimension to maintain square and stay within bounds
                                const maxSize = Math.min(
                                    newWidth,
                                    newHeight,
                                    cropCanvas.width - cropData.x,
                                    cropCanvas.height - cropData.y
                                );
                                const size = Math.max(50, maxSize);

                                cropData.width = size;
                                cropData.height = size;
                            }
                            break;
                        case 'sw': // Southwest
                            {
                                // Keep right edge fixed, move left edge
                                const fixedX = cropStartX + cropData.width; // Right edge stays fixed

                                const newX = Math.max(
                                    0,
                                    Math.min(cropStartX + deltaX, fixedX - 50)
                                );
                                const newWidth = fixedX - newX;

                                const newHeight = Math.max(
                                    50,
                                    Math.min(
                                        cropStartY + cropData.height + deltaY,
                                        cropCanvas.height
                                    ) - cropData.y
                                );

                                // Use the smaller dimension to maintain square and stay within bounds
                                const maxSize = Math.min(
                                    newWidth,
                                    newHeight,
                                    fixedX,
                                    cropCanvas.height - cropData.y
                                );
                                const size = Math.max(50, maxSize);

                                cropData.width = size;
                                cropData.height = size;
                                cropData.x = fixedX - size; // Keep right edge fixed
                            }
                            break;
                        case 'ne': // Northeast
                            {
                                // Keep bottom-left corner fixed
                                const fixedY = cropStartY + cropData.height; // Bottom edge stays fixed

                                const newWidth = Math.max(
                                    50,
                                    Math.min(
                                        cropStartX + cropData.width + deltaX,
                                        cropCanvas.width
                                    ) - cropData.x
                                );

                                const newY = Math.max(
                                    0,
                                    Math.min(cropStartY + deltaY, fixedY - 50)
                                );
                                const newHeight = fixedY - newY;

                                // Use the smaller dimension to maintain square and stay within bounds
                                const maxSize = Math.min(
                                    newWidth,
                                    newHeight,
                                    cropCanvas.width - cropData.x,
                                    fixedY
                                );
                                const size = Math.max(50, maxSize);

                                cropData.width = size;
                                cropData.height = size;
                                cropData.y = fixedY - size; // Keep bottom edge fixed
                            }
                            break;
                        case 'nw': // Northwest
                            {
                                // Keep bottom-right corner fixed
                                const fixedX = cropStartX + cropData.width; // Right edge stays fixed
                                const fixedY = cropStartY + cropData.height; // Bottom edge stays fixed

                                // Calculate new position with stricter bounds
                                const newX = Math.max(
                                    0,
                                    Math.min(cropStartX + deltaX, fixedX - 50)
                                );
                                const newY = Math.max(
                                    0,
                                    Math.min(cropStartY + deltaY, fixedY - 50)
                                );

                                // Calculate maximum possible sizes based on available space
                                const maxWidthFromX = fixedX - newX;
                                const maxHeightFromY = fixedY - newY;
                                const maxWidthFromCanvas = Math.min(fixedX, cropCanvas.width);
                                const maxHeightFromCanvas = Math.min(fixedY, cropCanvas.height);

                                // Use the most restrictive constraint to ensure we stay within bounds
                                const maxSize = Math.min(
                                    maxWidthFromX,
                                    maxHeightFromY,
                                    maxWidthFromCanvas,
                                    maxHeightFromCanvas
                                );
                                const size = Math.max(
                                    50,
                                    Math.min(maxSize, Math.min(fixedX, fixedY))
                                );

                                // Set new position and size - keep bottom-right corner fixed
                                cropData.width = size;
                                cropData.height = size;
                                cropData.x = Math.max(0, fixedX - size);
                                cropData.y = Math.max(0, fixedY - size);
                            }
                            break;
                    }

                    drawCropCanvas();
                    updateCropOverlay();
                    updateCropPreview();
                }
            });

            // Mouse up handling
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    selection.style.cursor = 'move';
                }
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
            });
        }

        function getCroppedImageBlob(callback) {
            if (!cropImage) {
                callback(null);
                return;
            }

            // Create a new canvas for the cropped image
            const croppedCanvas = document.createElement('canvas');
            const size = 600; // High resolution output size for profile photos
            croppedCanvas.width = size;
            croppedCanvas.height = size;

            const ctx = croppedCanvas.getContext('2d');

            // Calculate source coordinates in original image
            const scaleX = cropData.imageWidth / cropCanvas.width;
            const scaleY = cropData.imageHeight / cropCanvas.height;

            const sourceX = cropData.x * scaleX;
            const sourceY = cropData.y * scaleY;
            const sourceWidth = cropData.width * scaleX;
            const sourceHeight = cropData.height * scaleY;

            // Draw cropped area to final canvas
            ctx.drawImage(cropImage, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, size, size);

            // Convert to blob
            croppedCanvas.toBlob(callback, 'image/jpeg', 0.9);
        }

        // Shared restart helper: triggers server restart and polls /health until it's back
        async function triggerRestartAndPoll({
            title = 'Restarting…',
            message = 'Posterrama is restarting. This may take a few seconds.',
        } = {}) {
            // Persistent toast so users get feedback even if POST fails mid-restart
            const t = window.notify?.toast({
                type: 'info',
                title,
                message,
                duration: 0,
            });
            // Fire-and-forget the restart request; errors are non-fatal because the server may drop during restart
            try {
                fetch('/api/admin/restart-app', { method: 'POST', credentials: 'include' }).catch(
                    () => {}
                );
            } catch (_) {
                /* ignore */
            }
            const start = Date.now();
            const timeoutMs = 120000; // 2 minutes safety cap
            const poll = async () => {
                try {
                    const r = await fetch('/health?_=' + Date.now(), { cache: 'no-store' });
                    if (r.ok) {
                        t?.dismiss && t.dismiss();
                        window.notify?.toast({
                            type: 'success',
                            title: 'Back online',
                            message: 'Server is available again. Refreshing…',
                            duration: 2000,
                        });
                        setTimeout(() => location.reload(), 800);
                        return;
                    }
                } catch (_) {
                    /* server likely down; keep polling */
                }
                if (Date.now() - start < timeoutMs) {
                    setTimeout(poll, 1500);
                } else {
                    t?.dismiss && t.dismiss();
                    window.notify?.toast({
                        type: 'warning',
                        title: 'Still restarting',
                        message:
                            'Server not reachable yet. You can refresh manually when it’s back.',
                        duration: 6000,
                    });
                }
            };
            // Short delay to allow restart to begin, then poll
            setTimeout(poll, 1500);
        }

        // Expose to window so save functions in other scopes can use it
        window.triggerRestartAndPoll = triggerRestartAndPoll;

        // Restart action under settings (resilient to immediate POST failure)
        const restartLink = document.getElementById('menu-restart');
        restartLink?.addEventListener('click', async e => {
            e.preventDefault();
            // Immediately close the settings menu and trigger restart on single click
            try {
                closeMenu();
            } catch (_) {
                /* menu already closed or DOM structure changed (non-critical) */
            }
            const el = e.currentTarget;
            el.classList.add('disabled');
            window.triggerRestartAndPoll({
                title: 'Restarting…',
                message: 'Posterrama is restarting. This may take a few seconds.',
            });
            // Keep the control enabled after we initiate restart to allow navigation if needed
            el.classList.remove('disabled');
        });

        // Sidebar section switching (single-level items)
        document.querySelectorAll('.sidebar-nav .nav-item').forEach(item => {
            item.addEventListener('click', e => {
                e.preventDefault();
                const nav = item.getAttribute('data-nav');
                if (!nav) return; // skip items without target section
                document
                    .querySelectorAll('.sidebar-nav .nav-item')
                    .forEach(n => n.classList.remove('active'));
                item.classList.add('active');
                if (nav === 'dashboard') {
                    showSection('section-dashboard');
                } else if (nav === 'display') {
                    // Dedicated placeholder section for Display Settings (coming soon)
                    showSection('section-display');
                } else if (nav === 'devices') {
                    showSection('section-devices');
                    try {
                        document.getElementById('seg-devices')?.click();
                    } catch (_) {
                        /* activating default device tab failed (cosmetic) */
                    }
                    try {
                        window.admin2?.initDevices?.();
                    } catch (_) {
                        /* device init already ran or not yet loaded */
                    }
                    try {
                        if (location.hash !== '#devices') location.hash = '#devices';
                    } catch (_) {
                        /* unable to update hash (history permissions / Safari quirk) */
                    }
                } else if (nav === 'operations') {
                    showSection('section-operations');
                    // ensure latest status/backups when entering
                    refreshUpdateStatusUI();
                    refreshOperationsPanels();
                    // refresh API key status since API Access is now in Operations
                    refreshApiKeyStatus();
                } else if (nav === 'media-sources') {
                    // Always land on Plex tab by default
                    showSection('section-media-sources');
                    try {
                        if (location.hash !== '#plex') location.hash = '#plex';
                    } catch (_) {
                        /* hash sync for media sources failed (non-blocking) */
                    }
                    try {
                        window.admin2?.maybeFetchPlexOnOpen?.();
                    } catch (_) {
                        /* initial plex auto-fetch suppressed (can load manually) */
                    }
                }
            });
        });

        // Media Sources is now a simple nav item handled above via data-nav="media-sources"
        // Show only the selected source panel

        // Functions moved to top-level scope to fix lint errors

        function showSourcePanel(panelId, title) {
            // Ensure section is visible first
            showSection('section-media-sources');
            const section = document.getElementById('section-media-sources');
            if (!section) return;
            const list = section.querySelectorAll('section.panel');
            dbg('showSourcePanel()', { panelId, title, panels: list.length });
            // Put all panels into non-loading state first
            list.forEach(p => p.classList.remove('is-loading'));
            list.forEach(p => {
                if (
                    p.id === 'panel-plex' ||
                    p.id === 'panel-jellyfin' ||
                    p.id === 'panel-tmdb' ||
                    p.id === 'panel-local'
                ) {
                    p.hidden = p.id !== panelId;
                } else {
                    p.hidden = true; // hide overview panel when selecting a specific source
                }
            });
            // When switching panels, ensure multiselect UIs for the target panel are refreshed so that
            // any programmatic auto-selection (first-load) is reflected with chips. This covers cases
            // where the panel was never opened before (UI not wired yet) or options changed while hidden.
            try {
                if (panelId === 'panel-plex') {
                    rebuildMsForSelect('plex-ms-movies', 'plex.movies');
                    rebuildMsForSelect('plex-ms-shows', 'plex.shows');
                } else if (panelId === 'panel-jellyfin') {
                    rebuildMsForSelect('jf-ms-movies', 'jf.movies');
                    rebuildMsForSelect('jf-ms-shows', 'jf.shows');
                }
            } catch (_) {
                /* multiselect rebuild failed (UI will fallback to raw selects) */
            }
            // Keep the main page header static for Media Sources; individual panels have their own titles
            const el = document.getElementById(panelId);
            if (el) {
                // Force show defensively if some stylesheet keeps it hidden
                el.hidden = false;
                const cs = window.getComputedStyle(el);
                if (cs.display === 'none' || cs.visibility === 'hidden') {
                    el.style.display = 'block';
                    el.style.visibility = 'visible';
                }
                const content = el.querySelector('.panel-content');
                if (content) {
                    content.hidden = false;
                    const ccs = window.getComputedStyle(content);
                    if (ccs.display === 'none' || ccs.visibility === 'hidden') {
                        content.style.display = 'block';
                        content.style.visibility = 'visible';
                    }
                }
                dbg('panel visibility', {
                    id: panelId,
                    hidden: el.hidden,
                    display: cs.display,
                    visibility: cs.visibility,
                    contentHidden: content?.hidden,
                });
                // Always scroll the entire page to the absolute top when switching panels
                try {
                    // Primary: window scroll
                    window.scrollTo({ top: 0, left: 0, behavior: 'auto' });
                } catch (_) {
                    // no-op
                }
                try {
                    // Fallbacks for various scroll containers/browsers
                    document.documentElement.scrollTop = 0;
                    document.body.scrollTop = 0;
                    // Attempt common scroll containers just in case
                    const scrollers = document.querySelectorAll(
                        '.main, .content, .container, .layout, .page, .page-content, .content-wrapper, .scroll-container'
                    );
                    scrollers.forEach(s => {
                        if (s && typeof s.scrollTop === 'number') s.scrollTop = 0;
                    });
                } catch (_) {
                    // no-op
                }
                // Show loading overlay while we ensure config is populated
                el.classList.add('is-loading');
                // Ensure auto-fetch runs when panel becomes visible (covers all routes)
                try {
                    if (panelId === 'panel-plex') {
                        // Reset the auto-fetch flag so libraries are re-fetched each time panel opens
                        if (window.__autoFetchedLibs) window.__autoFetchedLibs.plex = false;
                        window.admin2?.maybeFetchPlexOnOpen?.();
                    } else if (panelId === 'panel-jellyfin') {
                        // Reset the auto-fetch flag so libraries are re-fetched each time panel opens
                        if (window.__autoFetchedLibs) window.__autoFetchedLibs.jf = false;
                        window.admin2?.maybeFetchJellyfinOnOpen?.();
                    } else if (panelId === 'panel-tmdb') {
                        window.admin2?.maybeFetchTmdbOnOpen?.();
                        window.admin2?.maybeFetchStreamingProvidersOnOpen?.();
                    } else if (panelId === 'panel-local') {
                        if (window.__autoFetchedLibs) window.__autoFetchedLibs.local = false;
                        window.admin2?.maybeInitLocalDirectoryOnOpen?.();
                    }
                } catch (_) {
                    /* no-op */
                }
            } else {
                dbg('panel not found', { panelId });
            }
            // Kick off background init without blocking the panel UI spinner.
            // Always force a fresh reload of config when switching panels so UI reflects latest
            try {
                const p = window.admin2?.loadMediaSources?.(true);
                if (p && typeof p.then === 'function') p.catch(() => {});
            } catch (_) {
                /* ignore */
            }
            // Always clear loading state shortly after making the panel visible
            setTimeout(() => {
                const active = document.getElementById(panelId);
                active?.classList.remove('is-loading');
                dbg('showSourcePanel() applied', { panelId, visible: !active?.hidden });
                try {
                    // Re-run number input enhancement for any visible numeric fields in the panel
                    const nums = active?.querySelectorAll('input[type="number"]') || [];
                    nums.forEach(el => window.admin2?.enhanceNumberInput?.(el));
                    // Wire steppers for statically pre-wrapped number inputs in this panel
                    window.admin2?.wireNumberWrappers?.(active);
                } catch (_) {
                    /* number input enhancement failed (controls still usable) */
                }
            }, 60);
        }

        // Submenu items removed; segmented tabs handle navigation within section

        // ----- Media Sources segmented tabs (mirror Display) -----
        (function setupSourcesTabs() {
            try {
                const container = document.querySelector('#section-media-sources .segmented');
                if (!container) return;
                // Ensure indicator exists
                let ind = container.querySelector('.seg-indicator');
                if (!ind) {
                    ind = document.createElement('div');
                    ind.className = 'seg-indicator';
                    container.appendChild(ind);
                }
                const segs = [
                    { id: 'seg-plex', val: 'plex', panel: 'panel-plex', hash: '#plex' },
                    {
                        id: 'seg-jellyfin',
                        val: 'jellyfin',
                        panel: 'panel-jellyfin',
                        hash: '#jellyfin',
                    },
                    { id: 'seg-tmdb', val: 'tmdb', panel: 'panel-tmdb', hash: '#tmdb' },
                    { id: 'seg-local', val: 'local', panel: 'panel-local', hash: '#local' },
                ];

                // Forward declaration so early calls can use a no-op until real impl assigned
                const forceUpdateHeaderToggleText = (..._args) => {};

                // Mount per-source header actions into the Media Sources UI
                const topActions = document.querySelector(
                    '#panel-media-sources .panel-header .panel-actions'
                );
                // Ensure right-side actions container exists next to tabs
                const tabsRow = document.querySelector(
                    '#panel-media-sources #sources-tabs .form-row'
                );
                let rightActions = tabsRow?.querySelector('.source-actions-right');
                if (!rightActions && tabsRow) {
                    rightActions = document.createElement('div');
                    rightActions.className = 'source-actions-right';
                    tabsRow.appendChild(rightActions);
                }
                let mountedSource = null; // 'plex' | 'jellyfin' | 'tmdb'
                const moveAll = (from, to) => {
                    if (!from || !to) return;
                    // Move nodes (preserve listeners)
                    while (from.firstChild) to.appendChild(from.firstChild);
                };
                const getActionsContainer = val => document.getElementById(`${val}-actions-home`);
                const mountSourceHeaderActions = val => {
                    if (!topActions) return;
                    try {
                        // Always resolve the current right-side actions container in case the DOM was refreshed
                        const freshTabsRow = document.querySelector(
                            '#panel-media-sources #sources-tabs .form-row'
                        );
                        let currentRight = freshTabsRow?.querySelector('.source-actions-right');
                        if (!currentRight && freshTabsRow) {
                            currentRight = document.createElement('div');
                            currentRight.className = 'source-actions-right';
                            freshTabsRow.appendChild(currentRight);
                        }
                        if (currentRight) rightActions = currentRight;
                        // Return current mounted actions back to their home before switching
                        if (mountedSource) {
                            const prevHome = getActionsContainer(mountedSource);
                            // Return all children from both regions
                            moveAll(topActions, prevHome);
                            moveAll(rightActions, prevHome);
                        }
                        // Move new source actions out and split: save button stays in header, others go to right of tabs
                        const nextHome = getActionsContainer(val);
                        if (!nextHome) return;
                        // Collect children first to avoid live mutations issues
                        const items = Array.from(nextHome.children);
                        // If items are not yet present due to async layout, retry once shortly
                        if (items.length === 0) {
                            setTimeout(() => {
                                try {
                                    // Recreate rightActions if the DOM changed
                                    const freshTabsRow2 = document.querySelector(
                                        '#panel-media-sources #sources-tabs .form-row'
                                    );
                                    let ra = freshTabsRow2?.querySelector('.source-actions-right');
                                    if (!ra && freshTabsRow2) {
                                        ra = document.createElement('div');
                                        ra.className = 'source-actions-right';
                                        freshTabsRow2.appendChild(ra);
                                    }
                                    if (ra) rightActions = ra;
                                } catch (_) {
                                    /* header actions retry failed; will attempt again shortly */
                                }
                                mountSourceHeaderActions(val);
                            }, 50);
                            return;
                        }
                        const saveBtn = items.find(n => n.id?.startsWith('btn-save-'));
                        const others = items.filter(n => n !== saveBtn);
                        // Place save in top header actions
                        if (saveBtn) topActions.appendChild(saveBtn);
                        // Place remaining actions (pills, toggle, test buttons) at right of tabs
                        others.forEach(n => rightActions && rightActions.appendChild(n));
                        mountedSource = val;
                    } catch (_) {
                        /* mountSourceHeaderActions best-effort; non-fatal if it fails */
                    }
                };

                const setActive = val => {
                    segs.forEach(s => {
                        const el = document.getElementById(s.id);
                        if (el) {
                            el.setAttribute('aria-checked', String(s.val === val));
                            const radio = el.querySelector('input[type="radio"]');
                            if (radio) radio.checked = s.val === val;
                        }
                        const panel = document.getElementById(s.panel);
                        if (panel) panel.hidden = s.val !== val;
                    });
                    // Slide indicator
                    const activeSeg = container.querySelector(`.seg[aria-checked="true"]`);
                    if (activeSeg) {
                        const cRect = container.getBoundingClientRect();
                        const sRect = activeSeg.getBoundingClientRect();
                        ind.style.left = `${sRect.left - cRect.left}px`;
                        ind.style.width = `${sRect.width}px`;
                    }
                    // Mount header actions for the active source into the top header
                    mountSourceHeaderActions(val);
                    // After moving actions, force-refresh the header-toggle label text for this source
                    try {
                        const idMap = {
                            plex: 'plex.enabled',
                            jellyfin: 'jf.enabled',
                            tmdb: 'tmdb.enabled',
                        };
                        const inputId = idMap[val];
                        if (inputId && typeof forceUpdateHeaderToggleText === 'function') {
                            // Defer to the next frame to ensure DOM is in place
                            requestAnimationFrame(() => forceUpdateHeaderToggleText(inputId));
                        }
                    } catch (_) {
                        /* preset apply API failed for device (continue others) */
                    }
                };

                // Click handling
                segs.forEach(s => {
                    const el = document.getElementById(s.id);
                    if (!el) return;
                    el.addEventListener('click', e => {
                        e.preventDefault();
                        if (location.hash !== s.hash) location.hash = s.hash;
                        // Show immediately as well
                        setActive(s.val);
                        // Trigger auto-fetch on open
                        try {
                            if (s.panel === 'panel-plex') window.admin2?.maybeFetchPlexOnOpen?.();
                            else if (s.panel === 'panel-jellyfin')
                                window.admin2?.maybeFetchJellyfinOnOpen?.();
                            else if (s.panel === 'panel-tmdb') {
                                window.admin2?.maybeFetchTmdbOnOpen?.();
                                window.admin2?.maybeFetchStreamingProvidersOnOpen?.();
                            } else if (s.panel === 'panel-local') {
                                window.admin2?.maybeInitLocalDirectoryOnOpen?.();
                            }
                        } catch (_) {
                            /* wrapper dataset wiring failed (diagnostic only) */
                        }
                    });
                });

                // Initialize default: Plex
                setActive('plex');

                // Sync with router/hash
                const syncFromHash = () => {
                    const h = (location.hash || '').toLowerCase();
                    if (h === '#jellyfin') setActive('jellyfin');
                    else if (h === '#tmdb') setActive('tmdb');
                    else if (h === '#local') setActive('local');
                    else setActive('plex');
                };
                // Run on enter to sources and on hash changes
                const section = document.getElementById('section-media-sources');
                const obs = new MutationObserver(() => {
                    // When leaving the section, return actions to their home container
                    if (section.hidden && mountedSource && topActions) {
                        try {
                            const home = getActionsContainer(mountedSource);
                            moveAll(topActions, home);
                            // Also return any right-side actions to the home container
                            moveAll(rightActions, home);
                            mountedSource = null;
                        } catch (_) {
                            /* number input enhance attempt failed (manual wrap fallback) */
                        }
                        return;
                    }
                    if (!section.hidden) syncFromHash();
                });
                obs.observe(section, { attributes: true, attributeFilter: ['hidden'] });
                window.addEventListener('hashchange', () => {
                    if (!section.hidden) syncFromHash();
                });
                // Initial sync if already on sources
                if (!section.hidden) syncFromHash();
            } catch (_) {
                /* sources tabs init failed (section falls back to static panels) */
            }
        })();

        // ----- Device Management segmented tabs (mirror Display/Sources) -----
        (function setupDeviceTabs() {
            try {
                const container = document.querySelector('#section-devices .segmented');
                if (!container) return;
                // Ensure indicator exists
                let ind = container.querySelector('.seg-indicator');
                if (!ind) {
                    ind = document.createElement('div');
                    ind.className = 'seg-indicator';
                    container.appendChild(ind);
                }
                const segs = [
                    // 'device-ui' is now an inline content container inside the main device management panel
                    { id: 'seg-devices', val: 'devices', panel: 'device-ui' },
                    { id: 'seg-dev-settings', val: 'settings', panel: 'device-settings-inline' },
                ];
                const setActive = val => {
                    segs.forEach(s => {
                        const el = document.getElementById(s.id);
                        if (el) el.setAttribute('aria-checked', String(s.val === val));
                        const panel = document.getElementById(s.panel);
                        if (panel) panel.hidden = s.val !== val;
                    });
                    const activeSeg = container.querySelector('.seg[aria-checked="true"]');
                    if (activeSeg) {
                        const cRect = container.getBoundingClientRect();
                        const sRect = activeSeg.getBoundingClientRect();
                        ind.style.left = `${sRect.left - cRect.left}px`;
                        ind.style.width = `${sRect.width}px`;
                    }
                    // When switching to Settings, refresh whitelist data
                    if (val === 'settings') {
                        try {
                            if (typeof window.reloadWhitelistData === 'function') {
                                window.reloadWhitelistData();
                            }
                        } catch (_) {
                            /* state export for numeric wrapper debug failed (dev only) */
                        }
                    }
                };
                // Click handling
                segs.forEach(s => {
                    const el = document.getElementById(s.id);
                    if (!el) return;
                    el.addEventListener('click', e => {
                        e.preventDefault();
                        setActive(s.val);
                    });
                });
                // Initialize default: Devices
                setActive('devices');
                // Keep in sync when section toggles visibility
                const section = document.getElementById('section-devices');
                const obs = new MutationObserver(() => {
                    if (!section.hidden) {
                        // Recalculate indicator position on show
                        const active = container.querySelector('.seg[aria-checked="true"]');
                        if (active) {
                            const cRect = container.getBoundingClientRect();
                            const sRect = active.getBoundingClientRect();
                            ind.style.left = `${sRect.left - cRect.left}px`;
                            ind.style.width = `${sRect.width}px`;
                        }
                    }
                });
                obs.observe(section, { attributes: true, attributeFilter: ['hidden'] });
            } catch (_) {
                /* wireNumberWrappers helper export failed (can be called lazily later) */
            }
        })();

        // Device Management group: robust toggle and sub-navigation via event delegation
        (function setupDeviceGroupDelegation() {
            const sidebar = document.querySelector('.sidebar .sidebar-nav');
            if (!sidebar) return;
            sidebar.addEventListener('click', e => {
                const toggle = e.target.closest('.nav-item.nav-toggle');
                if (toggle) {
                    e.preventDefault();
                    const group = toggle.closest('.nav-group');
                    if (!group) return;
                    group.classList.toggle('open');
                    group
                        .querySelectorAll('.nav-subitem')
                        ?.forEach(s => s.classList.remove('active'));
                    // Always open Devices tab by default when clicking the group header
                    showSection('section-devices');
                    try {
                        document.getElementById('seg-devices')?.click();
                    } catch (_) {
                        /* preset clear API failed for device (continue others) */
                    }
                    try {
                        window.admin2?.initDevices?.();
                    } catch (_) {
                        /* previous enabled state detection failed (restart decision may be skipped) */
                    }
                    return;
                }
                const sub = e.target.closest('.nav-subitem');
                if (sub) {
                    e.preventDefault();
                    const group = sub.closest('.nav-group');
                    // Clear top-level nav active states since we're inside a group
                    document
                        .querySelectorAll('.sidebar-nav .nav-item')
                        .forEach(n => n.classList.remove('active'));
                    group?.classList.add('open');
                    group
                        ?.querySelectorAll('.nav-subitem')
                        .forEach(s => s.classList.remove('active'));
                    sub.classList.add('active');
                    const key = sub.getAttribute('data-sub');
                    if (key === 'devices') {
                        showSection('section-devices');
                        try {
                            document.getElementById('seg-devices')?.click();
                            window.admin2?.initDevices?.();
                        } catch (_) {
                            /* inc button stopPropagation suppression failed (benign) */
                        }
                    } else if (key === 'device-settings') {
                        // Switch to Settings tab inside Devices section
                        showSection('section-devices');
                        try {
                            document.getElementById('seg-dev-settings')?.click();
                        } catch (_) {
                            /* dec button stopPropagation suppression failed (benign) */
                        }
                    }
                }
            });
        })();

        // Lightweight hash router so /admin2.html#plex opens Plex panel.
        // On initial load, always show Dashboard regardless of hash.
        // Debounced router to avoid rapid flicker when switching fast
        let routeTimer = null;
        // Persist first-run across any accidental script re-executions to avoid bouncing to Dashboard
        let firstRoute = !window.__adminFirstRouteDone;
        // Preserve last route across hard reloads (fallback)
        try {
            const saved = sessionStorage.getItem('admin:lastRoute');
            if (!location.hash && saved && typeof saved === 'string') {
                const allowed = [
                    '#dashboard',
                    '#display',
                    '#operations',
                    '#devices',
                    '#media-sources',
                ];
                if (allowed.includes(saved)) {
                    history.replaceState(null, '', saved);
                }
            }
        } catch (_) {
            /* slider bars/labels init failed (native sliders still usable) */
        }

        function routeByHash() {
            if (routeTimer) {
                clearTimeout(routeTimer);
                routeTimer = null;
            }
            routeTimer = setTimeout(() => {
                routeTimer = null;
                // First-run: force Dashboard view and clear any hash
                if (firstRoute) {
                    firstRoute = false;
                    try {
                        window.__adminFirstRouteDone = true;
                    } catch (_) {
                        /* no-op */
                    }
                    try {
                        if (location.hash) {
                            // replaceState to avoid history entry
                            history.replaceState(null, '', location.pathname + location.search);
                        }
                    } catch (_) {
                        try {
                            // Fallback if History API fails

                            location.hash = '';
                        } catch (__) {
                            /* no-op */
                        }
                    }
                    // Activate dashboard section and nav item
                    showSection('section-dashboard');
                    document
                        .querySelectorAll('.sidebar-nav .nav-item')
                        .forEach(n => n.classList.remove('active'));
                    document
                        .querySelector('.sidebar-nav .nav-item[data-nav="dashboard"]')
                        ?.classList.add('active');
                    return;
                }
                const h = (location.hash || '').toLowerCase();
                // If user is already on Devices and hash doesn't target a source, keep Devices active
                try {
                    const devicesActive = document
                        .getElementById('section-devices')
                        ?.classList.contains('active');
                    if (
                        devicesActive &&
                        (!h ||
                            h === '#' ||
                            h === '#/' ||
                            h === '#media-sources' ||
                            h === '#media-sources/overview')
                    ) {
                        // Ensure Devices remains visible and skip default routing
                        showSection('section-devices');
                        return;
                    }
                } catch (_) {
                    /* ignore */
                }
                if (h === '#plex' || h === '#media-sources/plex') {
                    showSourcePanel('panel-plex', 'Plex');
                    // Lazy-load on routed open
                    window.admin2?.maybeFetchPlexOnOpen?.();
                    return;
                }
                if (h === '#devices') {
                    showSection('section-devices');
                    try {
                        document.getElementById('seg-devices')?.click();
                        window.admin2?.initDevices?.();
                    } catch (_) {
                        /* device tab activation on hash route failed (benign) */
                    }
                    // showSection already calls ensureNavActive
                    return;
                }
                if (h === '#device-settings') {
                    showSection('section-devices');
                    try {
                        document.getElementById('seg-dev-settings')?.click();
                    } catch (_) {
                        /* settings tab activation on hash route failed (benign) */
                    }
                    return;
                }
                if (h === '#jellyfin') {
                    showSourcePanel('panel-jellyfin', 'Jellyfin');
                    // Lazy-load on routed open
                    window.admin2?.maybeFetchJellyfinOnOpen?.();
                    return;
                }
                if (h === '#tmdb') {
                    showSourcePanel('panel-tmdb', 'TMDB');
                    // Lazy-load on routed open
                    window.admin2?.maybeFetchTmdbOnOpen?.();
                    window.admin2?.maybeFetchStreamingProvidersOnOpen?.();
                    return;
                }
                if (h === '#local') {
                    showSourcePanel('panel-local', 'Local');
                    window.admin2?.maybeInitLocalDirectoryOnOpen?.();
                    return;
                }
                if (h === '#media-sources' || h === '#media-sources/overview') {
                    // Default Media Sources to Plex tab
                    showSection('section-media-sources');
                    try {
                        if (location.hash !== '#plex') location.hash = '#plex';
                    } catch (_) {
                        /* unable to redirect overview hash to #plex (non-critical) */
                    }
                    return;
                }
                // Default: keep current section or overview
            }, 60); // small debounce to smooth rapid clicks
        }
        window.addEventListener('hashchange', routeByHash);
        window.addEventListener('hashchange', () => {
            try {
                sessionStorage.setItem('admin:lastRoute', location.hash || '');
            } catch (_) {
                /* sessionStorage lastRoute persistence failed (non-critical) */
            }
        });
        // Initial route on load
        try {
            sessionStorage.setItem('admin:lastRoute', location.hash || '');
        } catch (_) {
            /* RT minimum score dependency visibility failed (non-blocking) */
        }
        routeByHash();
        // If hash on load points to a top-level section (none currently), ensure submenu is cleared
        try {
            const h0 = (location.hash || '').toLowerCase();
            if (!h0.startsWith('#plex') && !h0.startsWith('#jellyfin') && !h0.startsWith('#tmdb')) {
                document
                    .querySelectorAll('.sidebar-nav .nav-subitem')
                    ?.forEach(s => s.classList.remove('active'));
            }
        } catch (_) {
            /* no-op */
        }

        // Security panel auto-refresh handled on nav; no manual refresh button

        // --- Admin fetch de-dupe + short-lived caching to avoid rate limiter bursts ---
        const inflight = new Map();
        const miniCache = new Map(); // key -> { ts, data, status }
        const MINI_TTL = 10 * 1000; // 10s
        window.dedupJSON = async function (url, opts = {}) {
            const key = `${url}|${opts.method || 'GET'}`;
            const now = Date.now();
            const cached = miniCache.get(key);
            if (cached && now - cached.ts < MINI_TTL) {
                return {
                    ok: cached.status >= 200 && cached.status < 300,
                    json: async () => cached.data,
                    status: cached.status,
                    fromCache: true,
                };
            }
            if (inflight.has(key)) return inflight.get(key);
            const p = (async () => {
                const res = await fetch(url, { credentials: 'include', ...opts });
                const status = res.status;
                // Try to parse JSON either way; some 202/4xx may still include JSON payload
                let data = null;
                try {
                    data = await res.json();
                } catch (_) {
                    data = null;
                }
                // Only cache successful 2xx responses; avoid caching 202-building or errors
                if (res.ok && status >= 200 && status < 300) {
                    miniCache.set(key, { ts: Date.now(), data, status });
                }
                return { ok: res.ok, json: async () => data, status };
            })()
                .catch(err => {
                    return { ok: false, status: 0, error: err };
                })
                .finally(() => inflight.delete(key));
            inflight.set(key, p);
            return p;
        };

        // helper: ensure button spinner exists
        const ensureSpinner = btn => {
            if (!btn) return;
            if (!btn.querySelector('.spinner')) {
                const sp = document.createElement('span');
                sp.className = 'spinner';
                btn.insertBefore(sp, btn.firstChild);
            }
        };

        // Security: change password
        const btnChangePw = document.getElementById('btn-change-password');
        ensureSpinner(btnChangePw);
        btnChangePw?.addEventListener('click', async () => {
            const cur = document.getElementById('sec-current-pw');
            const nw = document.getElementById('sec-new-pw');
            const conf = document.getElementById('sec-confirm-pw');
            const currentPassword = cur?.value || '';
            const newPassword = nw?.value || '';
            const confirmPassword = conf?.value || '';
            if (!currentPassword || !newPassword || !confirmPassword) {
                return window.notify?.toast({
                    type: 'warning',
                    title: 'Missing fields',
                    message: 'Please fill in all password fields',
                    duration: 3500,
                });
            }
            if (newPassword.length < 8) {
                return window.notify?.toast({
                    type: 'warning',
                    title: 'Weak password',
                    message: 'New password must be at least 8 characters',
                    duration: 3500,
                });
            }
            if (newPassword !== confirmPassword) {
                return window.notify?.toast({
                    type: 'warning',
                    title: 'Mismatch',
                    message: 'New password and confirmation do not match',
                    duration: 3500,
                });
            }
            try {
                btnChangePw.classList.add('btn-loading');
                const res = await fetch('/api/admin/change-password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ currentPassword, newPassword, confirmPassword }),
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok)
                    throw new Error(data?.error || data?.message || 'Failed to change password');
                window.notify?.toast({
                    type: 'success',
                    title: 'Password changed',
                    message: 'You will need to log in again.',
                    duration: 4500,
                });
                setTimeout(() => {
                    location.href = '/admin/login';
                }, 1500);
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Change failed',
                    message: e?.message || 'Unable to change password',
                    duration: 5000,
                });
            } finally {
                btnChangePw.classList.remove('btn-loading');
            }
        });

        // Security: 2FA enable flow
        const btn2faEnable = document.getElementById('btn-2fa-enable');
        const btn2faDisable = document.getElementById('btn-2fa-disable');
        ensureSpinner(btn2faEnable);
        ensureSpinner(btn2faDisable);
        btn2faEnable?.addEventListener('click', async () => {
            try {
                btn2faEnable.classList.add('btn-loading');
                const r = await fetch('/api/admin/2fa/generate', {
                    method: 'POST',
                    credentials: 'include',
                });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j?.error || 'Failed to start 2FA setup');
                const qr = document.getElementById('qr-code-container');
                if (qr)
                    qr.innerHTML = j.qrCodeDataUrl
                        ? `<img src="${j.qrCodeDataUrl}" alt="Scan QR code" style="background:#fff;padding:8px;border-radius:8px;" />`
                        : '<span>QR unavailable</span>';
                openModal('modal-2fa');
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: '2FA setup failed',
                    message: e?.message || 'Unable to generate QR code',
                    duration: 5000,
                });
            } finally {
                btn2faEnable.classList.remove('btn-loading');
            }
        });
        // Theme-demo modal close buttons just have data-close-modal and close nearest overlay
        document.querySelectorAll('[data-close-modal]')?.forEach(btn => {
            if (btn.__closeBound) return; // avoid duplicate
            btn.__closeBound = true;
            btn.addEventListener('click', e => {
                e.preventDefault();
                const overlay = btn.closest('.modal-overlay');
                if (overlay && overlay.id) {
                    closeModal(overlay.id);
                } else if (overlay) {
                    overlay.classList.remove('open');
                    overlay.setAttribute('aria-hidden', 'true');
                }
            });
        });
        const btn2faVerify = document.getElementById('btn-2fa-verify');
        const input2faToken = document.getElementById('input-2fa-token');

        // Auto-format 2FA token input (123 456 format)
        input2faToken?.addEventListener('input', e => {
            let value = String(e.target.value || '')
                .replace(/\D/g, '')
                .slice(0, 6);
            if (value.length > 3) value = value.slice(0, 3) + ' ' + value.slice(3);
            e.target.value = value;
            if (value.replace(/\s/g, '').length === 6) {
                btn2faVerify?.focus();
            }
        });

        // Allow Enter key to submit
        input2faToken?.addEventListener('keydown', e => {
            if (e.key === 'Enter' && input2faToken.value.replace(/\s/g, '').length === 6) {
                btn2faVerify?.click();
            }
        });

        ensureSpinner(btn2faVerify);
        btn2faVerify?.addEventListener('click', async () => {
            const input = document.getElementById('input-2fa-token');
            const token = (input?.value || '').replace(/\s/g, '').trim(); // Remove spaces
            if (!token || token.length !== 6) {
                return window.notify?.toast({
                    type: 'warning',
                    title: 'Invalid Code',
                    message: 'Enter the complete 6-digit code from your authenticator app',
                    duration: 3500,
                });
            }
            try {
                btn2faVerify.classList.add('btn-loading');
                btn2faVerify.disabled = true;
                const r = await fetch('/api/admin/2fa/verify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ token }),
                });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j?.error || j?.message || 'Verification failed');
                window.notify?.toast({
                    type: 'success',
                    title: '2FA Enabled Successfully',
                    message: 'Two-Factor Authentication is now protecting your account.',
                    duration: 4000,
                });
                closeModal('modal-2fa');
                refreshSecurity();
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Verification Failed',
                    message: e?.message || 'Invalid or expired code. Please try again.',
                    duration: 5000,
                });
                // Clear input on error
                if (input) {
                    input.value = '';
                    input.focus();
                }
            } finally {
                btn2faVerify?.classList.remove('btn-loading');
                btn2faVerify.disabled = false;
            }
        });

        // Devices UI: initialize interactions when section is shown
        window.admin2 = window.admin2 || {};
        window.admin2.initDevices = function initDevices() {
            const section = document.getElementById('section-devices');
            if (!section) return;
            if (section.dataset.inited === '1') {
                dbg('initDevices(): already initialized');
                return;
            }
            dbg('initDevices(): starting');
            const grid = document.getElementById('device-grid');
            const deviceSearch = document.getElementById('device-search');
            const pageInfo = document.getElementById('device-page-info');
            const pageNumbers = document.getElementById('device-page-numbers');
            const pagePrev = document.getElementById('device-page-prev');
            const pageNext = document.getElementById('device-page-next');
            // per-page selector removed; fixed page size
            const mergeSource = document.getElementById('merge-source');
            const mergeTarget = document.getElementById('merge-target');
            const mergeConfirm = document.getElementById('btn-merge-confirm');
            const bulkBar = document.getElementById('bulk-bar');
            const bulkCount = document.getElementById('bulk-count');

            const state = {
                all: [],
                filteredIds: [],
                currentPage: 1,
                perPage: 9,
                query: '',
                filterStatus: null,
                filterRoom: null,
                presets: [],
                groups: [],
                syncEnabled: undefined, // loaded from /get-config
            };
            // Persist UI pin toggles so they survive reloads; merge with server state
            const PIN_STORE_KEY = 'admin2:pinned-devices';
            const loadPinnedMap = () => {
                try {
                    const raw = localStorage.getItem(PIN_STORE_KEY);
                    const obj = raw ? JSON.parse(raw) : {};
                    return obj && typeof obj === 'object' ? obj : {};
                } catch (_) {
                    return {};
                }
            };
            let pinnedUI = loadPinnedMap();
            const savePinnedMap = () => {
                try {
                    localStorage.setItem(PIN_STORE_KEY, JSON.stringify(pinnedUI));
                } catch (_) {
                    /* section mutation observer setup failed (retries via global observer) */
                }
            };
            // Expose minimal debug hooks
            try {
                window.admin2 = window.admin2 || {};
                window.admin2.devicesDebug = {
                    get state() {
                        return state;
                    },
                    reload: () => loadDevices(),
                    render: () => renderPage(),
                };
            } catch (_) {
                /* plex host/port population failed (inputs may be empty) */
            }

            const slugify = s =>
                String(s || '')
                    .trim()
                    .toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '');

            function getStatusClass(d) {
                const st = String(d?.status || '').toLowerCase();
                // 1) Live when a WebSocket is connected
                if (d?.wsConnected) return 'live';

                // 2) If we haven't seen the device recently, consider it offline
                //    Frontend safeguard so stale "online" doesn't linger when lastSeenAt is old
                const lastTs = Date.parse(d?.lastSeenAt || 0) || 0;
                const now = Date.now();
                const STALE_OFFLINE_MS = 60 * 60 * 1000; // 1 hour
                if (!lastTs) return 'unknown';
                if (now - lastTs > STALE_OFFLINE_MS) return 'offline';

                // 3) Otherwise reflect server status string (online/unknown)
                if (st === 'live') return 'live';
                if (st === 'online') return 'online';
                if (st === 'unknown') return 'unknown';
                return 'offline';
            }
            function iconForStatus(status) {
                switch (String(status || '').toLowerCase()) {
                    case 'live':
                        return 'fas fa-bolt';
                    case 'online':
                        return 'fas fa-signal';
                    case 'offline':
                        return 'fas fa-plug-circle-xmark';
                    default:
                        return 'fas fa-question-circle';
                }
            }
            function iconForDevice(d) {
                const ua = String(d?.clientInfo?.userAgent || '').toLowerCase();
                if (/android|tv/.test(ua)) return 'fa-tv';
                if (/ipad|tablet/.test(ua)) return 'fa-tablet';
                if (/mobile|iphone|android/.test(ua)) return 'fa-mobile-screen';
                if (/windows|mac|linux|chrome|safari|firefox/.test(ua)) return 'fa-desktop';
                return 'fa-display';
            }
            function typeLabel(d) {
                const ua = String(d?.clientInfo?.userAgent || '');
                if (/Android TV/i.test(ua)) return 'Android TV';
                if (/Android/i.test(ua)) return 'Android';
                if (/iPhone|iPad|iOS/i.test(ua)) return 'iOS';
                if (/Chrome/i.test(ua)) return 'Chrome';
                if (/Safari/i.test(ua)) return 'Safari';
                if (/Firefox/i.test(ua)) return 'Firefox';
                if (/Windows/i.test(ua)) return 'Windows';
                if (/Mac OS|Macintosh/i.test(ua)) return 'macOS';
                return 'Browser';
            }
            function isDevicePinned(d) {
                if (!d) return false;
                // Display must ALWAYS reflect what the client reports via server state.
                const cs = d.currentState || {};
                const serverPinned =
                    cs.pinned === true ||
                    cs.pin === true ||
                    (cs.pinMediaId != null && cs.pinMediaId !== '');
                return !!serverPinned;
            }
            function iconForType(type) {
                const t = String(type || '').toLowerCase();
                if (t.includes('android tv')) return 'fas fa-tv';
                if (t === 'android') return 'fab fa-android';
                if (t === 'ios') return 'fab fa-apple';
                if (t === 'chrome') return 'fab fa-chrome';
                if (t === 'safari') return 'fab fa-safari';
                if (t === 'firefox') return 'fab fa-firefox-browser';
                if (t === 'windows') return 'fab fa-windows';
                if (t === 'macos') return 'fab fa-apple';
                if (t === 'browser') return 'fas fa-globe';
                return 'fas fa-display';
            }
            function modeLabel(mode) {
                const m = String(mode || '').toLowerCase();
                if (m === 'screensaver') return 'Screensaver';
                if (m === 'wallart') return 'Wallart';
                if (m === 'cinema') return 'Cinema';
                return '';
            }
            function iconForMode(mode) {
                const m = String(mode || '').toLowerCase();
                if (m === 'screensaver') return 'fas fa-moon';
                if (m === 'wallart') return 'fas fa-images';
                if (m === 'cinema') return 'fas fa-tv';
                return 'fas fa-circle';
            }
            function roomLabel(d) {
                return d.location ? d.location : 'Unassigned';
            }
            function versionMeta(d) {
                // Only show app version; hide user agent details
                const appVer = d?.clientInfo?.appVersion || d?.clientInfo?.version || '';
                return appVer ? `v${appVer}` : '';
            }
            // Resolution helpers -> render using theme-demo badge styles
            function getScreen(d) {
                const sc = d?.clientInfo?.screen || {};
                const w = Number(sc.w || sc.width || 0) || 0;
                const h = Number(sc.h || sc.height || 0) || 0;
                const dpr = Number(sc.dpr || sc.scale || 1) || 1;
                return { w, h, dpr, raw: sc };
            }
            function resolutionTier(d) {
                const { w, h } = getScreen(d);
                if (!w || !h) return null;
                const maxSide = Math.max(w, h);
                if (maxSide >= 7680) return { key: '8K' };
                if (maxSide >= 3840) return { key: '4K' };
                if (maxSide >= 2560) return { key: '1440p' }; // QHD
                if (maxSide >= 1920) return { key: '1080p' };
                if (maxSide >= 1280) return { key: '720p' };
                return { key: 'SD' };
            }
            function resolutionIcon(d) {
                const { w, h, dpr } = getScreen(d);
                const tier = resolutionTier(d);
                if (!tier) return '';
                const label = tier.key;
                const title = `${w}×${h}${dpr && dpr !== 1 ? ` @${dpr}x` : ''}`;
                const cls = (lbl => {
                    switch (lbl) {
                        case '8K':
                            return 'badge-premium'; // gold gradient – stands out
                        case '4K':
                            return 'badge-premium'; // gold gradient – stands out
                        case '1440p':
                            return 'badge-pro'; // purple gradient
                        case '1080p':
                            return 'badge-success'; // green gradient
                        case '720p':
                            return 'badge-primary'; // primary gradient
                        case 'SD':
                        default:
                            return 'badge-secondary'; // gray gradient
                    }
                })(label);
                return `<span class="badge ${cls}" title="${escapeHtml(title)}">${escapeHtml(label)}</span>`;
            }
            // Duplicate detection (hardwareId, installId, UA+screen)
            function uaScKey(d) {
                try {
                    const ci = d && d.clientInfo ? d.clientInfo : {};
                    const ua = (ci.userAgent || ci.ua || '').trim();
                    const sc = ci.screen || {};
                    const w = Number(sc.w || sc.width || 0) || 0;
                    const h = Number(sc.h || sc.height || 0) || 0;
                    const dpr = Number(sc.dpr || sc.scale || 1) || 1;
                    if (!ua || !w || !h) return '';
                    return `${ua}|${w}x${h}@${dpr}x`;
                } catch (_) {
                    return '';
                }
            }
            function computeDupMaps() {
                const hwMap = Object.create(null);
                const iidMap = Object.create(null);
                const uaScMap = Object.create(null);
                const list = (state.filteredIds || [])
                    .map(id => state.all.find(x => x.id === id))
                    .filter(Boolean);
                try {
                    list.forEach(d => {
                        const hw = d && d.hardwareId;
                        if (hw) (hwMap[hw] = hwMap[hw] || []).push(d);
                        const iid = d && d.installId;
                        if (iid) (iidMap[iid] = iidMap[iid] || []).push(d);
                        const key = uaScKey(d);
                        if (key) (uaScMap[key] = uaScMap[key] || []).push(d);
                    });
                } catch (_) {
                    /* mutation observer setup failed (hashchange + retries still run) */
                }
                state.dupMaps = { hwMap, iidMap, uaScMap };
            }
            function getDupesForDevice(d) {
                const maps = state.dupMaps || {};
                const { hwMap = {}, iidMap = {}, uaScMap = {} } = maps;
                const reasonsById = Object.create(null);
                const add = (x, reason) => {
                    if (!x || x.id === d.id) return;
                    const entry = reasonsById[x.id] || { dev: x, reasons: new Set() };
                    entry.reasons.add(reason);
                    reasonsById[x.id] = entry;
                };
                try {
                    if (d.hardwareId && hwMap[d.hardwareId] && hwMap[d.hardwareId].length > 1) {
                        for (const x of hwMap[d.hardwareId]) add(x, 'hardwareId');
                    }
                    if (d.installId && iidMap[d.installId] && iidMap[d.installId].length > 1) {
                        for (const x of iidMap[d.installId]) add(x, 'installId');
                    }
                    const key = uaScKey(d);
                    if (key && uaScMap[key] && uaScMap[key].length > 1) {
                        for (const x of uaScMap[key]) add(x, 'UA+screen');
                    }
                } catch (_) {
                    /* hashchange wrap attempt failed (later attempts continue) */
                }
                return Object.values(reasonsById).map(v => ({
                    dev: v.dev,
                    reasons: Array.from(v.reasons),
                }));
            }
            function deriveDeviceMode(d) {
                try {
                    const override = d?.settingsOverride || {};
                    // Explicit override precedence with hard disable semantics
                    const ovCinema = override.cinemaMode === true;
                    const ovCinemaDisabled = override.cinemaMode === false;
                    const ovWallart = !!(
                        override.wallartMode &&
                        typeof override.wallartMode === 'object' &&
                        override.wallartMode.enabled
                    );

                    if (ovCinema) return 'cinema';
                    if (ovWallart) return 'wallart';
                    // If override explicitly disabled cinema and wallart not enabled, force screensaver regardless of stale reported mode
                    if (ovCinemaDisabled && !ovWallart) return 'screensaver';

                    // Ignore presence of override.cinema object unless cinemaMode === true
                    const reported = (d?.clientInfo?.mode || d?.mode || '').toLowerCase();
                    if (!ovCinemaDisabled) {
                        // only trust reported if not explicitly disabled
                        if (reported === 'cinema' || reported === 'cinema mode') return 'cinema';
                    }
                    if (reported === 'wallart') return 'wallart';
                    return 'screensaver';
                } catch (_) {
                    return 'screensaver';
                }
            }
            function renderCard(d) {
                const status = getStatusClass(d);
                const icon = iconForDevice(d);
                const type = typeLabel(d);
                const mode = deriveDeviceMode(d);
                const room = roomLabel(d);
                const meta = versionMeta(d);
                // Filter orphan group IDs (those not in state.groups) at render time
                let validGroups = [];
                try {
                    if (Array.isArray(d.groups) && Array.isArray(state.groups)) {
                        const validSet = new Set(state.groups.map(g => g.id));
                        validGroups = d.groups.filter(g => validSet.has(g));
                    }
                } catch (_) {
                    /* intersection observer wrap trigger failed (other triggers remain) */
                }
                // Build group pills HTML only when needed
                let groupsHtml = '';
                if (validGroups.length > 0) {
                    groupsHtml = `<div class="dev-groups">${validGroups
                        .map(gid => {
                            const g = state.groups.find(x => x.id === gid);
                            const label = escapeHtml(g?.name || gid);
                            return `<span class="group-pill" title="Group: ${label}">${label}</span>`;
                        })
                        .join('')}</div>`;
                }
                const disabledPower = status === 'offline' ? ' disabled' : '';
                const isPoweredOff = d?.currentState?.poweredOff === true;
                const poweredOff = isPoweredOff ? ' title="Currently powered off"' : '';
                const statusLabel =
                    status === 'live'
                        ? isPoweredOff
                            ? 'Powered off'
                            : 'Live'
                        : status === 'online'
                          ? 'Online'
                          : status === 'unknown'
                            ? 'Unknown'
                            : 'Offline';
                const dupeList = getDupesForDevice(d);
                const dupesPill = (() => {
                    if (!dupeList || !dupeList.length) return '';
                    const listIds = dupeList.map(x => x.dev && x.dev.id).filter(Boolean);
                    const tipList = dupeList
                        .map(x => {
                            const nm =
                                (x.dev && x.dev.name ? String(x.dev.name).slice(0, 40) : '') ||
                                (x.dev && x.dev.id ? x.dev.id.slice(0, 8) : '(unnamed)');
                            const sid = (x.dev && x.dev.id ? x.dev.id : '').slice(0, 8);
                            const rsn =
                                x.reasons && x.reasons.length ? ` [${x.reasons.join(', ')}]` : '';
                            return `${nm} — ${sid}${rsn}`;
                        })
                        .join('\n');
                    const title = `Likely duplicates (reasons per item):\n${tipList}`;
                    const safeTitle = title.replace(/"/g, '&quot;');
                    const safeIds = listIds.join(',').replace(/"/g, '&quot;');
                    return `<span class="pill pill-dup js-dupes-hover" title="${safeTitle}" data-dupes-ids="${safeIds}" data-dupes-title="${safeTitle}"><i class="fas fa-clone"></i> Dupes: ${dupeList.length}</span>`;
                })();
                // Map preset and groups to human-readable labels
                const presetKey = (d && typeof d.preset === 'string' ? d.preset : '').trim();
                const presetName = presetKey
                    ? state.presets.find(p => p.key === presetKey)?.name || presetKey
                    : '';
                const groupNames = Array.isArray(d?.groups)
                    ? d.groups
                          .map(gid => {
                              const g = (state.groups || []).find(
                                  x => x.id === gid || x.key === gid
                              );
                              return g?.name || gid;
                          })
                          .filter(Boolean)
                    : [];
                // Playback state helpers for toolbar play/pause button
                const pausedFlag = d?.currentState?.paused;
                const ppCls = pausedFlag === true ? ' is-paused' : ' is-playing';
                // Icon represents STATE (not action):
                // - playing => play icon (gray)
                // - paused  => pause icon (yellow)
                const ppIcon = pausedFlag === true ? 'fa-pause' : /* paused */ 'fa-play';
                const ppTitle = pausedFlag === true ? 'Resume' : 'Pause';
                // Pin button initial state
                const initiallyPinned = isDevicePinned(d);
                const pinCls = initiallyPinned ? ' is-pinned' : '';
                const pinIcon = initiallyPinned ? 'fa-map-pin' : 'fa-thumbtack';
                const pinTitle = initiallyPinned ? 'Unpin poster' : 'Pin current poster';
                const pinPressed = initiallyPinned ? 'true' : 'false';
                // Now-playing info (uses device-reported currentState URLs)
                const cs = d && d.currentState ? d.currentState : {};
                // thumbnailUrl is already mode-aware (wallart uses backgroundUrl)
                const thumbSrc = cs.thumbnailUrl || cs.posterUrl || cs.backgroundUrl || '';
                const thumbAlt = escapeHtml(cs.title || d.name || '');
                // Show thumbnail only if URL exists AND device is not offline
                const hasNowplay = !!thumbSrc && status !== 'offline';
                const thumbRightHtml = hasNowplay
                    ? `<div class="nowplay-thumb nowplay-thumb-right js-media-hover"><img src="${thumbSrc}" alt="${thumbAlt}" loading="lazy" decoding="async" referrerpolicy="no-referrer" width="48" height="72" onerror="this.parentElement.remove();this.closest('.device-card').classList.remove('has-nowplay');"></div>`
                    : '';
                // Title rendering handled via live reconcile; no separate inline row here
                return `
                                <div class="device-card${dupeList && dupeList.length ? ' has-dupes' : ''}${hasNowplay ? ' has-nowplay' : ''}" data-id="${d.id}" data-status="${status}" data-room="${(room || '').toLowerCase().replace(/\s+/g, '-')}" data-dupes-count="${dupeList ? dupeList.length : 0}">
                                    ${d.wsConnected && state.syncEnabled !== false ? '<div class="device-corner"><span class="synced-dot" role="status" aria-label="Device will align to sync ticks" title="Device will align to sync ticks"></span></div>' : ''}
                                                                        <div class="device-card-header">
                                                                                <div class="device-select-wrap">
                                                                                        <label class="checkbox" aria-label="Select device: ${escapeHtml(d.name || d.id)}">
                                                                                                <input type="checkbox" class="device-select">
                                                                                                <span class="checkmark"></span>
                                                                                        </label>
                                                                                </div>
                                        <div class="device-id">
                                            <div class="device-avatar"><i class="fas ${icon}"></i></div>
                                            <div class="device-title">
                                                <div class="name-row">
                                                    <span class="name">${escapeHtml(d.name || 'Unnamed')}</span>
                                                    <button class="btn btn-icon btn-xxs btn-rename-inline" title="Rename device"><i class="fas fa-pen"></i></button>
                                                </div>
                                                <span class="meta">${escapeHtml(meta)}</span>
                                            </div>
                                        </div>
                                        <div class="device-res">${resolutionIcon(d)}</div>
                                    </div>

                                    <div class="device-tools">
                                                <button type="button" class="btn btn-icon btn-sm btn-power${isPoweredOff ? ' is-off' : ''}" title="Power Toggle"${disabledPower}${poweredOff}><i class="fas fa-power-off"></i></button>
                                                <button type="button" class="btn btn-icon btn-sm btn-reload" title="Reload this device"><i class="fas fa-rotate-right"></i></button>
                                                <button type="button" class="btn btn-icon btn-sm btn-clearcache" title="Clear caches"><i class="fas fa-broom"></i></button>
                                                <button type="button" class="btn btn-icon btn-sm btn-pair card-secondary" title="Generate pairing code"><i class="fas fa-qrcode"></i></button>
                                                <button type="button" class="btn btn-icon btn-sm btn-remote card-secondary" title="Open remote control" ${status === 'offline' || isPoweredOff ? 'disabled' : ''}><i class="fas fa-gamepad"></i></button>
                                                <button type="button" class="btn btn-icon btn-sm btn-override card-secondary" title="Edit display settings override"><i class="fas fa-sliders"></i></button>
                                                ${(() => {
                                                    try {
                                                        const ov = d.settingsOverride || {};
                                                        const has =
                                                            ov &&
                                                            typeof ov === 'object' &&
                                                            Object.keys(ov).length;
                                                        return has
                                                            ? '<button type="button" class="btn btn-icon btn-sm btn-clear-override card-secondary" title="Clear overrides" aria-label="Clear overrides"><i class="fas fa-eraser"></i></button>'
                                                            : '';
                                                    } catch (_) {
                                                        return '';
                                                    }
                                                })()}
                                                <button type="button" class="btn btn-icon btn-sm btn-sendcmd card-secondary" title="Send command" ${status === 'offline' || isPoweredOff ? 'disabled' : ''}><i class="fas fa-terminal"></i></button>
                                                <button type="button" class="btn btn-icon btn-sm btn-playpause${ppCls}" title="${ppTitle}" ${status === 'offline' || isPoweredOff ? 'disabled' : ''}><i class="fas ${ppIcon}"></i></button>
                                                <button type="button" class="btn btn-icon btn-sm btn-pin card-secondary${pinCls}" title="${pinTitle}" aria-pressed="${pinPressed}" ${status === 'offline' || isPoweredOff ? 'disabled' : ''}><i class="fas ${pinIcon}"></i></button>
                                                <div class="dropdown card-more" style="position:relative;display:none;">
                                                        <button class="btn btn-icon btn-sm" title="More"><i class="fas fa-ellipsis"></i></button>
                                                        <div class="dropdown-menu"></div>
                                                </div>
                                    </div>
                                                                        <div class="device-card-body">
                                                                                <div class="device-body-main">
                                                                                    <div class="device-badges">
                                            <span class="status-pill status-${status} js-status-hover" tabindex="0">
                                                <i class="${iconForStatus(isPoweredOff && status === 'live' ? 'offline' : status)}"></i> ${statusLabel}
                                            </span>
                                                          <span class="status-pill sp-browser"><i class="${iconForType(type)}"></i> ${escapeHtml(type)}</span>
                                                          ${dupesPill}
                                                          
                                                                                      ${(() => {
                                                                                          const m =
                                                                                              String(
                                                                                                  mode ||
                                                                                                      ''
                                                                                              ).toLowerCase();
                                                                                          const mClass =
                                                                                              m ===
                                                                                              'screensaver'
                                                                                                  ? 'pill-screensaver'
                                                                                                  : m ===
                                                                                                      'wallart'
                                                                                                    ? 'pill-wallart'
                                                                                                    : m ===
                                                                                                            'cinema' ||
                                                                                                        m ===
                                                                                                            'cinema mode'
                                                                                                      ? 'pill-cinema'
                                                                                                      : 'pill-mode';
                                                                                          return modeLabel(
                                                                                              mode
                                                                                          )
                                                                                              ? `<span class="status-pill ${mClass.replace('pill-', 'sp-')}"><i class="${iconForMode(mode)}"></i> ${escapeHtml(modeLabel(mode))}</span>`
                                                                                              : '';
                                                                                      })()}
                                                                                     
                                                                                </div>
                                                        </div>
                                                </div>
                                    <div class="device-actions">
                                        ${thumbRightHtml}
                                        <div class="meta-pills" style="display:flex; gap:6px; flex-wrap:wrap;">
                                            <span class="status-pill" title="Location"><i class="fas fa-location-dot"></i> ${escapeHtml(room)}</span>
                                            ${presetName ? `<span class="status-pill" title="Preset"><i class="fas fa-star"></i> ${escapeHtml(presetName)}</span>` : ''}
                                            ${groupNames.length ? `<span class="status-pill" title="Groups"><i class="fas fa-layer-group"></i> ${escapeHtml(groupNames.join(', '))}</span>` : ''}
                                        </div>
                                    </div>
                                    ${groupsHtml}
                                </div>`;
            }
            function escapeHtml(s) {
                return String(s || '')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }
            // Collapse secondary per-card actions into a kebab menu when space is tight
            function collapseCardActions(card) {
                try {
                    const row = card.querySelector('.device-tools');
                    const moreWrap = card.querySelector('.card-more');
                    if (!row || !moreWrap) return;
                    const moreBtn = moreWrap.querySelector('button');
                    const menu = moreWrap.querySelector('.dropdown-menu');
                    if (!moreBtn || !menu) return;
                    const secondary = Array.from(row.querySelectorAll('.card-secondary'));
                    if (!secondary.length) return;
                    // Determine if actions overflow the row; be slightly conservative to avoid wrap
                    const rowOverflow = row.scrollWidth - row.clientWidth > 2;
                    // Collapse only on real overflow AND very small screens; otherwise allow wrapping
                    const tooNarrow = rowOverflow && window.innerWidth < 640;
                    if (tooNarrow) {
                        // Build menu items for hidden actions (use button titles)
                        menu.innerHTML = secondary
                            .map(
                                (btn, idx) =>
                                    `<div class="dropdown-item" data-card-idx="${idx}">${btn.title || btn.getAttribute('aria-label') || 'Action'}</div>`
                            )
                            .join('');
                        // Hide secondary buttons and show kebab
                        secondary.forEach(btn => (btn.style.display = 'none'));
                        moreWrap.style.display = 'inline-block';
                        // Attach click proxy once
                        if (!moreWrap._menuWired) {
                            moreWrap._menuWired = true;
                            moreBtn?.addEventListener('click', e => {
                                e.stopPropagation();
                                const open = menu.style.display === 'block';
                                menu.style.display = open ? 'none' : 'block';
                                if (!open) {
                                    // Position the dropdown relative to viewport
                                    const r = moreBtn.getBoundingClientRect();
                                    menu.style.position = 'fixed';
                                    menu.style.top = `${r.bottom + 6}px`;
                                    // Try aligning right edge roughly
                                    const left = Math.max(
                                        8,
                                        Math.min(window.innerWidth - 228, r.right - 200)
                                    );
                                    menu.style.left = `${left}px`;
                                    menu.style.zIndex = 1701; // above hovercards
                                }
                            });
                            document.addEventListener('click', ev => {
                                if (!menu.contains(ev.target) && ev.target !== moreBtn)
                                    menu.style.display = 'none';
                            });
                            // Basic keyboard support for accessibility
                            menu.addEventListener('keydown', e => {
                                if (e.key === 'Escape') {
                                    menu.style.display = 'none';
                                    moreBtn.focus();
                                }
                            });
                            menu.addEventListener('click', ev => {
                                const item = ev.target.closest('.dropdown-item');
                                if (!item) return;
                                const idx = Number(item.getAttribute('data-card-idx'));
                                // Use the latest snapshot of hidden buttons
                                const list = moreWrap._secondary || secondary;
                                const target = list && list[idx];
                                if (target) {
                                    target.click();
                                }
                                menu.style.display = 'none';
                            });
                        }
                        // Store current secondary reference for this menu scope (refresh each time)
                        moreWrap._secondary = secondary;
                    } else {
                        // Restore inline buttons and hide kebab
                        secondary.forEach(btn => (btn.style.display = ''));
                        menu.innerHTML = '';
                        if (menu.style.display !== 'none') menu.style.display = 'none';
                        moreWrap.style.display = 'none';
                    }
                } catch (_) {
                    /* device card action collapse failed (layout may overflow; non-fatal) */
                }
            }

            function bindCardEvents(card) {
                const cb = card.querySelector('.device-select');
                cb?.addEventListener('change', e => {
                    try {
                        e.stopPropagation();
                    } catch (_) {
                        /* preset apply API failed for device (continue others) */
                    }
                    try {
                        if (window.__uiDebug)
                            console.info('[DevUI] selection change', {
                                id: card.getAttribute('data-id'),
                                checked: cb.checked,
                            });
                    } catch (_) {
                        /* preset clear API failed for device (continue others) */
                    }
                    card.classList.toggle('selected', cb.checked);
                    updateBulkUI();
                });
                card.querySelector('.btn-power')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* previous enabled state detection failed (restart decision may be skipped) */
                    }
                    const id = card.getAttribute('data-id');
                    await sendCommand(id, 'power.toggle');
                });
                card.querySelector('.btn-reload')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* previous enabled state detection failed (restart decision may be skipped) */
                    }
                    const id = card.getAttribute('data-id');
                    // Suppress SW update toasts briefly around action
                    try {
                        window.__suppressSwUpdateToasts = true;
                        setTimeout(() => (window.__suppressSwUpdateToasts = false), 8000);
                    } catch (_) {
                        /* previous enabled state detection failed (restart decision may be skipped) */
                    }
                    // one-time spin animation on the icon
                    try {
                        const icon = card.querySelector('.btn-reload i');
                        if (icon) {
                            icon.classList.remove('icon-spin-once');
                            // force reflow to restart animation if already applied
                            void icon.offsetWidth;
                            icon.classList.add('icon-spin-once');
                        }
                    } catch (_) {
                        /* suppressSwUpdateToasts flag update failed (non-critical) */
                    }
                    await sendCommand(id, 'core.mgmt.reload');
                    // Keep hash neutral to avoid router reactions
                    try {
                        if (location.hash && location.hash !== '#devices')
                            location.hash = '#devices';
                    } catch (_) {
                        /* location hash normalization failed; safe to ignore */
                    }
                    window.notify?.toast({
                        type: 'info',
                        title: 'Reload',
                        message: `${state.all.find(d => d.id === id)?.name || id}: reloading`,
                    });
                });
                card.querySelector('.btn-clearcache')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* suppressSwUpdateToasts flag update failed (non-critical) */
                    }
                    const id = card.getAttribute('data-id');
                    // Suppress SW update toasts briefly around action
                    try {
                        window.__suppressSwUpdateToasts = true;
                        setTimeout(() => (window.__suppressSwUpdateToasts = false), 8000);
                    } catch (_) {
                        /* location hash normalization failed; safe to ignore */
                    }
                    // broom sweep animation
                    try {
                        const icon = card.querySelector('.btn-clearcache i');
                        if (icon) {
                            icon.classList.remove('broom-sweep');
                            void icon.offsetWidth; // restart
                            icon.classList.add('broom-sweep');
                        }
                    } catch (_) {
                        /* UI debug log optional; continue */
                    }
                    await sendCommand(id, 'core.mgmt.clearCache');
                    // Keep hash neutral to avoid router reactions
                    try {
                        if (location.hash && location.hash !== '#devices')
                            location.hash = '#devices';
                    } catch (_) {
                        /* UI debug log optional; continue */
                    }
                    window.notify?.toast({
                        type: 'success',
                        title: 'Clear cache',
                        message: `${state.all.find(d => d.id === id)?.name || id}: cache cleared`,
                    });
                });
                card.querySelector('.btn-pair')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* click guard failed; continue with pairing flow */
                    }
                    const id = card.getAttribute('data-id');
                    try {
                        if (window.__uiDebug) console.info('[DevUI] btn-pair click', id);
                    } catch (_) {
                        /* debug log optional; ignore */
                    }
                    await openPairingFor([id]);
                });
                card.querySelector('.btn-remote')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* click guard failed; continue with remote flow */
                    }
                    const id = card.getAttribute('data-id');
                    openRemoteFor(id);
                });
                card.querySelector('.btn-override')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* click guard failed; continue with override flow */
                    }
                    const id = card.getAttribute('data-id');
                    openOverrideFor([id]);
                });
                card.querySelector('.btn-clear-override')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* click guard failed; continue with clear override flow */
                    }
                    const id = card.getAttribute('data-id');
                    const proceed = await (async () => {
                        try {
                            return await confirmAction({
                                title: 'Clear Display Overrides',
                                message: `Remove all display settings overrides for <strong>${escapeHtml(
                                    state.all.find(d => d.id === id)?.name || id
                                )}</strong>? It will then only inherit server and group configuration.`,
                                okText: 'Clear Overrides',
                                okClass: 'btn-accent btn-confirm-accent',
                                okIcon: 'eraser',
                            });
                        } catch (_) {
                            // Fallback to native confirm if themed modal fails for any reason
                            return window.confirm(
                                'Remove all overrides for this device? It will only follow server + group config.'
                            );
                        }
                    })();
                    if (!proceed) return;
                    try {
                        await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ settingsOverride: {} }),
                        });
                        window.notify?.toast?.({
                            type: 'success',
                            title: 'Overrides cleared',
                            message: state.all.find(d => d.id === id)?.name || id,
                        });
                        await loadDevices();
                    } catch (err) {
                        window.notify?.toast?.({
                            type: 'error',
                            title: 'Failed to clear',
                            message: err?.message || 'Could not clear overrides',
                        });
                    }
                });
                card.querySelector('.btn-sendcmd')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* click guard failed; continue with sendcmd flow */
                    }
                    const id = card.getAttribute('data-id');
                    try {
                        if (window.__uiDebug) console.info('[DevUI] btn-sendcmd click', id);
                    } catch (_) {
                        /* debug log optional; ignore */
                    }
                    openSendCmdFor([id]);
                });
                card.querySelector('.btn-playpause')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* click guard failed; continue with play/pause flow */
                    }
                    const id = card.getAttribute('data-id');
                    const btn = card.querySelector('.btn-playpause');
                    const icon = btn?.querySelector('i');
                    // Optimistic UI toggle
                    if (btn) {
                        const wasPaused = btn.classList.contains('is-paused');
                        btn.classList.toggle('is-paused', !wasPaused);
                        btn.classList.toggle('is-playing', wasPaused);
                        // New icon semantics: represent STATE
                        // nowPaused => show pause icon; nowPlaying => show play icon
                        const nowPaused = !wasPaused;
                        if (icon) icon.className = `fas ${nowPaused ? 'fa-pause' : 'fa-play'}`;
                        // Title can reflect next action when clicked
                        btn.title = nowPaused ? 'Resume' : 'Pause';
                    }
                    try {
                        await sendCommand(id, 'playback.toggle');
                        // Attempt to update local device state if present
                        const dev = state.all.find(d => d.id === id);
                        if (dev) {
                            dev.currentState = dev.currentState || {};
                            const nowPaused = btn?.classList.contains('is-paused');
                            dev.currentState.paused = nowPaused;
                        }
                    } catch (_) {
                        // revert optimistic change on failure
                        if (btn) {
                            const nowPaused = btn.classList.contains('is-paused');
                            const revertToPaused = !nowPaused; // revert to previous
                            btn.classList.toggle('is-paused', revertToPaused);
                            btn.classList.toggle('is-playing', !revertToPaused);
                            // Re-apply icon reflecting the (reverted) STATE
                            if (icon)
                                icon.className = `fas ${revertToPaused ? 'fa-pause' : 'fa-play'}`;
                            // Title reflects the next action
                            btn.title = revertToPaused ? 'Resume' : 'Pause';
                        }
                    }
                });
                card.querySelector('.btn-pin')?.addEventListener('click', async e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* click guard failed; continue with pin flow */
                    }
                    const id = card.getAttribute('data-id');
                    const btn = card.querySelector('.btn-pin');
                    const icon = btn?.querySelector('i');
                    const wasPinned = !!btn?.classList.contains('is-pinned');
                    // optimistic UI: toggle pinned state and aria-pressed immediately
                    if (btn) {
                        btn.classList.toggle('is-pinned', !wasPinned);
                        const pressed = !wasPinned;
                        btn.setAttribute('aria-pressed', pressed ? 'true' : 'false');
                        if (icon) {
                            icon.className = pressed ? 'fas fa-map-pin' : 'fas fa-thumbtack';
                        }
                        btn.title = pressed ? 'Unpin poster' : 'Pin current poster';
                    }
                    try {
                        const cmd = wasPinned ? 'playback.resume' : 'playback.pinPoster';
                        await sendCommand(id, cmd);
                        // Update local maps and in-memory state
                        if (wasPinned) {
                            if (pinnedUI && pinnedUI[id]) delete pinnedUI[id];
                            savePinnedMap();
                            const dev = state.all.find(d => d.id === id);
                            if (dev) {
                                dev.currentState = dev.currentState || {};
                                dev.currentState.pinned = false;
                                // Use empty string to explicitly signal cleared pin to server/UI
                                dev.currentState.pinMediaId = '';
                            }
                        } else {
                            pinnedUI = pinnedUI || {};
                            pinnedUI[id] = true;
                            savePinnedMap();
                            const dev = state.all.find(d => d.id === id);
                            if (dev) {
                                dev.currentState = dev.currentState || {};
                                dev.currentState.pinned = true;
                            }
                        }
                    } catch (_) {
                        // revert on failure
                        if (btn) {
                            btn.classList.toggle('is-pinned', wasPinned);
                            const pressed = wasPinned;
                            btn.setAttribute('aria-pressed', pressed ? 'true' : 'false');
                            if (icon) {
                                icon.className = pressed ? 'fas fa-map-pin' : 'fas fa-thumbtack';
                            }
                            btn.title = pressed ? 'Unpin poster' : 'Pin current poster';
                        }
                    }
                });
                // Support both inline header pencil and legacy rename button
                const renameBtn = card.querySelector('.btn-rename, .btn-rename-inline');
                renameBtn?.addEventListener('click', e => {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                    } catch (_) {
                        /* click guard failed; continue with rename */
                    }
                    startRename(card);
                });
                // per-card merge/group buttons removed; actions available via toolbar
                // Ensure action row collapses when width is tight
                collapseCardActions(card);
            }
            function startRename(card) {
                try {
                    const id = card.getAttribute('data-id');
                    const nameEl = card.querySelector('.device-title .name');
                    if (!nameEl || nameEl.dataset.editing === '1') return;
                    const current = nameEl.textContent || '';
                    nameEl.dataset.editing = '1';
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = current;
                    input.className = 'inline-rename-input';
                    // styling handled in theme CSS (.inline-rename-input)
                    const finish = async commit => {
                        nameEl.dataset.editing = '';
                        nameEl.style.display = '';
                        input.remove();
                        if (!commit) return;
                        const val = (input.value || '').trim();
                        if (!val || val === current) return;
                        try {
                            await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ name: val }),
                            });
                            nameEl.textContent = val;
                            window.notify?.toast({
                                type: 'success',
                                title: 'Renamed',
                                message: 'Device name updated',
                            });
                        } catch (e) {
                            window.notify?.toast({
                                type: 'error',
                                title: 'Rename failed',
                                message: e?.message || 'Could not update device',
                            });
                        }
                    };
                    nameEl.style.display = 'none';
                    nameEl.parentElement.insertBefore(input, nameEl);
                    input.focus();
                    input.select();
                    input.addEventListener('keydown', ev => {
                        if (ev.key === 'Enter') finish(true);
                        else if (ev.key === 'Escape') finish(false);
                    });
                    input.addEventListener('blur', () => finish(true));
                } catch (_) {
                    /* bulk bar responsive collapse failed (controls still functional) */
                }
            }
            function updateBulkUI() {
                const selected = document.querySelectorAll(
                    '#device-grid .device-card.selected'
                ).length;
                if (bulkCount) bulkCount.textContent = String(selected);
                if (bulkBar) {
                    bulkBar.classList.toggle('open', selected > 0);
                    if (selected > 0) {
                        try {
                            const r = bulkBar.getBoundingClientRect();
                            if (
                                (r.width === 0 || r.height === 0) &&
                                bulkBar.parentElement !== document.body
                            ) {
                                if (window.__uiDebug)
                                    console.warn('[DevUI] bulk bar zero-rect; portal relocation');
                                document.body.appendChild(bulkBar);
                                requestAnimationFrame(() => {
                                    const r2 = bulkBar.getBoundingClientRect();
                                    if (window.__uiDebug)
                                        console.info(
                                            '[DevUI] bulk bar rect after portal',
                                            r2.toJSON()
                                        );
                                });
                            }
                        } catch (_) {
                            /* notify min-level select change failed (non-critical) */
                        }
                    }
                }
                // Responsive controls: collapse secondary buttons on narrow widths
                try {
                    const bar = document.getElementById('bulk-bar');
                    const more = document.getElementById('bulk-more');
                    const menu = document.getElementById('bulk-more-menu');
                    if (bar && more && menu) {
                        const tooNarrow = bar.clientWidth < 760; // heuristic
                        const secs = Array.from(bar.querySelectorAll('.bulk-secondary'));
                        if (tooNarrow) {
                            // move secondary buttons into dropdown menu
                            menu.innerHTML = secs
                                .map(
                                    btn =>
                                        `<div class="dropdown-item" data-bulk-proxy="#${btn.id}">${btn.title}</div>`
                                )
                                .join('');
                            secs.forEach(btn => (btn.style.display = 'none'));
                            more.parentElement.style.display = 'inline-block';
                        } else {
                            secs.forEach(btn => (btn.style.display = ''));
                            more.parentElement.style.display = 'none';
                            menu.innerHTML = '';
                        }
                        more.onclick = () => {
                            const open = menu.style.display === 'block';
                            menu.style.display = open ? 'none' : 'block';
                            if (!open) {
                                // position below button
                                const r = more.getBoundingClientRect();
                                menu.style.position = 'fixed';
                                menu.style.top = `${r.bottom + 6}px`;
                                menu.style.left = `${Math.max(8, r.left - 120)}px`;
                                menu.style.zIndex = 3002;
                            }
                        };
                        document.addEventListener('click', e => {
                            if (!menu.contains(e.target) && e.target !== more)
                                menu.style.display = 'none';
                        });
                        menu.onclick = e => {
                            const item = e.target.closest('.dropdown-item');
                            if (!item) return;
                            const targetSel = item.getAttribute('data-bulk-proxy');
                            const target = targetSel ? document.querySelector(targetSel) : null;
                            if (target) target.click();
                            menu.style.display = 'none';
                        };
                    }
                } catch (_) {
                    /* inline rename init failed (rename action skipped) */
                }
            }
            async function sendCommand(id, type, payload) {
                try {
                    const wait = type.startsWith('playback.') ? 'false' : 'true';
                    const res = await fetchJSON(
                        `/api/devices/${encodeURIComponent(id)}/command?wait=${wait}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type, payload }),
                        }
                    );
                    if (res?.ack?.status === 'timeout') {
                        window.notify?.toast({
                            type: 'warning',
                            title: 'No response',
                            message: 'Device did not ack in time',
                        });
                    }
                    return res;
                } catch (e) {
                    window.notify?.toast({
                        type: 'error',
                        title: 'Command failed',
                        message: e?.message || 'Failed to send',
                    });
                    return null;
                }
            }
            function populateMergeOptions() {
                if (!mergeSource || !mergeTarget) return;
                const opts = state.all
                    .map(d => `<option value="${d.id}">${escapeHtml(d.name || d.id)}</option>`)
                    .join('');
                mergeSource.innerHTML = opts;
                mergeTarget.innerHTML = opts;
            }
            function openMergeWith(targetId) {
                populateMergeOptions();
                if (mergeTarget && targetId) mergeTarget.value = targetId;
                const overlay = document.getElementById('modal-merge');
                if (overlay) {
                    __showOverlay(overlay, 'modal-merge');
                    try {
                        if (window.__uiDebug)
                            console.info(
                                '[ModalDebug] merge rect',
                                overlay.getBoundingClientRect().toJSON()
                            );
                    } catch (_) {
                        /* merge modal debug log optional; ignore */
                    }
                }
            }
            async function submitMerge() {
                const src = mergeSource?.value;
                const tgt = mergeTarget?.value;
                if (!src || !tgt || src === tgt) {
                    return window.notify?.toast({
                        type: 'warning',
                        title: 'Select two different devices',
                    });
                }
                try {
                    const res = await fetchJSON(`/api/devices/${encodeURIComponent(tgt)}/merge`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ sourceIds: [src] }),
                    });
                    if (res?.ok) {
                        window.notify?.toast({
                            type: 'success',
                            title: 'Merged',
                            message: `${res.merged} device merged`,
                        });
                        document.getElementById('modal-merge')?.classList.remove('open');
                        await loadDevices();
                    }
                } catch (e) {
                    window.notify?.toast({
                        type: 'error',
                        title: 'Merge failed',
                        message: e?.message || 'Failed to merge',
                    });
                }
            }

            // Utilities: Modals for pairing, remote, override, send command
            async function openPairingFor(ids, overrides) {
                if (!Array.isArray(ids) || !ids.length) return;
                const container = document.getElementById('pairing-list');
                if (container) {
                    // Reset previous content and timers if any
                    container.innerHTML = '';
                    if (container._tickTimer) {
                        try {
                            clearInterval(container._tickTimer);
                        } catch (_) {
                            /* clearInterval may throw if timer already cleared; ignore */
                        }
                        container._tickTimer = null;
                    }
                    if (container._pairPollTimer) {
                        try {
                            clearInterval(container._pairPollTimer);
                        } catch (_) {
                            /* clearInterval may throw if timer already cleared; ignore */
                        }
                        container._pairPollTimer = null;
                    }
                }
                // Keep title static; show device name inside content name bar if single selection
                try {
                    const bar = document.getElementById('pairing-namebar');
                    const text = document.getElementById('pairing-namebar-text');
                    if (bar && text) {
                        if (ids.length === 1) {
                            const firstId = ids[0];
                            const dev = (state.all || []).find(d => d.id === firstId);
                            const meta = (overrides && overrides[firstId]) || {};
                            const name = meta.name || dev?.name || firstId;
                            text.textContent = String(name);
                            bar.hidden = false;
                        } else {
                            bar.hidden = true;
                            text.textContent = '—';
                        }
                    }
                } catch (_) {
                    /* pairing namebar build failed (falls back to generic title) */
                }
                const fmtExp = ms => {
                    const s = Math.max(0, Math.round(ms / 1000));
                    const m = Math.floor(s / 60);
                    const r = s % 60;
                    return m ? `${m}m ${r}s` : `${r}s`;
                };
                // Track generated codes to detect successful claims and auto-close modal
                const watchers = [];
                for (const id of ids) {
                    try {
                        const r = await fetchJSON(
                            `/api/devices/${encodeURIComponent(id)}/pairing-code`,
                            {
                                method: 'POST',
                                // Requires admin session; allow cookies (default in fetchJSON)
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ ttlMs: 600000, requireToken: false }),
                            }
                        );
                        const dev = (state.all || []).find(d => d.id === id);
                        const meta = (overrides && overrides[id]) || {};
                        const location =
                            meta.location != null ? meta.location : dev?.location || '';
                        const groupIds = Array.isArray(meta.groups)
                            ? meta.groups
                            : Array.isArray(dev?.groups)
                              ? dev.groups
                              : [];
                        // Map group ids to names using state.groups
                        const groups = Array.isArray(groupIds)
                            ? groupIds
                                  .map(gid => {
                                      const g = (state.groups || []).find(
                                          x => String(x.id) === String(gid)
                                      );
                                      return g ? g.name || g.id : gid;
                                  })
                                  .filter(Boolean)
                            : [];
                        // Determine a safe origin for Claim URL. Prefer current window.origin when location is not an absolute URL
                        let baseOrigin = '';
                        try {
                            // If location looks like a full URL, use that; else fallback to current origin
                            if (typeof location === 'string' && /^https?:\/\//i.test(location)) {
                                baseOrigin = new URL(location).origin;
                            } else if (location && location.origin) {
                                baseOrigin = String(location.origin);
                            } else {
                                baseOrigin = window.location.origin;
                            }
                        } catch (_) {
                            baseOrigin = window.location.origin;
                        }
                        const claimUrl = `${baseOrigin}/?pair=${encodeURIComponent(r?.code || '')}`;
                        if (r?.code) {
                            watchers.push({ id, code: String(r.code) });
                        }
                        const ttlMs =
                            Number(r?.expiresInMs) ||
                            Math.max(0, Date.parse(r?.expiresAt || 0) - Date.now());
                        const expMs = Math.max(0, ttlMs);
                        const expAt = Date.now() + expMs;
                        const tagHtml = `
                            <div class="pairing-tags" aria-label="Device attributes">
                                ${location ? `<span class="pill" title="Location"><i class="fas fa-location-dot"></i> ${escapeHtml(String(location))}</span>` : ''}
                                ${groups
                                    .map(
                                        g =>
                                            `<span class="pill" title="Group"><i class="fas fa-layer-group"></i> ${escapeHtml(String(g))}</span>`
                                    )
                                    .join(' ')}
                            </div>`;
                        const html = `
                            <div class="pairing-item" data-expires-at="${String(expAt)}">
                                <div class="pairing-meta">
                                    <div class="pairing-header">
                                        ${tagHtml}
                                    </div>
                                    <div class="pairing-row">
                                        <div class="pairing-label">Code</div>
                                        <div class="pairing-copy">
                                            <code class="pairing-code">${escapeHtml(r?.code || '—')}</code>
                                            <button class="btn btn-outline btn-sm" data-copy="${escapeHtml(
                                                r?.code || ''
                                            )}"><i class="fas fa-copy"></i> Copy</button>
                                        </div>
                                    </div>
                                    <div class="pairing-row">
                                        <div class="pairing-label">Claim URL</div>
                                        <div class="pairing-copy">
                                            <code class="pairing-code pairing-url">${escapeHtml(claimUrl)}</code>
                                            <button class="btn btn-outline btn-sm" data-copy="${escapeHtml(
                                                claimUrl
                                            )}"><i class="fas fa-copy"></i> Copy</button>
                                        </div>
                                    </div>
                                    
                                </div>
                            </div>`;
                        if (container) container.insertAdjacentHTML('beforeend', html);
                    } catch (e) {
                        window.notify?.toast({
                            type: 'error',
                            title: 'Pairing',
                            message: `Failed for ${id}`,
                        });
                    }
                }
                if (container && !container._copyBound) {
                    container.addEventListener('click', async ev => {
                        const btn = ev.target?.closest('[data-copy]');
                        if (!btn) return;
                        const val = btn.getAttribute('data-copy') || '';
                        try {
                            await navigator.clipboard.writeText(val);
                            window.notify?.toast({ type: 'success', title: 'Copied to clipboard' });
                        } catch (_) {
                            // Fallback: create a temporary textarea to copy from
                            const ta = document.createElement('textarea');
                            ta.value = val;
                            ta.setAttribute('readonly', '');
                            ta.style.position = 'fixed';
                            ta.style.opacity = '0';
                            ta.style.pointerEvents = 'none';
                            document.body.appendChild(ta);
                            ta.select();
                            try {
                                document.execCommand?.('copy');
                            } catch (_) {
                                /* display section lazy init failed (user can still navigate manually) */
                            }
                            window.getSelection()?.removeAllRanges?.();
                            document.body.removeChild(ta);
                        }
                    });
                    container._copyBound = true;
                }
                // Start ticking countdown in modal footer (earliest expiry across items)
                if (container) {
                    const footerEl = document.getElementById('pairing-exp-footer');
                    // Reset previous timer if any
                    if (container._tickTimer) {
                        try {
                            clearInterval(container._tickTimer);
                        } catch (_) {
                            /* clearInterval may throw if timer already cleared; ignore */
                        }
                        container._tickTimer = null;
                    }
                    const tick = () => {
                        const items = Array.from(container.querySelectorAll('.pairing-item'));
                        if (!items.length) {
                            if (footerEl) footerEl.textContent = '';
                            return;
                        }
                        const now = Date.now();
                        let minLeft = Infinity;
                        for (const item of items) {
                            const expAt = Number(item.getAttribute('data-expires-at') || '0');
                            const left = Math.max(0, expAt - now);
                            if (left < minLeft) minLeft = left;
                        }
                        if (footerEl) {
                            footerEl.textContent =
                                minLeft > 0 ? `Expires in ${fmtExp(minLeft)}` : 'Expired';
                        }
                    };
                    tick();
                    container._tickTimer = setInterval(tick, 1000);
                }
                // QR removed per UX
                const pairingOverlay = document.getElementById('modal-pairing');
                if (pairingOverlay) {
                    __showOverlay(pairingOverlay, 'modal-pairing');
                    try {
                        const r = pairingOverlay.getBoundingClientRect();
                        if (window.__uiDebug)
                            console.info('[ModalDebug] openPairingFor rect', r.toJSON());
                        if (
                            (r.width === 0 || r.height === 0) &&
                            pairingOverlay.parentElement !== document.body
                        ) {
                            console.warn('[ModalDebug] pairing zero-rect; force portal move');
                            document.body.appendChild(pairingOverlay);
                            pairingOverlay.setAttribute('data-portal', 'true');
                            requestAnimationFrame(() => {
                                const r2 = pairingOverlay.getBoundingClientRect();
                                if (window.__uiDebug)
                                    console.info(
                                        '[ModalDebug] pairing rect after portal',
                                        r2.toJSON()
                                    );
                                if (r2.width === 0 || r2.height === 0) {
                                    pairingOverlay.style.width = '100vw';
                                    pairingOverlay.style.height = '100vh';
                                }
                            });
                        }
                    } catch (_) {
                        /* clear pairing tick timer failed (timer was already null) */
                    }
                }

                // Helper to show a short success state and fade out the modal
                function closePairingModalWithSuccess() {
                    try {
                        if (!pairingOverlay) return;
                        const box = pairingOverlay.querySelector('.modal');
                        if (box) {
                            box.innerHTML =
                                '<div class="modal-body"><div class="pairing-success"><i class="fas fa-check-circle"></i><span>Screen Paired</span></div></div>';
                        }
                        // stop timers to avoid UI flicker during fade
                        if (container && container._tickTimer) {
                            try {
                                clearInterval(container._tickTimer);
                            } catch (_) {
                                /* clearInterval may throw if timer already cleared; ignore */
                            }
                            container._tickTimer = null;
                        }
                        if (container && container._pairPollTimer) {
                            try {
                                clearInterval(container._pairPollTimer);
                            } catch (_) {
                                /* clearInterval may throw if timer already cleared; ignore */
                            }
                            container._pairPollTimer = null;
                        }
                        pairingOverlay.classList.add('fade-out');
                        setTimeout(() => {
                            pairingOverlay.classList.remove('open');
                            pairingOverlay.classList.remove('fade-out');
                        }, 650);
                    } catch (_) {
                        /* pairing modal success close is best-effort; ignore */
                    }
                }

                // Poll devices to see when any watched code gets claimed, then refresh + close modal
                if (container && watchers.length) {
                    const pollOnce = async () => {
                        try {
                            const list = await fetchJSON('/api/devices').catch(() => null);
                            if (!Array.isArray(list)) return;
                            const byId = new Map(list.map(d => [String(d.id), d]));
                            const now = Date.now();
                            for (const w of watchers) {
                                const d = byId.get(String(w.id));
                                if (!d) continue;
                                const p = d.pairing || {};
                                const lp = Date.parse(p.lastPairedAt || 0) || 0;
                                const codeStillMatches =
                                    p.code && String(p.code) === String(w.code);
                                const recentlyPaired = lp && now - lp < 5 * 60 * 1000; // 5 minutes
                                if (recentlyPaired && !codeStillMatches) {
                                    try {
                                        await loadDevices();
                                    } catch (_) {
                                        /* load/refresh after pairing is best-effort; ignore */
                                    }
                                    try {
                                        await refreshDevices();
                                    } catch (_) {
                                        /* device refresh after pairing is best-effort; ignore */
                                    }
                                    closePairingModalWithSuccess();
                                    // Stop polling after success
                                    if (container._pairPollTimer) {
                                        try {
                                            clearInterval(container._pairPollTimer);
                                        } catch (_) {
                                            /* clearInterval may throw if timer already cleared; ignore */
                                        }
                                        container._pairPollTimer = null;
                                    }
                                    return;
                                }
                            }
                        } catch (_) {
                            /* ignore */
                        }
                    };
                    // Prime once quickly, then poll every 1.5s
                    pollOnce();
                    container._pairPollTimer = setInterval(pollOnce, 1500);
                }
            }
            function openRemoteFor(id) {
                const dev = (state.all || []).find(d => d.id === id);
                const nameEl = document.getElementById('remote-target-name');
                if (nameEl) nameEl.textContent = dev ? `— ${dev.name || dev.id}` : '';
                const overlay = document.getElementById('modal-remote');
                if (!overlay) return;
                // Stash current device id on overlay for delegated handler
                overlay.dataset.targetId = id;
                __showOverlay(overlay, 'modal-remote');
                try {
                    if (window.__uiDebug)
                        console.info(
                            '[ModalDebug] openRemoteFor rect',
                            overlay.getBoundingClientRect().toJSON()
                        );
                } catch (_) {
                    /* DOMContentLoaded wrap attempt failed (later timers/raf still execute) */
                }
                // Attach a single delegated click handler once
                if (!overlay._remoteBound) {
                    overlay.addEventListener('click', async ev => {
                        const btn = ev.target?.closest?.('[data-remote]');
                        if (!btn || !overlay.contains(btn)) return;
                        const key = btn.getAttribute('data-remote');
                        const targetId = overlay.dataset.targetId;
                        if (!targetId) return;
                        try {
                            // Brief pulse feedback
                            try {
                                btn.classList.remove('pulse');
                                // Force reflow to restart animation

                                btn.offsetHeight;
                                btn.classList.add('pulse');
                            } catch (_) {
                                /* pulse feedback animation best-effort; ignore */
                            }
                            if (key === 'playpause') {
                                await sendCommand(targetId, 'playback.toggle');
                            } else {
                                await sendCommand(targetId, 'remote.key', { key });
                            }
                        } catch (_) {
                            /* remote command send failed; UI already resilient */
                        }
                    });
                    overlay._remoteBound = true;
                }
            }
            async function openOverrideFor(ids) {
                if (!Array.isArray(ids) || !ids.length) return;
                const overlay = document.getElementById('modal-override');
                const textarea = document.getElementById('override-json');
                if (overlay) __showOverlay(overlay, 'modal-override');
                try {
                    overlay &&
                        window.__uiDebug &&
                        console.info(
                            '[ModalDebug] openOverrideFor rect',
                            overlay.getBoundingClientRect().toJSON()
                        );
                } catch (_) {
                    /* admin2 mediaSourceWrapDebug export failed (debug only) */
                }
                const applyBtn = document.getElementById('btn-override-apply');
                const statusEl = document.getElementById('override-json-status');
                const formatBtn = document.getElementById('override-format');
                const clearBtn = document.getElementById('override-clear');
                const cleanBtn = document.getElementById('override-clean');
                const mixedBadge = document.getElementById('mode-mixed-badge');
                const conflictWrap = document.getElementById('override-conflicts');
                const conflictCountEl = document.getElementById('conflict-count');
                const conflictList = document.getElementById('conflict-list');
                const conflictEmpty = document.getElementById('conflicts-empty');
                const conflictsBody = document.getElementById('conflicts-body');
                const conflictsToggle = document.getElementById('conflicts-toggle');
                const conflictsRescan = document.getElementById('conflicts-rescan');
                const seg = document.getElementById('mode-segment');
                const snippetsWrap = document.getElementById('override-snippets');
                let originalPerDevice = {}; // id -> settingsOverride object
                let conflictData = { paths: [], map: {} }; // map[path] => { values:Set<string>, samples:[{device,value}] }
                function deriveMode(obj) {
                    if (!obj || typeof obj !== 'object') return 'general';
                    if (obj.cinemaMode === true || (obj.cinema && typeof obj.cinema === 'object'))
                        return 'cinema';
                    if (
                        (obj.wallartMode &&
                            typeof obj.wallartMode === 'object' &&
                            obj.wallartMode.enabled) ||
                        (obj.wallart && typeof obj.wallart === 'object')
                    )
                        return 'wallart';
                    return 'general';
                }
                function normalizeLegacy(obj) {
                    if (obj && obj.wallart && !obj.wallartMode) {
                        // attempt shallow transform if legacy key used
                        obj.wallartMode = obj.wallartMode || {};
                        if (obj.wallart.duration && !obj.wallartMode.transitionInterval)
                            obj.wallartMode.transitionInterval = obj.wallart.duration;
                        delete obj.wallart; // remove legacy key
                    }
                }
                async function loadOverrides(ids) {
                    const collected = [];
                    for (const id of ids) {
                        try {
                            const dev = await fetchJSON(`/api/devices/${encodeURIComponent(id)}`);
                            if (
                                dev &&
                                dev.settingsOverride &&
                                typeof dev.settingsOverride === 'object'
                            ) {
                                collected.push(dev.settingsOverride);
                            }
                        } catch (_) {
                            /* per-device overrides load best-effort; skip on failure */
                        }
                    }
                    return collected;
                }
                // Load overrides for all selected devices
                let mode = 'general';
                if (textarea) {
                    const all = await loadOverrides(ids);
                    originalPerDevice = {};
                    all.forEach((o, i) => {
                        originalPerDevice[ids[i]] = JSON.parse(JSON.stringify(o || {}));
                    });
                    if (all.length === 1) {
                        const obj = all[0];
                        normalizeLegacy(obj);
                        textarea.value = JSON.stringify(obj, null, 2);
                        mode = deriveMode(obj);
                    } else if (all.length > 1) {
                        // Determine if mixed
                        const modes = new Set();
                        all.forEach(o => modes.add(deriveMode(o)));
                        if (modes.size === 1) {
                            const merged = all.reduce((acc, cur) => Object.assign(acc, cur), {});
                            normalizeLegacy(merged);
                            textarea.value = JSON.stringify(merged, null, 2);
                            mode = [...modes][0];
                        } else {
                            mode = '__mixed';
                            textarea.value = '{}';
                        }
                    } else if (!textarea.dataset.userEdited) {
                        textarea.value =
                            '{\n  "wallartMode": { "enabled": true, "animationType": "fade" }\n}';
                        mode = 'wallart';
                    }
                }

                const SNIPPET_SETS = {
                    general: [
                        { label: 'syncEnabled', json: { syncEnabled: true } },
                        {
                            label: 'transitionIntervalSeconds',
                            json: { transitionIntervalSeconds: 45 },
                        },
                        { label: 'transitionEffect=fade', json: { transitionEffect: 'fade' } },
                        { label: 'effectPauseTime=2', json: { effectPauseTime: 2 } },
                        { label: 'uiScaling.content', json: { uiScaling: { content: 110 } } },
                        { label: 'clockFormat=12h', json: { clockFormat: '12h' } },
                    ],
                    wallart: [
                        { label: 'wallartMode.enabled', json: { wallartMode: { enabled: true } } },
                        {
                            label: 'wallartMode.density=high',
                            json: { wallartMode: { density: 'high' } },
                        },
                        {
                            label: 'wallartMode.animationType=fade',
                            json: { wallartMode: { animationType: 'fade' } },
                        },
                        {
                            label: 'wallartMode.itemsPerScreen=40',
                            json: { wallartMode: { itemsPerScreen: 40 } },
                        },
                        {
                            label: 'wallartMode.refreshRate=4',
                            json: { wallartMode: { refreshRate: 4 } },
                        },
                        {
                            label: 'wallartMode.ambientGradient',
                            json: { wallartMode: { ambientGradient: true } },
                        },
                    ],
                    cinema: [
                        {
                            label: 'cinema.header.style=neon',
                            json: { cinema: { header: { style: 'neon' } } },
                        },
                        {
                            label: 'cinema.footer.type=marquee',
                            json: { cinema: { footer: { type: 'marquee' } } },
                        },
                        {
                            label: 'cinema.footer.type=specs',
                            json: { cinema: { footer: { type: 'specs' } } },
                        },
                        {
                            label: 'cinema.ambilight.enabled',
                            json: { cinema: { ambilight: { enabled: true } } },
                        },
                        {
                            label: 'cinema.ambilight.strength=80',
                            json: { cinema: { ambilight: { strength: 80 } } },
                        },
                        {
                            label: 'cinema.header.text',
                            json: { cinema: { header: { text: 'Now Showing' } } },
                        },
                    ],
                };

                let mixedInfo = mode === '__mixed';
                function setSegmentActive(val) {
                    if (!seg) return;
                    seg.querySelectorAll('.seg-btn').forEach(btn => {
                        const m = btn.getAttribute('data-mode');
                        const active = m === val;
                        btn.setAttribute('aria-checked', active ? 'true' : 'false');
                        btn.classList.toggle('active', active);
                    });
                    // Reposition sliding indicator when a concrete mode is active
                    if (!mixedInfo) positionIndicator();
                }
                if (!mixedInfo) setSegmentActive(mode);
                if (mixedBadge) mixedBadge.hidden = !mixedInfo;

                function positionIndicator() {
                    try {
                        if (!seg) return;
                        const ind = seg.querySelector('.seg-indicator');
                        if (!ind) return;
                        if (mixedInfo) {
                            ind.style.width = '0px';
                            return;
                        }
                        const active = seg.querySelector('.seg-btn[aria-checked="true"]');
                        if (!active) {
                            ind.style.width = '0px';
                            return;
                        }
                        // Compute offset relative to segment container (which is position:relative)
                        const left = active.offsetLeft;
                        const width = active.offsetWidth;
                        ind.style.left = left + 'px';
                        ind.style.width = width + 'px';
                    } catch (e) {
                        /* noop */
                    }
                }

                // Wire interaction (once) for segmented control
                if (seg && !seg._wired) {
                    seg._wired = true;
                    seg.addEventListener('click', ev => {
                        const btn = ev.target?.closest?.('.seg-btn');
                        if (!btn || !seg.contains(btn)) return;
                        const val = btn.getAttribute('data-mode');
                        if (!val) return;
                        // Leaving mixed state if user selects a mode
                        if (mixedInfo) {
                            mixedInfo = false;
                            if (mixedBadge) mixedBadge.hidden = true;
                        }
                        setSegmentActive(val);
                        renderSnippets();
                    });
                    // Keyboard navigation (Left/Right / Arrow keys + Home/End)
                    seg.addEventListener('keydown', ev => {
                        const keys = ['ArrowLeft', 'ArrowRight', 'Home', 'End'];
                        if (!keys.includes(ev.key)) return;
                        const buttons = Array.from(seg.querySelectorAll('.seg-btn'));
                        if (!buttons.length) return;
                        const current = seg.querySelector('.seg-btn[aria-checked="true"]');
                        let idx = buttons.indexOf(current);
                        if (ev.key === 'ArrowLeft')
                            idx = (idx + buttons.length - 1) % buttons.length;
                        else if (ev.key === 'ArrowRight') idx = (idx + 1) % buttons.length;
                        else if (ev.key === 'Home') idx = 0;
                        else if (ev.key === 'End') idx = buttons.length - 1;
                        const target = buttons[idx];
                        if (target) {
                            ev.preventDefault();
                            if (mixedInfo) {
                                mixedInfo = false;
                                if (mixedBadge) mixedBadge.hidden = true;
                            }
                            const val = target.getAttribute('data-mode');
                            setSegmentActive(val);
                            renderSnippets();
                            target.focus();
                        }
                    });
                    // Recalculate on resize (debounced via rAF)
                    let resizeRaf = null;
                    window.addEventListener('resize', () => {
                        if (resizeRaf) cancelAnimationFrame(resizeRaf);
                        resizeRaf = requestAnimationFrame(positionIndicator);
                    });
                    // Initial positioning after first layout paint
                    requestAnimationFrame(positionIndicator);
                }

                function renderSnippets() {
                    if (!snippetsWrap) return;
                    const activeSeg = seg?.querySelector('.seg-btn[aria-checked="true"]');
                    const mode = mixedInfo
                        ? 'general'
                        : activeSeg
                          ? activeSeg.getAttribute('data-mode')
                          : 'general';
                    snippetsWrap.innerHTML = '';
                    (SNIPPET_SETS[mode] || []).forEach(sn => {
                        const b = document.createElement('button');
                        b.type = 'button';
                        b.className = 'ov-snippet';
                        b.textContent = sn.label;
                        b.dataset.overrideSnippet = JSON.stringify(sn.json);
                        b.addEventListener('click', () => applySnippet(JSON.stringify(sn.json)));
                        snippetsWrap.appendChild(b);
                    });
                }

                function applySnippet(str) {
                    if (!textarea) return;
                    textarea.dataset.userEdited = '1';
                    let frag;
                    try {
                        frag = JSON.parse(str);
                    } catch (_) {
                        return;
                    }
                    let baseObj = {};
                    try {
                        baseObj = JSON.parse(textarea.value || '{}');
                    } catch (_) {
                        baseObj = {};
                    }
                    const merged = (function deepMerge(t, s) {
                        if (s && typeof s === 'object' && !Array.isArray(s)) {
                            Object.entries(s).forEach(([k, v]) => {
                                if (v && typeof v === 'object' && !Array.isArray(v))
                                    t[k] = deepMerge(
                                        t[k] && typeof t[k] === 'object' ? t[k] : {},
                                        v
                                    );
                                else t[k] = v;
                            });
                            return t;
                        }
                        return s;
                    })(baseObj, frag);
                    textarea.value = JSON.stringify(merged, null, 2);
                    textarea.dispatchEvent(new Event('input'));
                }

                renderSnippets();
                if (mixedInfo && statusEl) {
                    statusEl.className = 'override-status neutral';
                    statusEl.innerHTML =
                        '<i class="fas fa-info-circle icon"></i>Multiple modes selected. Editing will apply a unified override to all.';
                }

                function buildConflicts() {
                    const devIds = Object.keys(originalPerDevice);
                    if (devIds.length <= 1) {
                        conflictData = { paths: [], map: {} };
                        return;
                    }
                    const map = {};
                    for (const id of devIds) {
                        const root = originalPerDevice[id] || {};
                        walk(root, '', (p, v) => {
                            if (!map[p]) map[p] = { values: new Set(), samples: [] };
                            const key = JSON.stringify(v);
                            map[p].values.add(key);
                            if (map[p].samples.length < 12)
                                map[p].samples.push({ device: id, value: v });
                        });
                    }
                    const paths = Object.keys(map).filter(p => map[p].values.size > 1);
                    conflictData = { paths, map };
                }
                function walk(obj, base, cb) {
                    if (obj && typeof obj === 'object') {
                        for (const k of Object.keys(obj)) {
                            const path = base ? base + '.' + k : k;
                            const val = obj[k];
                            if (val && typeof val === 'object' && !Array.isArray(val)) {
                                cb(path, val);
                                walk(val, path, cb);
                            } else cb(path, val);
                        }
                    }
                }
                function renderConflicts() {
                    if (!conflictWrap) return;
                    conflictList.innerHTML = '';
                    if (!conflictData.paths.length) {
                        if (conflictCountEl) conflictCountEl.textContent = '0';
                        conflictWrap.hidden = true;
                        return;
                    }
                    conflictWrap.hidden = false;
                    conflictCountEl.textContent = String(conflictData.paths.length);
                    const sorted = conflictData.paths.slice().sort();
                    conflictEmpty.hidden = true;
                    sorted.forEach(p => {
                        const info = conflictData.map[p];
                        const li = document.createElement('li');
                        li.className = 'conflict-item';
                        const pathEl = document.createElement('span');
                        pathEl.className = 'c-path';
                        pathEl.textContent = p;
                        li.appendChild(pathEl);
                        const valuesWrap = document.createElement('div');
                        valuesWrap.className = 'conflict-values';
                        const rendered = new Set();
                        info.samples.forEach(s => {
                            const k = JSON.stringify(s.value);
                            if (rendered.has(k)) return;
                            rendered.add(k);
                            const vBtn = document.createElement('div');
                            vBtn.className = 'conflict-value';

                            // Removed nested function - using top-level ensureLibrarySelectionIntegrity instead
                            vBtn.title =
                                'Device: ' +
                                s.device +
                                '\nClick to apply this value across all devices';
                            let label =
                                typeof s.value === 'object'
                                    ? JSON.stringify(s.value)
                                    : String(s.value);
                            if (label.length > 60) label = label.slice(0, 57) + '…';
                            vBtn.textContent = label;
                            vBtn.addEventListener('click', () =>
                                applyConflictValue(p, s.value, vBtn)
                            );
                            valuesWrap.appendChild(vBtn);
                        });
                        li.appendChild(valuesWrap);
                        conflictList.appendChild(li);
                    });
                }
                function setPath(obj, path, val) {
                    const parts = path.split('.');
                    let cur = obj;
                    for (let i = 0; i < parts.length - 1; i++) {
                        const k = parts[i];
                        if (!cur[k] || typeof cur[k] !== 'object') cur[k] = {};
                        cur = cur[k];
                    }
                    cur[parts[parts.length - 1]] = val;
                }
                function applyConflictValue(path, value, el) {
                    Object.keys(originalPerDevice).forEach(id => {
                        setPath(originalPerDevice[id], path, value);
                    });
                    // Rebuild canonical merged object from first device
                    const firstId = Object.keys(originalPerDevice)[0];
                    const canon = JSON.parse(JSON.stringify(originalPerDevice[firstId] || {}));
                    textarea.value = JSON.stringify(canon, null, 2);
                    el.classList.add('applied');
                    buildConflicts();
                    renderConflicts();
                    updateSnippetState();
                    if (statusEl) setStatus('success', 'Conflict value applied');
                }
                function currentModeValue() {
                    if (mixedInfo) return '__mixed';
                    const active = seg?.querySelector('.seg-btn[aria-checked="true"]');
                    return active ? active.getAttribute('data-mode') : 'general';
                }
                function updateSnippetState() {
                    const disabled =
                        currentModeValue() === '__mixed' || conflictData.paths.length > 0;
                    snippetsWrap?.querySelectorAll('.ov-snippet').forEach(b => {
                        b.disabled = disabled;
                        b.title = disabled
                            ? 'Disabled while mixed or conflicts unresolved'
                            : 'Insert snippet';
                    });
                }
                function selectSegment(newMode) {
                    if (mixedInfo) {
                        showConfirm(
                            'Unify Mixed Overrides',
                            'Switching mode will unify overrides across devices and discard conflicting keys that do not apply to the chosen mode. Continue?',
                            () => {
                                mixedInfo = false;
                                mixedBadge && (mixedBadge.hidden = true);
                                setSegmentActive(newMode);
                                cleanupForMode(newMode);
                                buildConflicts();
                                renderConflicts();
                                updateSnippetState();
                                setStatus('info', 'Mode switched to ' + formatModeWord(newMode));
                            }
                        );
                        return;
                    }
                    const cur = currentModeValue();
                    if (cur === newMode) return;
                    setSegmentActive(newMode);
                    cleanupForMode(newMode);
                    buildConflicts();
                    renderConflicts();
                    updateSnippetState();
                    setStatus('info', 'Mode switched to ' + formatModeWord(newMode));
                }
                seg?.addEventListener('click', e => {
                    const btn = e.target.closest('.seg-btn');
                    if (!btn) return;
                    selectSegment(btn.getAttribute('data-mode'));
                });
                seg?.addEventListener('keydown', e => {
                    if (!['ArrowLeft', 'ArrowRight', 'Home', 'End', ' ', 'Enter'].includes(e.key))
                        return;
                    const buttons = Array.from(seg.querySelectorAll('.seg-btn'));
                    let idx = buttons.findIndex(b => b.getAttribute('aria-checked') === 'true');
                    if (idx === -1) idx = 0;
                    let next = idx;
                    if (e.key === 'ArrowRight') next = (idx + 1) % buttons.length;
                    else if (e.key === 'ArrowLeft')
                        next = (idx - 1 + buttons.length) % buttons.length;
                    else if (e.key === 'Home') next = 0;
                    else if (e.key === 'End') next = buttons.length - 1;
                    if (next !== idx) {
                        e.preventDefault();
                        selectSegment(buttons[next].getAttribute('data-mode'));
                    } else if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        selectSegment(buttons[idx].getAttribute('data-mode'));
                    }
                });
                conflictsToggle?.addEventListener('click', () => {
                    if (conflictsBody) conflictsBody.hidden = !conflictsBody.hidden;
                });
                conflictsRescan?.addEventListener('click', () => {
                    buildConflicts();
                    renderConflicts();
                    updateSnippetState();
                });
                // Initial conflict build
                buildConflicts();
                renderConflicts();
                updateSnippetState();
                if (mixedBadge) mixedBadge.hidden = mode !== '__mixed';

                // Custom confirm modal helper
                function showConfirm(title, message, onOk) {
                    const overlay = document.getElementById('modal-confirm');
                    if (!overlay) {
                        if (confirm(message)) onOk?.();
                        return;
                    }
                    const msgEl = document.getElementById('confirm-message');
                    const titleEl = document.getElementById('confirm-title');
                    const okBtn = document.getElementById('confirm-ok');
                    const cancelBtn = document.getElementById('confirm-cancel');
                    if (titleEl)
                        titleEl.innerHTML =
                            '<i class="fas fa-circle-question"></i> ' +
                            escapeHtml(title || 'Confirm');
                    if (msgEl) msgEl.textContent = message;
                    overlay.hidden = false;
                    overlay.classList.add('open');
                    const cleanup = () => {
                        overlay.classList.remove('open');
                        overlay.hidden = true;
                        okBtn && okBtn.removeEventListener('click', okHandler);
                        cancelBtn && cancelBtn.removeEventListener('click', cancelHandler);
                    };
                    function okHandler() {
                        try {
                            onOk?.();
                        } finally {
                            cleanup();
                        }
                    }
                    function cancelHandler() {
                        cleanup();
                    }
                    okBtn?.addEventListener('click', okHandler, { once: true });
                    cancelBtn?.addEventListener('click', cancelHandler, { once: true });
                }
                // Multi-choice variant for dual-mode resolution
                function showChoice(options) {
                    // options: { title, message, choices:[{label,mode,primary}], onSelect(mode), onCancel }
                    const overlay = document.getElementById('modal-confirm');
                    if (!overlay) {
                        // Fallback to simple confirm sequence
                        const picked = confirm(
                            options.message + '\nKeep Wall Art? (Cancel = Cinema)'
                        );
                        options.onSelect?.(picked ? 'wallart' : 'cinema');
                        return;
                    }
                    const msgEl = document.getElementById('confirm-message');
                    const titleEl = document.getElementById('confirm-title');
                    const okBtn = document.getElementById('confirm-ok');
                    const cancelBtn = document.getElementById('confirm-cancel');
                    if (titleEl)
                        titleEl.innerHTML =
                            '<i class="fas fa-circle-question"></i> ' +
                            escapeHtml(options.title || 'Choose');
                    if (msgEl) msgEl.textContent = options.message;
                    // Repurpose existing two buttons: make OK = first choice, Cancel = second choice (or cancel)
                    const wallartChoice =
                        options.choices?.find(c => c.mode === 'wallart') || options.choices?.[0];
                    const cinemaChoice =
                        options.choices?.find(c => c.mode === 'cinema') || options.choices?.[1];
                    if (okBtn && wallartChoice) okBtn.textContent = wallartChoice.label;
                    if (cancelBtn && cinemaChoice) cancelBtn.textContent = cinemaChoice.label;
                    overlay.hidden = false;
                    overlay.classList.add('open');
                    function cleanup() {
                        overlay.classList.remove('open');
                        overlay.hidden = true;
                        if (okBtn) okBtn.textContent = 'OK';
                        if (cancelBtn) cancelBtn.textContent = 'Cancel';
                        okBtn && okBtn.removeEventListener('click', okHandler);
                        cancelBtn && cancelBtn.removeEventListener('click', cancelHandler);
                    }
                    function okHandler() {
                        try {
                            options.onSelect?.(wallartChoice.mode);
                        } finally {
                            cleanup();
                        }
                    }
                    function cancelHandler() {
                        try {
                            options.onSelect?.(cinemaChoice.mode);
                        } finally {
                            cleanup();
                        }
                    }
                    okBtn?.addEventListener('click', okHandler, { once: true });
                    cancelBtn?.addEventListener('click', cancelHandler, { once: true });
                }
                function formatModeWord(modeVal) {
                    const label = modeVal === 'general' ? 'screensaver' : modeVal;
                    const cls =
                        modeVal === 'wallart'
                            ? 'pill-wallart'
                            : modeVal === 'cinema'
                              ? 'pill-cinema'
                              : 'pill-screensaver';
                    return '<span class="mode-pill ' + cls + '">' + escapeHtml(label) + '</span>';
                }

                function cleanupForMode(curMode) {
                    if (!textarea) return;
                    // Parse existing JSON; treat invalid/empty as empty object instead of aborting
                    let obj;
                    try {
                        const raw = (textarea.value || '').trim();
                        obj = raw ? JSON.parse(raw) : {};
                    } catch {
                        obj = {}; // fallback
                    }
                    if (curMode === '__mixed') return; // never mutate while mixed
                    const keep = {};
                    const genericKeys = [
                        'syncEnabled',
                        'transitionIntervalSeconds',
                        'transitionEffect',
                        'effectPauseTime',
                        'uiScaling',
                        'clockFormat',
                    ];
                    genericKeys.forEach(k => {
                        if (obj && typeof obj === 'object' && k in obj) keep[k] = obj[k];
                    });
                    if (curMode === 'wallart') {
                        // Activate wallart; preserve previous wallart settings
                        if (obj.wallartMode && typeof obj.wallartMode === 'object') {
                            keep.wallartMode = { ...obj.wallartMode };
                        } else if (obj.wallart && typeof obj.wallart === 'object') {
                            keep.wallartMode = { ...obj.wallart };
                        } else {
                            keep.wallartMode = {};
                        }
                        keep.wallartMode.enabled = true;
                        // Preserve cinema config (inactive) if present
                        if (obj.cinema && typeof obj.cinema === 'object') {
                            keep.cinema = { ...obj.cinema };
                        }
                        keep.cinemaMode = false;
                    } else if (curMode === 'cinema') {
                        // Activate cinema; retain full wallart config but disable it
                        keep.cinemaMode = true;
                        keep.cinema =
                            obj.cinema && typeof obj.cinema === 'object'
                                ? { ...obj.cinema }
                                : { header: { text: 'Now Showing' } };
                        if (obj.wallartMode && typeof obj.wallartMode === 'object') {
                            keep.wallartMode = { ...obj.wallartMode, enabled: false };
                        } else if (obj.wallart && typeof obj.wallart === 'object') {
                            keep.wallartMode = { ...obj.wallart, enabled: false };
                        } else {
                            keep.wallartMode = { enabled: false };
                        }
                    } else {
                        // Screensaver/general: preserve both configs but mark them inactive
                        if (obj.wallartMode && typeof obj.wallartMode === 'object') {
                            keep.wallartMode = { ...obj.wallartMode, enabled: false };
                        } else if (obj.wallart && typeof obj.wallart === 'object') {
                            keep.wallartMode = { ...obj.wallart, enabled: false };
                        } else {
                            keep.wallartMode = { enabled: false };
                        }
                        if (obj.cinema && typeof obj.cinema === 'object') {
                            keep.cinema = { ...obj.cinema }; // retained for later use
                        }
                        keep.cinemaMode = false;
                    }
                    textarea.value = JSON.stringify(keep, null, 2);
                    // Immediately re-parse to update status/apply button state
                    tryParse();
                }
                cleanBtn?.addEventListener('click', () => {
                    const cur = currentModeValue();
                    cleanupForMode(cur === '__mixed' ? 'general' : cur);
                });

                function setStatus(state, msg) {
                    if (!statusEl) return;
                    statusEl.className = 'override-status ' + state;
                    let icon = '';
                    if (state === 'success') icon = '<i class="fas fa-check icon"></i>';
                    else if (state === 'error')
                        icon = '<i class="fas fa-exclamation-triangle icon"></i>';
                    else icon = '<i class="fas fa-info-circle icon"></i>';
                    statusEl.innerHTML = icon + msg;
                }
                function tryParse() {
                    if (!textarea) return null;
                    const raw = textarea.value.trim();
                    if (!raw) {
                        setStatus('neutral', 'Empty – will clear overrides');
                        applyBtn && (applyBtn.disabled = false);
                        textarea.classList.remove('invalid', 'valid');
                        return {};
                    }
                    try {
                        const obj = JSON.parse(raw);
                        setStatus(
                            'success',
                            'Valid JSON (' +
                                Object.keys(obj).length +
                                ' root key' +
                                (Object.keys(obj).length === 1 ? '' : 's') +
                                ')'
                        );
                        textarea.classList.add('valid');
                        textarea.classList.remove('invalid');
                        if (applyBtn) applyBtn.disabled = false;
                        maybePromptDualMode(obj);
                        return obj;
                    } catch (e) {
                        setStatus('error', e.message.split('\n')[0]);
                        textarea.classList.add('invalid');
                        textarea.classList.remove('valid');
                        if (applyBtn) applyBtn.disabled = true;
                        return null;
                    }
                }
                let dualModePromptShown = false;
                function maybePromptDualMode(obj) {
                    if (dualModePromptShown) return;
                    if (!obj || typeof obj !== 'object') return;
                    // Detect wallart enabled
                    const wallartOn = !!(
                        obj.wallartMode?.enabled ||
                        obj.wallart?.enabled ||
                        (obj.wallartMode &&
                            obj.wallartMode.enabled !== false &&
                            obj.wallartMode.enabled !== 0)
                    );
                    // Detect cinema enabled (explicit true). A cinema object alone does not force activation unless cinemaMode true.
                    const cinemaOn = obj.cinemaMode === true;
                    if (wallartOn && cinemaOn) {
                        dualModePromptShown = true;
                        showChoice({
                            title: 'Choose a Mode',
                            message:
                                "Both Wall Art and Cinema are enabled. Select which mode to keep; the other mode's keys will be removed.",
                            choices: [
                                { label: 'Keep Wall Art', mode: 'wallart' },
                                { label: 'Keep Cinema', mode: 'cinema' },
                            ],
                            onSelect: modeChosen => {
                                cleanupForMode(modeChosen);
                                buildConflicts();
                                renderConflicts();
                                updateSnippetState();
                                setSegmentActive(modeChosen);
                                setStatus(
                                    'info',
                                    'Resolved dual mode – kept ' + formatModeWord(modeChosen)
                                );
                            },
                        });
                    }
                }
                // Initial validation
                tryParse();
                if (textarea && !textarea._bound) {
                    textarea.addEventListener('input', () => {
                        textarea.dataset.userEdited = '1';
                        tryParse();
                    });
                    textarea._bound = true;
                }
                if (formatBtn && !formatBtn._bound) {
                    formatBtn.addEventListener('click', () => {
                        const obj = tryParse();
                        if (obj) {
                            textarea.value = JSON.stringify(obj, null, 2);
                            tryParse();
                        }
                    });
                    formatBtn._bound = true;
                }
                if (clearBtn && !clearBtn._bound) {
                    clearBtn.addEventListener('click', () => {
                        textarea.value = '';
                        tryParse();
                    });
                    clearBtn._bound = true;
                }
                if (snippetsWrap && !snippetsWrap._bound) {
                    snippetsWrap.addEventListener('click', e => {
                        const btn = e.target.closest('.ov-snippet');
                        if (!btn) return;
                        const data = btn.getAttribute('data-override-snippet');
                        if (!data) return;
                        let frag;
                        try {
                            frag = JSON.parse(data);
                        } catch (_) {
                            return;
                        }
                        const base = tryParse() || {};
                        function deepMerge(t, s) {
                            Object.keys(s).forEach(k => {
                                if (s[k] && typeof s[k] === 'object' && !Array.isArray(s[k])) {
                                    if (!t[k] || typeof t[k] !== 'object') t[k] = {};
                                    deepMerge(t[k], s[k]);
                                } else {
                                    t[k] = s[k];
                                }
                            });
                            return t;
                        }
                        const merged = deepMerge(JSON.parse(JSON.stringify(base)), frag);
                        textarea.value = JSON.stringify(merged, null, 2);
                        tryParse();
                    });
                    snippetsWrap._bound = true;
                }
                if (applyBtn) {
                    const newBtn = applyBtn.cloneNode(true);
                    applyBtn.parentNode.replaceChild(newBtn, applyBtn);
                    newBtn.addEventListener('click', async () => {
                        const parsed = tryParse();
                        if (parsed === null) {
                            window.notify?.toast?.({
                                type: 'error',
                                title: 'Invalid JSON',
                                message: 'Please fix errors before applying.',
                            });
                            return;
                        }
                        const payload = parsed || {};
                        let ok = 0,
                            fail = 0;
                        for (const id of ids) {
                            try {
                                await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                                    method: 'PATCH',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ settingsOverride: payload }),
                                });
                                ok++;
                            } catch (_) {
                                fail++;
                            }
                        }
                        // Removed deprecated 'Override Debug' informational toast.
                        document.getElementById('modal-override')?.classList.remove('open');
                        // After applying overrides, refresh the config so mode pill reflects changes promptly
                        try {
                            const r = await fetch('/api/admin/config', { cache: 'no-cache' });
                            if (r.ok) {
                                const cfg = await r.json();
                                if (cfg && (cfg.config || cfg)) {
                                    hydrateDisplayForm(cfg.config || cfg);
                                }
                            } else {
                                if (__debugOn)
                                    console.debug(
                                        '[Admin] Failed to refresh config after overrides'
                                    );
                            }
                        } catch (e) {
                            if (__debugOn)
                                console.debug('[Admin] Refresh error after overrides', e);
                        }
                        if (ok)
                            window.notify?.toast({
                                type: 'success',
                                title: 'Overrides applied',
                                message: `${ok}/${ids.length} updated`,
                            });
                        if (fail)
                            window.notify?.toast({
                                type: 'error',
                                title: 'Some failed',
                                message: `${fail} failed`,
                            });
                        await loadDevices();
                    });
                }
            }
            async function openSendCmdFor(ids) {
                if (!Array.isArray(ids) || !ids.length) return;
                const overlay = document.getElementById('modal-sendcmd');
                if (overlay) {
                    __showOverlay(overlay, 'modal-sendcmd');
                    try {
                        const r = overlay.getBoundingClientRect();
                        if (window.__uiDebug)
                            console.info('[ModalDebug] openSendCmdFor rect', r.toJSON());
                        if (
                            (r.width === 0 || r.height === 0) &&
                            overlay.parentElement !== document.body
                        ) {
                            console.warn('[ModalDebug] sendcmd zero-rect; force portal move');
                            document.body.appendChild(overlay);
                            overlay.setAttribute('data-portal', 'true');
                            requestAnimationFrame(() => {
                                const r2 = overlay.getBoundingClientRect();
                                if (window.__uiDebug)
                                    console.info(
                                        '[ModalDebug] sendcmd rect after portal',
                                        r2.toJSON()
                                    );
                                if (r2.width === 0 || r2.height === 0) {
                                    overlay.style.width = '100vw';
                                    overlay.style.height = '100vh';
                                }
                            });
                        }
                    } catch (_) {
                        /* clear pairing poll timer failed (timer likely not set) */
                    }
                }
                const typeEl = document.getElementById('sendcmd-type');
                const payloadEl = document.getElementById('sendcmd-payload');
                const selectEl = document.getElementById('sendcmd-select');
                const srcWrap = document.getElementById('sendcmd-param-source');
                const srcEl = document.getElementById('sendcmd-source');
                const applyBtn = document.getElementById('btn-sendcmd-apply');
                if (selectEl) {
                    const newSel = selectEl.cloneNode(true);
                    selectEl.parentNode.replaceChild(newSel, selectEl);
                    newSel.addEventListener('change', () => {
                        const v = newSel.value;
                        if (!v) return;
                        if (v === '__custom') {
                            typeEl.value = '';
                            if (payloadEl) payloadEl.value = '';
                            if (srcWrap) srcWrap.style.display = 'none';
                            return;
                        }
                        typeEl.value = v;
                        // Always refresh payload textarea to match command selection
                        if (payloadEl) {
                            let tpl = '';
                            switch (v) {
                                case 'remote.key':
                                    tpl = '{\n  "key": "up"\n}';
                                    break;
                                case 'source.switch':
                                    tpl = '{\n  "source": "' + (srcEl?.value || 'plex') + '"\n}';
                                    break;
                                case 'playback.pinPoster':
                                    tpl = '{\n  "id": "<posterId>"\n}';
                                    break;
                                default:
                                    tpl = '';
                            }
                            payloadEl.value = tpl;
                        }
                        if (srcWrap) srcWrap.style.display = v === 'source.switch' ? '' : 'none';
                    });
                }
                if (srcEl) {
                    const newSrc = srcEl.cloneNode(true);
                    srcEl.parentNode.replaceChild(newSrc, srcEl);
                    newSrc.addEventListener('change', () => {
                        // If source.switch is selected, keep payload in sync
                        const v = document.getElementById('sendcmd-select')?.value;
                        if (v === 'source.switch' && payloadEl) {
                            payloadEl.value =
                                '{\n  "source": "' + (newSrc.value || 'plex') + '"\n}';
                        }
                    });
                }
                if (applyBtn) {
                    const newBtn = applyBtn.cloneNode(true);
                    applyBtn.parentNode.replaceChild(newBtn, applyBtn);
                    newBtn.addEventListener('click', async () => {
                        const type = String(typeEl?.value || '').trim();
                        if (!type) {
                            window.notify?.toast({
                                type: 'info',
                                title: 'Type required',
                                message: 'Enter a command type',
                            });
                            return;
                        }
                        let payload = undefined;
                        if (payloadEl && payloadEl.value.trim()) {
                            try {
                                payload = JSON.parse(payloadEl.value);
                            } catch (e) {
                                window.notify?.toast({
                                    type: 'error',
                                    title: 'Invalid JSON',
                                    message: e.message,
                                });
                                return;
                            }
                        }
                        let ok = 0,
                            fail = 0;
                        for (const id of ids) {
                            try {
                                await sendCommand(id, type, payload);
                                ok++;
                            } catch (_) {
                                fail++;
                            }
                        }
                        document.getElementById('modal-sendcmd')?.classList.remove('open');
                        if (ok)
                            window.notify?.toast({
                                type: 'success',
                                title: 'Commands sent',
                                message: `${ok}/${ids.length} sent`,
                            });
                        if (fail)
                            window.notify?.toast({
                                type: 'error',
                                title: 'Some failed',
                                message: `${fail} failed`,
                            });
                    });
                }
            }
            mergeConfirm?.addEventListener('click', submitMerge);

            function applyFilters() {
                const q = state.query;
                const fs = state.filterStatus;
                const fr = state.filterRoom;
                const matches = d => {
                    const name = String(d.name || '').toLowerCase();
                    const meta = String(versionMeta(d) || '').toLowerCase();
                    const matchesText = !q || name.includes(q) || meta.includes(q);
                    const status = getStatusClass(d);
                    // Use the same slugification as the filter menu to ensure consistent matching
                    const room = slugify(roomLabel(d));
                    // Support a pseudo-status 'active' that matches either 'live' or 'online'
                    let matchesStatus = true;
                    if (fs) {
                        if (fs === 'active')
                            matchesStatus = status === 'live' || status === 'online';
                        else matchesStatus = status === fs;
                    }
                    const matchesRoom = !fr || room === fr;
                    return matchesText && matchesStatus && matchesRoom;
                };
                state.filteredIds = state.all.filter(matches).map(d => d.id);
                // Failsafe: if no filters are active but nothing matched, show all
                if (!q && !fs && !fr && state.filteredIds.length === 0) {
                    state.filteredIds = state.all.map(d => d.id);
                }
            }
            function renderPage() {
                applyFilters();
                // prepare duplicate maps for current filtered set
                computeDupMaps();
                const total = state.filteredIds.length;
                const perPage = Math.max(1, state.perPage | 0);
                const maxPage = Math.max(1, Math.ceil(total / perPage));
                if (state.currentPage > maxPage) state.currentPage = maxPage;
                const start = (state.currentPage - 1) * perPage;
                const end = start + perPage;
                grid.innerHTML = '';
                if (total === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'empty-state';
                    empty.style.padding = '20px';
                    empty.style.color = 'var(--color-text-muted)';
                    empty.innerHTML =
                        '<i class="fas fa-circle-info"></i> No devices to show. Try clearing filters or check if any devices have registered.';
                    grid.appendChild(empty);
                }
                const pageIds = state.filteredIds.slice(start, end);
                for (const id of pageIds) {
                    const dev = state.all.find(x => x.id === id);
                    const wrapper = document.createElement('div');
                    wrapper.innerHTML = renderCard(dev);
                    const card = wrapper.firstElementChild;
                    grid.appendChild(card);
                    bindCardEvents(card);
                }
                const showing = Math.min(perPage, Math.max(0, total - start));
                if (pageInfo) pageInfo.textContent = `Showing ${showing} of ${total} devices`;
                if (pagePrev) pagePrev.disabled = state.currentPage <= 1;
                if (pageNext) pageNext.disabled = state.currentPage >= maxPage;
                if (pageNumbers) {
                    pageNumbers.innerHTML = '';
                    const maxButtons = 7;
                    let startPage = Math.max(1, state.currentPage - 3);
                    const endPage = Math.min(maxPage, startPage + maxButtons - 1);
                    startPage = Math.max(1, Math.min(startPage, endPage - maxButtons + 1));
                    for (let p = startPage; p <= endPage; p++) {
                        const btn = document.createElement('button');
                        btn.className = 'btn btn-sm' + (p === state.currentPage ? ' active' : '');
                        btn.textContent = String(p);
                        btn.addEventListener('click', () => {
                            state.currentPage = p;
                            renderPage();
                        });
                        pageNumbers.appendChild(btn);
                    }
                }
                updateBulkUI();
                // Re-evaluate per-card action overflow after rendering
                requestAnimationFrame(() => {
                    document
                        .querySelectorAll('#device-grid .device-card')
                        .forEach(collapseCardActions);
                });

                // Re-bind hover listeners for newly rendered pills
                try {
                    bindHover('.js-status-hover', statusCard);
                    bindHover('.js-dupes-hover', dupesCard);
                    // Also bind media hover for now-playing thumbnails on freshly rendered cards
                    bindHover('.js-media-hover', mediaCard);
                } catch (_) {
                    /* initMinLevelControl setup failed (defaults still apply) */
                }
            }

            // Reflow handlers for responsive action overflow
            const reflowActions = (function () {
                const fn = () => {
                    try {
                        updateBulkUI();
                        document
                            .querySelectorAll('#device-grid .device-card')
                            .forEach(collapseCardActions);
                    } catch (_) {
                        /* modal merge rect debug failed (diagnostic only) */
                    }
                };
                return debounce(fn, 150);
            })();
            window.addEventListener('resize', reflowActions, { passive: true });
            // Run once on first paint to set initial overflow state
            requestAnimationFrame(reflowActions);

            // Build toolbar menus dynamically
            function buildActionsMenu() {
                const menu = document.getElementById('device-actions-menu');
                if (!menu) return;
                dbg('buildActionsMenu()');
                menu.innerHTML = `
                    <div class="dropdown-item" data-device-action="create-device"><i class="fas fa-plus"></i> New device…</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" data-device-action="merge"><i class="fas fa-object-group"></i> Merge selected</div>
                    <div class="dropdown-item" data-device-action="groups"><i class="fas fa-layer-group"></i> Groups…</div>
                    <div class="dropdown-item" data-device-action="presets"><i class="fas fa-star"></i> Presets…</div>
                    <div class="dropdown-item" data-device-action="location"><i class="fas fa-location-dot"></i> Assign location</div>
                    <div class="dropdown-heading">Selection</div>
                    <div class="dropdown-item" data-device-action="select-all"><i class="fas fa-check-double"></i> Select all</div>
                    <div class="dropdown-item" data-device-action="clear-selection"><i class="fas fa-eraser"></i> Clear selection</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" data-device-action="delete"><i class="fas fa-trash"></i> Delete selected</div>`;
            }

            function buildFilterMenu() {
                const menu = document.getElementById('device-filter-menu');
                if (!menu) return;
                dbg('buildFilterMenu()');
                const roomsSet = new Set();
                let hasUnassigned = false;
                (state.all || []).forEach(d => {
                    const loc = (d && d.location != null ? String(d.location) : '').trim();
                    if (!loc) hasUnassigned = true;
                    else roomsSet.add(loc);
                });
                const rooms = Array.from(roomsSet).sort((a, b) => a.localeCompare(b));
                const parts = [];
                parts.push('<div class="dropdown-heading">Status</div>');
                parts.push(
                    '<div class="dropdown-item" data-device-filter="status:live"><i class="fas fa-bolt"></i> Live</div>'
                );
                parts.push(
                    '<div class="dropdown-item" data-device-filter="status:online"><i class="fas fa-signal"></i> Online</div>'
                );
                parts.push(
                    '<div class="dropdown-item" data-device-filter="status:offline"><i class="fas fa-plug-circle-xmark"></i> Offline</div>'
                );
                parts.push(
                    '<div class="dropdown-item" data-device-filter="status:unknown"><i class="fas fa-question-circle"></i> Unknown</div>'
                );
                parts.push('<div class="dropdown-heading">Location</div>');
                rooms.forEach(r => {
                    const slug = slugify(r);
                    parts.push(
                        `<div class="dropdown-item" data-device-filter="location:${slug}"><i class="fas fa-location-dot"></i> ${r.replace(/</g, '&lt;')}</div>`
                    );
                });
                if (hasUnassigned) {
                    parts.push(
                        '<div class="dropdown-item" data-device-filter="location:unassigned"><i class="fas fa-circle-dot"></i> Unassigned</div>'
                    );
                }
                // Quick reset to recover from empty result states
                parts.push('<div class="dropdown-divider"></div>');
                parts.push(
                    '<div class="dropdown-item" data-device-filter="clear"><i class="fas fa-filter-circle-xmark"></i> Clear filters</div>'
                );
                menu.innerHTML = parts.join('');
                wireFilterMenuHandlers();
                updateFilterMenuUI();
            }

            // Assign Location modal logic
            const locationInput = document.getElementById('location-input');
            const locationList = document.getElementById('location-list');
            const btnLocationApply = document.getElementById('btn-location-apply');
            const btnLocationClear = document.getElementById('btn-location-clear');
            function openAssignLocationModal() {
                const overlay = document.getElementById('modal-assign-location');
                if (!overlay) return;
                // Prefill if all selected share the same location
                const selected = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                );
                const locs = new Set(
                    selected.map(
                        c =>
                            (state.all || []).find(d => d.id === c.getAttribute('data-id'))
                                ?.location || ''
                    )
                );
                if (locationInput) locationInput.value = locs.size === 1 ? Array.from(locs)[0] : '';
                // Populate datalist with existing unique locations across all devices
                try {
                    if (locationList) {
                        const roomsSet = new Set();
                        (state.all || []).forEach(d => {
                            const loc = (d && d.location != null ? String(d.location) : '').trim();
                            if (loc) roomsSet.add(loc);
                        });
                        const rooms = Array.from(roomsSet).sort((a, b) => a.localeCompare(b));
                        locationList.innerHTML = rooms
                            .map(r => `<option value="${escapeHtml(r)}"></option>`)
                            .join('');
                    }
                } catch (_) {
                    /* location datalist build failed (non-fatal; user may type any value) */
                }
                __showOverlay(overlay, 'modal-assign-location');
                try {
                    if (window.__uiDebug)
                        console.info(
                            '[ModalDebug] assign-location rect',
                            overlay.getBoundingClientRect().toJSON()
                        );
                } catch (_) {
                    /* assign-location modal debug rect read failed (overlay still opens) */
                }
                setTimeout(() => locationInput?.focus(), 50);
            }
            btnLocationApply?.addEventListener('click', async () => {
                const val = (locationInput?.value || '').trim();
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                if (!ids.length) {
                    window.notify?.toast({ type: 'warning', title: 'No devices selected' });
                    return;
                }
                let ok = 0;
                for (const id of ids) {
                    try {
                        await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ location: val }),
                        });
                        ok++;
                    } catch (_) {
                        /* ignore */
                    }
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Location updated',
                    message: `${ok}/${ids.length} device${ids.length !== 1 ? 's' : ''}`,
                });
                document.getElementById('modal-assign-location')?.classList.remove('open');
                await loadDevices();
            });
            btnLocationClear?.addEventListener('click', async () => {
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                if (!ids.length) {
                    window.notify?.toast({ type: 'warning', title: 'No devices selected' });
                    return;
                }
                let ok = 0;
                for (const id of ids) {
                    try {
                        await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ location: '' }),
                        });
                        ok++;
                    } catch (_) {
                        /* ignore */
                    }
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Location cleared',
                    message: `${ok}/${ids.length} device${ids.length !== 1 ? 's' : ''}`,
                });
                document.getElementById('modal-assign-location')?.classList.remove('open');
                await loadDevices();
            });
            locationInput?.addEventListener('keydown', e => {
                if (e.key === 'Enter') btnLocationApply?.click();
            });

            async function loadPresets() {
                try {
                    const list = await fetchJSON('/api/admin/device-presets').catch(() => []);
                    state.presets = Array.isArray(list) ? list : [];
                } catch (_) {
                    state.presets = [];
                }
                // presets dropdown removed; presets available via modal
            }

            async function loadDevices() {
                try {
                    const list = await fetchJSON('/api/devices');
                    state.all = Array.isArray(list) ? list : [];
                    dbg('loadDevices(): count', state.all.length);
                    state.currentPage = 1;
                    buildFilterMenu();
                    populateMergeOptions();
                    renderPage();
                } catch (e) {
                    dbg('loadDevices(): failed', e?.message || e);
                    // Show empty state but don't crash section
                    state.all = [];
                    buildFilterMenu();
                    renderPage();
                }
            }
            async function loadGroupsForCards() {
                try {
                    const list = await fetchJSON('/api/groups');
                    state.groups = Array.isArray(list) ? list : [];
                } catch (_) {
                    state.groups = [];
                }
            }
            // Dropdown toggles within device toolbar and cards
            document.querySelectorAll('#section-devices .dropdown-toggle').forEach(btn => {
                btn.addEventListener('click', e => {
                    e.stopPropagation();
                    const dd = btn.closest('.dropdown');
                    const willOpen = !dd.classList.contains('open');
                    dbg('dropdown toggle click', { id: btn.id, willOpen });
                    document.querySelectorAll('#section-devices .dropdown').forEach(x => {
                        if (x !== dd) x.classList.remove('open');
                    });
                    dd.classList.toggle('open', willOpen);
                    // Reflect state for a11y
                    try {
                        btn.setAttribute('aria-expanded', String(!!willOpen));
                    } catch (_) {
                        /* pairing overlay rect debug/portal move failed (visual fallback) */
                    }
                });
            });
            document.addEventListener('click', () => {
                document
                    .querySelectorAll('#section-devices .dropdown')
                    .forEach(x => x.classList.remove('open'));
                // Reset aria-expanded on all toggles
                document
                    .querySelectorAll('#section-devices .dropdown-toggle[aria-expanded="true"]')
                    .forEach(b => b.setAttribute('aria-expanded', 'false'));
            });

            deviceSearch?.addEventListener('input', () => {
                state.query = (deviceSearch.value || '').toLowerCase();
                state.currentPage = 1;
                renderPage();
            });
            // per-page selector removed; always 9 per page
            pagePrev?.addEventListener('click', () => {
                if (state.currentPage > 1) {
                    state.currentPage--;
                    renderPage();
                }
            });
            pageNext?.addEventListener('click', () => {
                const total = state.filteredIds.length;
                const maxPage = Math.max(1, Math.ceil(total / Math.max(1, state.perPage | 0)));
                if (state.currentPage < maxPage) {
                    state.currentPage++;
                    renderPage();
                }
            });
            // Load groups first (for name mapping), then devices
            loadGroupsForCards().finally(loadDevices);

            // Hovercards (status, dupes)
            function createHovercard(id, html) {
                let el = document.getElementById(id);
                if (!el) {
                    el = document.createElement('div');
                    el.className = 'hovercard';
                    el.id = id;
                    el.innerHTML = html;
                    document.body.appendChild(el);
                }
                return el;
            }
            // Helpers for hovercards
            function fmtAgo(ms) {
                if (!ms || Number.isNaN(ms)) return '—';
                const now = Date.now();
                const diff = Math.max(0, now - ms);
                const sec = Math.floor(diff / 1000);
                if (sec < 5) return 'just now';
                if (sec < 60) return `${sec}s ago`;
                const min = Math.floor(sec / 60);
                if (min < 60) return `${min}m ago`;
                const hr = Math.floor(min / 60);
                if (hr < 24) return `${hr}h ago`;
                const day = Math.floor(hr / 24);
                return `${day}d ago`;
            }
            function statusPretty(s) {
                const t = String(s || '').toLowerCase();
                if (t === 'live') return 'Live';
                if (t === 'online') return 'Online';
                if (t === 'unknown') return 'Unknown';
                return 'Offline';
            }
            function statusDotClass(s) {
                const t = String(s || '').toLowerCase();
                if (t === 'live') return 'sd-live';
                if (t === 'online') return 'sd-online';
                if (t === 'unknown') return 'sd-unknown';
                return 'sd-offline';
            }
            const statusHoverHTML =
                '\n                <div class="hc-title"><span class="status-dot sd-online"></span><span>Status</span></div>\n                <div class="hc-list">\n                    <div class="hc-row"><i class="fas fa-plug"></i><span>WebSocket</span><span class="mono value dim">—</span></div>\n                    <div class="hc-row"><i class="fas fa-clock"></i><span>Last seen</span><span class="mono value dim">—</span></div>\n                    <div class="hc-row"><i class="fas fa-hashtag"></i><span>Device ID</span><span class="mono value dim">—</span></div>\n                    <div class="hc-row"><i class="fas fa-expand"></i><span>Resolution</span><span class="mono value dim">—</span></div>\n                    <div class="hc-row"><i class="fas fa-sliders"></i><span>Mode</span><span class="mono value dim">—</span></div>\n                    <div class="hc-row hc-ua"><i class="fas fa-globe"></i><span>User agent</span><span class="mono value dim">—</span></div>\n                </div>';
            const dupesHoverHTML =
                '\n                <div class="hc-title">Duplicates found</div>\n                <div class="hc-list"><div class="hc-row"><span>No details</span></div></div>';
            const statusCard = createHovercard('hc-status', statusHoverHTML);
            const dupesCard = createHovercard('hc-dupes', dupesHoverHTML);
            const mediaHoverHTML = `
                <div class="hc-title"><i class="fas fa-film"></i><span>Media</span></div>
                <div class="hc-list">
                    <div class="hc-row"><i class="fas fa-heading"></i><span>Title</span><span class="mono value dim">—</span></div>
                    <div class="hc-row"><i class="fas fa-calendar"></i><span>Year</span><span class="mono value dim">—</span></div>
                    <div class="hc-row"><i class="fas fa-star"></i><span>Rating</span><span class="mono value dim">—</span></div>
                    <div class="hc-row"><i class="fas fa-clock"></i><span>Runtime</span><span class="mono value dim">—</span></div>
                    <div class="hc-row"><i class="fas fa-shapes"></i><span>Genres</span><span class="mono value dim">—</span></div>
                    <div class="hc-row"><i class="fas fa-shield-alt"></i><span>Content Rating</span><span class="mono value dim">—</span></div>
                    <div class="hc-row"><i class="fas fa-quote-left"></i><span>Tagline</span><span class="mono value dim">—</span></div>
                </div>`;
            const mediaCard = createHovercard('hc-media', mediaHoverHTML);
            function positionHover(el, trigger) {
                const r = trigger.getBoundingClientRect();
                const margin = 8;
                const top = window.scrollY + r.top + r.height + margin;
                const left = Math.min(
                    window.scrollX + r.left,
                    window.scrollX + window.innerWidth - el.offsetWidth - margin
                );
                el.style.top = top + 'px';
                el.style.left = left + 'px';
            }
            function bindHover(selector, card) {
                document.querySelectorAll(selector).forEach(tr => {
                    let hideTimer;
                    const clearHide = () => {
                        if (hideTimer) {
                            clearTimeout(hideTimer);
                            hideTimer = null;
                        }
                    };
                    const show = () => {
                        clearHide();
                        // If status or media hovercard, rebuild from the device referenced by trigger
                        try {
                            if (card && (card.id === 'hc-status' || card.id === 'hc-media')) {
                                const cardEl = tr.closest('.device-card');
                                const id = cardEl?.getAttribute('data-id');
                                const d = (state.all || []).find(x => x.id === id);
                                if (d) {
                                    if (card.id === 'hc-status') {
                                        const status = getStatusClass(d);
                                        const ws = d.wsConnected ? 'Connected' : 'Not connected';
                                        const lastTs = Date.parse(d.lastSeenAt || 0) || 0;
                                        const last = lastTs
                                            ? `${fmtAgo(lastTs)}\u00A0·\u00A0${new Date(lastTs).toLocaleString()}`
                                            : '—';
                                        const sc = d?.clientInfo?.screen || {};
                                        const w = Number(sc.w || sc.width || 0) || 0;
                                        const h = Number(sc.h || sc.height || 0) || 0;
                                        const dpr = Number(sc.dpr || sc.scale || 1) || 1;
                                        const res =
                                            w && h
                                                ? `${w}×${h}${dpr && dpr !== 1 ? ` @${dpr}x` : ''}`
                                                : '—';
                                        const mode = d?.clientInfo?.mode || d?.mode || '';
                                        const ua = (
                                            d?.clientInfo?.userAgent ||
                                            d?.clientInfo?.ua ||
                                            ''
                                        ).trim();
                                        const isPO = d?.currentState?.poweredOff === true;
                                        const dotCls =
                                            isPO && status === 'live'
                                                ? 'sd-poweredoff'
                                                : statusDotClass(status);
                                        const titleHTML = `<div class="hc-title"><span class="status-dot ${dotCls}"></span><span>${escapeHtml(isPO && status === 'live' ? 'Powered off' : statusPretty(status))}</span></div>`;
                                        const html = [
                                            titleHTML,
                                            '<div class="hc-list">',
                                            `<div class="hc-row"><i class="fas fa-plug"></i><span>WebSocket</span><span class="mono value ${d.wsConnected ? '' : 'dim'}">${escapeHtml(ws)}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-clock"></i><span>Last seen</span><span class="mono value ${lastTs ? '' : 'dim'}">${escapeHtml(last)}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-hashtag"></i><span>Device ID</span><span class="mono value">${escapeHtml(d.id || '—')}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-expand"></i><span>Resolution</span><span class="mono value ${w && h ? '' : 'dim'}">${escapeHtml(res)}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-sliders"></i><span>Mode</span><span class="mono value ${mode ? '' : 'dim'}">${escapeHtml(modeLabel(mode))}</span></div>`,
                                            `<div class="hc-row hc-ua"><i class="fas fa-globe"></i><span>User agent</span><span class="mono value ${ua ? '' : 'dim'}" title="${escapeHtml(ua)}">${escapeHtml(ua || '—')}</span></div>`,
                                            '</div>',
                                        ].join('');
                                        card.innerHTML = html;
                                    } else {
                                        // Media card
                                        const cs = d?.currentState || {};
                                        const title = cs.title || '—';
                                        const year = Number.isFinite(Number(cs.year))
                                            ? String(cs.year)
                                            : '—';
                                        const rating = Number.isFinite(Number(cs.rating))
                                            ? Number(cs.rating).toFixed(1)
                                            : '—';
                                        // Runtime: handle both ms and minutes, with safety checks
                                        let runtime = '—';
                                        const runtimeVal = Number(cs.runtime || cs.duration);
                                        if (Number.isFinite(runtimeVal) && runtimeVal > 0) {
                                            // If value is very large (>1000), assume it's in milliseconds
                                            // Otherwise assume it's already in minutes
                                            const minutes =
                                                runtimeVal > 1000
                                                    ? Math.round(runtimeVal / 60000)
                                                    : Math.round(runtimeVal);
                                            runtime = minutes > 0 ? `${minutes} min` : '—';
                                        }
                                        const genres = Array.isArray(cs.genres)
                                            ? cs.genres.join(', ')
                                            : '—';
                                        const tagline = (cs.tagline || '').trim() || '—';
                                        const contentRating =
                                            (cs.contentRating || '').trim() || '—';
                                        const html = [
                                            '<div class="hc-title"><i class="fas fa-film"></i><span>Media</span></div>',
                                            '<div class="hc-list">',
                                            `<div class="hc-row"><i class="fas fa-heading"></i><span>Title</span><span class="mono value ${title === '—' ? 'dim' : ''}">${escapeHtml(title)}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-calendar"></i><span>Year</span><span class="mono value ${year === '—' ? 'dim' : ''}">${escapeHtml(year)}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-star"></i><span>Rating</span><span class="mono value ${rating === '—' ? 'dim' : ''}">${escapeHtml(rating)}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-clock"></i><span>Runtime</span><span class="mono value ${runtime === '—' ? 'dim' : ''}">${escapeHtml(runtime)}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-shapes"></i><span>Genres</span><span class="mono value ${genres === '—' ? 'dim' : ''}">${escapeHtml(genres)}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-shield-alt"></i><span>Content Rating</span><span class="mono value ${contentRating === '—' ? 'dim' : ''}">${escapeHtml(contentRating)}</span></div>`,
                                            `<div class="hc-row"><i class="fas fa-quote-left"></i><span>Tagline</span><span class="mono value ${tagline === '—' ? 'dim' : ''}" style="max-width:520px;white-space:normal;line-height:1.35;font-style:italic;">${escapeHtml(tagline)}</span></div>`,
                                            '</div>',
                                        ].join('');
                                        card.innerHTML = html;
                                    }
                                }
                            }
                        } catch (_) {
                            /* hovercard build (status/media) failed (skip update, continue) */
                        }
                        // If dupes hovercard, rebuild content from trigger datasets
                        try {
                            if (card && card.id === 'hc-dupes') {
                                const title = tr.getAttribute('data-dupes-title') || '';
                                const ids = (tr.getAttribute('data-dupes-ids') || '')
                                    .split(',')
                                    .filter(Boolean);
                                const rows = (title || '').split('\n').slice(1);
                                const listHtml = rows
                                    .filter(Boolean)
                                    .map(
                                        (line, idx) =>
                                            `<div class="hc-row"><i class="fas fa-clone"></i><span>${escapeHtml(line)}</span><button class="btn btn-outline btn-sm" data-merge-tgt="${escapeHtml(tr.closest('.device-card')?.getAttribute('data-id') || '')}" data-merge-src="${escapeHtml(ids[idx] || '')}"><i class="fas fa-object-group"></i> Merge</button></div>`
                                    )
                                    .join('');
                                card.innerHTML = `
                                    <div class="hc-title">Duplicates found</div>
                                    <div class="hc-list">${listHtml || '<div class="hc-row"><span>No details</span></div>'}</div>
                                `;
                                card.querySelectorAll('button[data-merge-tgt]').forEach(btn => {
                                    btn.addEventListener('click', () => {
                                        const tgt = btn.getAttribute('data-merge-tgt');
                                        const src = btn.getAttribute('data-merge-src');
                                        openMergeWith(tgt);
                                        if (src) {
                                            const srcSel = document.getElementById('merge-source');
                                            if (srcSel) srcSel.value = src;
                                        }
                                    });
                                });
                            }
                        } catch (_) {
                            /* hovercard build (dupes) failed (leave previous content) */
                        }
                        positionHover(card, tr);
                        card.classList.add('open');
                        // Track the current trigger so we can live-refresh while open
                        try {
                            card._trigger = tr;
                        } catch (_) {
                            /* record of hover trigger failed (live refresh disabled) */
                        }
                    };
                    const hide = () => {
                        clearHide();
                        card.classList.remove('open');
                        try {
                            card._trigger = null;
                        } catch (_) {
                            /* clearing hover trigger reference failed (benign) */
                        }
                    };
                    tr.addEventListener('mouseenter', show);
                    tr.addEventListener('focus', show);
                    tr.addEventListener('mouseleave', e => {
                        if (e.relatedTarget && card.contains(e.relatedTarget)) return;
                        clearHide();
                        hideTimer = setTimeout(hide, 350);
                    });
                    tr.addEventListener('blur', () => {
                        setTimeout(() => {
                            if (!tr.matches(':hover') && !card.matches(':hover')) hide();
                        }, 200);
                    });
                    card.addEventListener('mouseenter', clearHide);
                    card.addEventListener('mousedown', clearHide);
                    card.addEventListener('mouseleave', e => {
                        if (e.relatedTarget && tr.contains(e.relatedTarget)) return;
                        hide();
                    });
                });
            }
            bindHover('.js-status-hover', statusCard);
            bindHover('.js-dupes-hover', dupesCard);
            bindHover('.js-media-hover', mediaCard);

            // (removed) toolbar presets handlers

            // Toolbar actions menu (merge, group, preset, location, selection tools)
            buildActionsMenu();
            // Use event delegation so rebuilt menus keep working
            const actionsMenuEl = document.getElementById('device-actions-menu');
            if (actionsMenuEl) {
                actionsMenuEl.addEventListener('click', async ev => {
                    const item = ev.target?.closest('.dropdown-item');
                    if (!item || !actionsMenuEl.contains(item)) return;
                    ev.stopPropagation();
                    const act = item.getAttribute('data-device-action');
                    if (act === 'create-device') {
                        const overlay = document.getElementById('modal-create-device');
                        const close = () => {
                            overlay?.classList.remove('open');
                            overlay?.setAttribute('aria-hidden', 'true');
                        };
                        // Prepare fields: suggested name + location dropdown + groups
                        const nameEl = document.getElementById('create-device-name');
                        const locSel = document.getElementById('create-device-location-select');
                        const locNew = document.getElementById('create-device-location-new');
                        const groupsSel = document.getElementById('create-device-groups');
                        const devices = state.all || [];
                        const rooms = Array.from(
                            new Set(
                                devices
                                    .map(d =>
                                        d && d.location != null ? String(d.location).trim() : ''
                                    )
                                    .filter(Boolean)
                            )
                        ).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
                        // Most common room (fallback to last used)
                        const counts = new Map();
                        for (const r of devices.map(d => (d.location || '').trim()).filter(Boolean))
                            counts.set(r, (counts.get(r) || 0) + 1);
                        let popular = '';
                        for (const [k, v] of counts.entries())
                            if (!popular || v > (counts.get(popular) || 0)) popular = k;
                        const lastLoc = (localStorage.getItem('admin2:last-location') || '').trim();
                        const defaultLoc = lastLoc || popular || '';
                        if (locSel) {
                            const opts = ['<option value="">Unassigned</option>']
                                .concat(
                                    rooms.map(
                                        r =>
                                            `<option value="${r.replace(/"/g, '&quot;')}">${r.replace(/</g, '&lt;')}</option>`
                                    )
                                )
                                .concat(['<option value="__new__">+ Add new location…</option>']);
                            locSel.innerHTML = opts.join('');
                            locSel.value = rooms.includes(defaultLoc) ? defaultLoc : '';
                            locSel.onchange = () => {
                                if (locSel.value === '__new__') {
                                    if (locNew) {
                                        locNew.style.display = '';
                                        setTimeout(() => locNew.focus(), 30);
                                    }
                                } else if (locNew) {
                                    locNew.style.display = 'none';
                                    locNew.value = '';
                                }
                            };
                            // Ensure hidden by default
                            if (locNew) {
                                locNew.style.display = 'none';
                                locNew.value = '';
                            }
                        }
                        // Suggest a friendly default name: "Screen N"
                        const suggestName = () => {
                            const base = 'Screen';
                            let maxN = 0;
                            for (const d of devices) {
                                const nm = (d?.name || '').trim();
                                if (!nm.toLowerCase().startsWith(base.toLowerCase())) continue;
                                const m = nm.match(/(\d+)\s*$/);
                                const n = m
                                    ? parseInt(m[1], 10)
                                    : nm.toLowerCase() === base.toLowerCase()
                                      ? 1
                                      : 0;
                                if (n > maxN) maxN = n;
                            }
                            return `${base} ${maxN + 1}`.trim();
                        };
                        if (nameEl) nameEl.value = suggestName();

                        // Populate groups selector alphabetically
                        if (groupsSel) {
                            const gs = Array.isArray(state.groups) ? state.groups.slice() : [];
                            gs.sort((a, b) =>
                                (a?.name || '').localeCompare(b?.name || '', undefined, {
                                    sensitivity: 'base',
                                })
                            );
                            groupsSel.innerHTML = gs
                                .map(
                                    g =>
                                        `<option value="${String(g.id)}">${escapeHtml(g.name || g.id)}</option>`
                                )
                                .join('');
                        }
                        if (overlay) {
                            __showOverlay(overlay, 'modal-create-device');
                            try {
                                if (window.__uiDebug)
                                    console.info(
                                        '[ModalDebug] create-device rect',
                                        overlay.getBoundingClientRect().toJSON()
                                    );
                            } catch (_) {
                                /* close other header menu failed (ignorable) */
                            }
                        }
                        const confirmBtn = document.getElementById('btn-create-device-confirm');
                        const onConfirm = async () => {
                            confirmBtn?.setAttribute('disabled', 'disabled');
                            try {
                                const name =
                                    document.getElementById('create-device-name')?.value || '';
                                let location = '';
                                if (locSel) {
                                    const v = locSel.value;
                                    if (v === '__new__') location = (locNew?.value || '').trim();
                                    else location = v;
                                }
                                // Generate a unique installId to force a new device record
                                const iid =
                                    self.crypto && self.crypto.randomUUID
                                        ? self.crypto.randomUUID()
                                        : 'iid-' +
                                          Math.random().toString(36).slice(2) +
                                          Date.now().toString(36);
                                const hwid =
                                    'hw-' +
                                    Math.random().toString(36).slice(2) +
                                    '-' +
                                    Date.now().toString(36);
                                const r = await fetchJSON('/api/devices/register', {
                                    method: 'POST',
                                    // Avoid sending cookies so server doesn't reuse pr_iid and upsert previous device
                                    credentials: 'omit',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'x-install-id': iid,
                                        'x-hardware-id': hwid,
                                    },
                                    body: JSON.stringify({
                                        name,
                                        location,
                                        installId: iid,
                                        hardwareId: hwid,
                                    }),
                                });
                                await loadDevices();
                                const newId = r?.deviceId || r?.device?.id || r?.id;
                                if (!newId) throw new Error('No device id returned');
                                // Assign groups if any selected
                                if (
                                    groupsSel &&
                                    groupsSel.selectedOptions &&
                                    groupsSel.selectedOptions.length
                                ) {
                                    const selected = Array.from(groupsSel.selectedOptions).map(
                                        o => o.value
                                    );
                                    try {
                                        await fetchJSON(
                                            `/api/devices/${encodeURIComponent(newId)}`,
                                            {
                                                method: 'PATCH',
                                                headers: { 'Content-Type': 'application/json' },
                                                body: JSON.stringify({ groups: selected }),
                                            }
                                        );
                                    } catch (_) {
                                        /* noop */
                                    }
                                }
                                close();
                                if (location)
                                    localStorage.setItem('admin2:last-location', location);
                                // Always show pairing right after creating
                                await openPairingFor([newId]);
                                window.notify?.toast({
                                    type: 'success',
                                    title: 'Device created',
                                    message: `Device ${newId} created`,
                                });
                            } catch (e) {
                                window.notify?.toast({
                                    type: 'error',
                                    title: 'Create device failed',
                                    message: e?.message || 'Failed to create device',
                                });
                            } finally {
                                confirmBtn?.removeAttribute('disabled');
                                confirmBtn?.removeEventListener('click', onConfirm);
                            }
                        };
                        confirmBtn?.addEventListener('click', onConfirm);
                        overlay
                            ?.querySelectorAll('[data-close-modal]')
                            ?.forEach(btn => btn.addEventListener('click', close, { once: true }));
                        return;
                    }
                    if (act === 'select-all') {
                        document.querySelectorAll('#device-grid .device-card').forEach(card => {
                            if (card.style.display === 'none') return; // page filtered out
                            const cb = card.querySelector('.device-select');
                            if (cb) {
                                cb.checked = true;
                                card.classList.add('selected');
                            }
                        });
                        updateBulkUI();
                        window.notify?.toast({
                            type: 'info',
                            title: 'Selection',
                            message: 'All on page selected',
                        });
                    } else if (act === 'clear-selection') {
                        document.querySelectorAll('#device-grid .device-select').forEach(cb => {
                            cb.checked = false;
                            cb.closest('.device-card')?.classList.remove('selected');
                        });
                        updateBulkUI();
                        window.notify?.toast({
                            type: 'info',
                            title: 'Selection',
                            message: 'Selection cleared',
                        });
                    } else if (act === 'location') {
                        const selected = Array.from(
                            document.querySelectorAll('#device-grid .device-card.selected')
                        );
                        if (!selected.length) {
                            window.notify?.toast({
                                type: 'info',
                                title: 'No devices selected',
                                message: 'Select one or more devices first',
                            });
                            return;
                        }
                        openAssignLocationModal();
                    } else if (act === 'groups') {
                        const selected = Array.from(
                            document.querySelectorAll('#device-grid .device-card.selected')
                        );
                        if (!selected.length) {
                            window.notify?.toast({
                                type: 'info',
                                title: 'No devices selected',
                                message: 'Select one or more devices first',
                            });
                            return;
                        }
                        openGroupModal();
                    } else if (act === 'presets') {
                        const selected = Array.from(
                            document.querySelectorAll('#device-grid .device-card.selected')
                        );
                        if (!selected.length) {
                            window.notify?.toast({
                                type: 'info',
                                title: 'No devices selected',
                                message: 'Select one or more devices first',
                            });
                            return;
                        }
                        openAssignPresetModal();
                    } else if (act === 'merge') {
                        const selected = Array.from(
                            document.querySelectorAll('#device-grid .device-card.selected')
                        );
                        if (selected.length < 2) {
                            window.notify?.toast({
                                type: 'warning',
                                title: 'Select at least 2 devices',
                                message: 'Pick a source and a target to merge',
                            });
                            return;
                        }
                        // Prefer the last selected as target, others as sources
                        const tgt = selected[selected.length - 1].getAttribute('data-id');
                        populateMergeOptions();
                        if (mergeTarget) mergeTarget.value = tgt;
                        if (mergeSource) {
                            // If exactly two, set source to the other; else leave first option
                            const srcId = selected[0].getAttribute('data-id');
                            if (srcId && srcId !== tgt) mergeSource.value = srcId;
                        }
                        document.getElementById('modal-merge')?.classList.add('open');
                    } else if (act === 'preset') {
                        // Deprecated singular action id; treat like 'presets'
                        const selected = Array.from(
                            document.querySelectorAll('#device-grid .device-card.selected')
                        );
                        if (!selected.length) {
                            window.notify?.toast({
                                type: 'info',
                                title: 'No devices selected',
                                message: 'Select one or more devices first',
                            });
                            return;
                        }
                        openAssignPresetModal();
                    } else if (act === 'delete') {
                        const selectedCards = Array.from(
                            document.querySelectorAll('#device-grid .device-card.selected')
                        );
                        if (!selectedCards.length) {
                            window.notify?.toast({
                                type: 'info',
                                title: 'No devices selected',
                                message: 'Select one or more devices first',
                            });
                            return;
                        }
                        const ids = selectedCards
                            .map(c => c.getAttribute('data-id'))
                            .filter(Boolean);
                        const names = selectedCards
                            .map(
                                c =>
                                    c.querySelector('.device-title .name')?.textContent?.trim() ||
                                    c.getAttribute('data-id')
                            )
                            .filter(Boolean);
                        // Populate and open themed modal
                        const overlay = document.getElementById('modal-delete-devices');
                        const content = document.getElementById('modal-delete-content');
                        const confirmBtn = document.getElementById('btn-confirm-delete-devices');
                        if (content) {
                            const list = names
                                .slice(0, 6)
                                .map(n => `<li>${escapeHtml(n)}</li>`)
                                .join('');
                            const more =
                                names.length > 6 ? `<li>…and ${names.length - 6} more</li>` : '';
                            content.innerHTML = `
                                <p>You're about to permanently delete <strong>${ids.length}</strong> device${ids.length !== 1 ? 's' : ''}. This action cannot be undone.</p>
                                <ul style="margin: 10px 0 0 18px;">${list}${more}</ul>
                            `;
                        }
                        // Clean previous handlers
                        if (confirmBtn) {
                            const newBtn = confirmBtn.cloneNode(true);
                            confirmBtn.parentNode.replaceChild(newBtn, confirmBtn);
                            newBtn.addEventListener('click', async () => {
                                newBtn.classList.add('btn-loading');
                                newBtn.disabled = true;
                                let ok = 0;
                                let fail = 0;
                                for (const id of ids) {
                                    try {
                                        await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                                            method: 'DELETE',
                                        });
                                        ok++;
                                    } catch (_) {
                                        fail++;
                                    }
                                }
                                document
                                    .getElementById('modal-delete-devices')
                                    ?.classList.remove('open');
                                if (ok) {
                                    window.notify?.toast({
                                        type: 'success',
                                        title: 'Deleted',
                                        message: `Deleted ${ok} device${ok !== 1 ? 's' : ''}`,
                                    });
                                }
                                if (fail) {
                                    window.notify?.toast({
                                        type: 'error',
                                        title: 'Some failed',
                                        message: `${fail} could not be deleted`,
                                    });
                                }
                                await loadDevices();
                            });
                        }
                        overlay?.classList.add('open');
                    }
                    document
                        .querySelectorAll('#section-devices .dropdown')
                        .forEach(x => x.classList.remove('open'));
                });
            }

            // Filter menu (toolbar)
            function updateFilterMenuUI() {
                document.querySelectorAll('#device-filter-menu .dropdown-item').forEach(it => {
                    const val = it.getAttribute('data-device-filter') || '';
                    const [type, v] = val.split(':');
                    const active =
                        (type === 'status' && state.filterStatus === v) ||
                        (type === 'location' && state.filterRoom === v);
                    it.classList.toggle('active', !!active);
                });
            }
            function wireFilterMenuHandlers() {
                document.querySelectorAll('#device-filter-menu .dropdown-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const val = item.getAttribute('data-device-filter');
                        const label = item.textContent.trim();
                        const [type, v] = (val || '').split(':');
                        if (type === 'status') {
                            state.filterStatus = state.filterStatus === v ? null : v;
                        } else if (type === 'location') {
                            state.filterRoom = state.filterRoom === v ? null : v;
                        } else if (type === 'clear' || val === 'clear') {
                            state.filterStatus = null;
                            state.filterRoom = null;
                            state.query = '';
                            const deviceSearch = document.getElementById('device-search');
                            if (deviceSearch) deviceSearch.value = '';
                        }
                        state.currentPage = 1;
                        updateFilterMenuUI();
                        renderPage();
                        window.notify?.toast({
                            type: 'info',
                            title: 'Filter',
                            message: `${type} → ${label}`,
                        });
                        document
                            .querySelectorAll('#section-devices .dropdown')
                            .forEach(x => x.classList.remove('open'));
                    });
                });
            }
            // Initial menu builds (populate immediately, even before loadDevices)
            buildActionsMenu();
            buildFilterMenu();
            loadPresets();
            // Mark as initialized only after core menus are present
            try {
                section.dataset.inited = '1';
                dbg('initDevices(): initialized');
            } catch (_) {
                /* plex port numeric clamp listener wiring failed (digits still filtered) */
            }
            // Load syncEnabled from /get-config so we can show 'Synced' badge on devices
            (async () => {
                try {
                    const cfg = await fetchJSON('/get-config').catch(() => null);
                    if (cfg && typeof cfg.syncEnabled !== 'undefined') {
                        state.syncEnabled = !!cfg.syncEnabled;
                    } else {
                        state.syncEnabled = true; // default enabled when not specified
                    }
                } catch (_) {
                    state.syncEnabled = undefined;
                }
            })();

            // Live reconcile: periodically refresh toolbar states from device-reported truth
            let devicesLiveTimer = null;
            const DEVICES_LIVE_INTERVAL = 3000; // 3s is snappy without being too chatty
            function isDevicesSectionVisible() {
                try {
                    const cs = getComputedStyle(section);
                    return cs.display !== 'none' && cs.visibility !== 'hidden';
                } catch (_) {
                    return true;
                }
            }
            async function reconcileDeviceToolbarStatesOnce(listOverride) {
                try {
                    const t0 = performance.now?.() || Date.now();
                    const list =
                        Array.isArray(listOverride) && listOverride.length >= 0
                            ? listOverride
                            : await fetchJSON('/api/devices').catch(() => null);
                    if (!Array.isArray(list)) return;
                    // Keep in-memory state fresh for hovercards and filters
                    try {
                        state.all = list;
                    } catch (_) {
                        /* display metric shortcut navigation failed (benign) */
                    }
                    const byId = new Map(
                        list.map(d => [String(d.id || d.deviceId || d._id || d.name || ''), d])
                    );
                    document.querySelectorAll('#device-grid .device-card').forEach(card => {
                        const id = card.getAttribute('data-id');
                        if (!id) return;
                        const d = byId.get(id);
                        if (!d) return;

                        // Play/Pause button truth from device state
                        const ppBtn = card.querySelector('.btn-playpause');
                        if (ppBtn) {
                            const paused = d?.currentState?.paused === true;
                            ppBtn.classList.toggle('is-paused', paused);
                            ppBtn.classList.toggle('is-playing', !paused);
                            const icon = ppBtn.querySelector('i');
                            if (icon) icon.className = `fas ${paused ? 'fa-pause' : 'fa-play'}`;
                            ppBtn.title = paused ? 'Resume' : 'Pause';
                        }

                        // Pin button truth from device state
                        const pinBtn = card.querySelector('.btn-pin');
                        if (pinBtn) {
                            const pinned = isDevicePinned(d);
                            pinBtn.classList.toggle('is-pinned', pinned);
                            try {
                                pinBtn.setAttribute('aria-pressed', pinned ? 'true' : 'false');
                            } catch (_) {
                                /* close user menu during notif open failed (ignored) */
                            }
                            const icon = pinBtn.querySelector('i');
                            if (icon)
                                icon.className = `fas ${pinned ? 'fa-map-pin' : 'fa-thumbtack'}`;
                            pinBtn.title = pinned ? 'Unpin poster' : 'Pin current poster';
                        }

                        // Status pill + synced-dot + power button enablement
                        try {
                            const status = getStatusClass(d);
                            // Keep data-status attribute in sync for styling/hooks
                            try {
                                card.setAttribute('data-status', status);
                            } catch (_) {
                                /* status data-status attribute sync failed (cosmetic only) */
                            }
                            // Update only the status pill (js-status-hover) and replace its inner content to avoid duplicates
                            const statusPill = card.querySelector(
                                '.device-badges .js-status-hover'
                            );
                            if (statusPill) {
                                const prev =
                                    (statusPill.className.match(
                                        /status-(live|online|offline|unknown)/
                                    ) || [])[0] || '';
                                const nextCls = `status-${status}`;
                                const changed = prev !== nextCls;
                                statusPill.classList.remove(
                                    'status-live',
                                    'status-online',
                                    'status-offline',
                                    'status-unknown'
                                );
                                statusPill.classList.add(nextCls);
                                const po = d?.currentState?.poweredOff === true;
                                const labelText =
                                    status === 'live'
                                        ? po
                                            ? 'Powered off'
                                            : 'Live'
                                        : status === 'online'
                                          ? 'Online'
                                          : status === 'unknown'
                                            ? 'Unknown'
                                            : 'Offline';
                                const ico = iconForStatus(
                                    po && status === 'live' ? 'offline' : status
                                );
                                statusPill.innerHTML = `<i class="${ico}"></i> ${labelText}`;
                                if (changed) {
                                    // retrigger animation by toggling the class
                                    statusPill.classList.remove('status-flip');
                                    // force reflow

                                    statusPill.offsetWidth;
                                    statusPill.classList.add('status-flip');
                                    setTimeout(
                                        () => statusPill.classList.remove('status-flip'),
                                        600
                                    );
                                }
                            }
                            // Synced dot visibility
                            const corner = card.querySelector('.device-corner .synced-dot');
                            const shouldShowDot = !!d.wsConnected && state.syncEnabled !== false;
                            if (corner) {
                                corner.style.display = shouldShowDot ? '' : 'none';
                            } else if (shouldShowDot) {
                                // Create the corner container + dot if missing
                                const cornerWrap = document.createElement('div');
                                cornerWrap.className = 'device-corner';
                                const dot = document.createElement('span');
                                dot.className = 'synced-dot';
                                dot.setAttribute('role', 'status');
                                dot.setAttribute('aria-label', 'Device will align to sync ticks');
                                dot.title = 'Device will align to sync ticks';
                                cornerWrap.appendChild(dot);
                                // Insert at the top of card
                                card.insertBefore(cornerWrap, card.firstChild);
                            }
                            // Power button disabled when offline; magenta icon when powered off
                            const powerBtn = card.querySelector('.btn-power');
                            if (powerBtn) {
                                powerBtn.disabled = status === 'offline';
                                const po = d?.currentState?.poweredOff === true;
                                powerBtn.classList.toggle('is-off', po);
                                if (po) powerBtn.title = 'Power Toggle (Powered off)';
                            }
                            // Disable other controls while offline or powered off
                            try {
                                const disabled =
                                    status === 'offline' || d?.currentState?.poweredOff === true;
                                const sel = [
                                    '.btn-remote',
                                    '.btn-sendcmd',
                                    '.btn-playpause',
                                    '.btn-pin',
                                ];
                                sel.forEach(s => {
                                    const el = card.querySelector(s);
                                    if (el) el.disabled = disabled;
                                });
                            } catch (_) {
                                /* disable secondary controls while offline/powered-off failed (non-fatal) */
                            }
                            // No separate powered-off pill anymore
                        } catch (_) {
                            /* direct wrapper nested removal failed (harmless) */
                        }

                        // Live-update now-playing thumbnail and title (if present)
                        try {
                            const cs = d && d.currentState ? d.currentState : {};
                            const src = cs.thumbnailUrl || cs.posterUrl || cs.backgroundUrl || '';
                            const status = getStatusClass(d);
                            const np =
                                card.querySelector('.nowplay-thumb-right') ||
                                card.querySelector('.nowplay-thumb');

                            // If device is offline, remove thumbnail immediately to prevent broken images
                            if (status === 'offline' && np) {
                                card.classList.remove('has-nowplay');
                                try {
                                    np.remove();
                                } catch (_) {
                                    /* now-playing thumb remove during offline transition failed (safe) */
                                }
                            } else if (np) {
                                const img = np.querySelector('img');
                                if (img && src) {
                                    const nextAlt = (cs.title || d.name || '').toString();
                                    const curSrc = img.getAttribute('src') || '';
                                    if (curSrc !== src && !img.__fading) {
                                        img.__fading = true;
                                        // Preload target to avoid blank pop-in and verify it loads
                                        const pre = new Image();
                                        pre.onload = () => {
                                            try {
                                                const prevTransition = img.style.transition;
                                                // Ensure we have a transition for opacity
                                                img.style.transition = 'opacity 160ms ease-in-out';
                                                // Start fade-out on next frame
                                                requestAnimationFrame(() => {
                                                    img.style.opacity = '0';
                                                    // After fade-out, swap src and fade-in
                                                    setTimeout(() => {
                                                        img.setAttribute('src', src);
                                                        img.setAttribute('alt', nextAlt);
                                                        // Fade back in on next frame
                                                        requestAnimationFrame(() => {
                                                            img.style.opacity = '1';
                                                            // Cleanup a bit after the fade completes
                                                            setTimeout(() => {
                                                                img.style.transition =
                                                                    prevTransition;
                                                                img.__fading = false;
                                                            }, 220);
                                                        });
                                                    }, 170);
                                                });
                                            } catch (_) {
                                                // Fallback: direct swap without animation
                                                try {
                                                    img.setAttribute('src', src);
                                                    img.setAttribute('alt', nextAlt);
                                                } catch (_) {
                                                    /* direct src/alt swap fallback failed (image may remain old) */
                                                }
                                                img.__fading = false;
                                            }
                                        };
                                        pre.onerror = () => {
                                            // If preload fails, remove the thumbnail entirely (broken image)
                                            img.__fading = false;
                                            card.classList.remove('has-nowplay');
                                            try {
                                                np.remove();
                                            } catch (_) {
                                                /* remove broken now-playing thumbnail failed (layout OK) */
                                            }
                                        };
                                        // Start preloading to test if image is valid
                                        pre.src = src;
                                    } else {
                                        // No change (or currently animating): keep alt fresh
                                        img.setAttribute('alt', nextAlt);
                                    }
                                }
                                const titleRow =
                                    card.querySelector('.nowplay-title-bottom') ||
                                    card.querySelector('.nowplay-title-row');
                                if (titleRow) {
                                    const t = (cs.title || '').toString();
                                    titleRow.textContent = t;
                                    if (t) titleRow.setAttribute('title', t);
                                    titleRow.style.display = t ? '' : 'none';
                                }
                                // Toggle spacing class based on presence of src
                                if (src) card.classList.add('has-nowplay');
                                else card.classList.remove('has-nowplay');
                                // If src is now empty, remove the thumbnail node entirely
                                if (!src) {
                                    try {
                                        np.remove();
                                    } catch (_) {
                                        /* stale now-playing thumbnail node removal failed (benign) */
                                    }
                                }
                            } else if (src && status !== 'offline') {
                                // Thumbnail became available; test if it loads before injecting
                                // (but only if device is not offline)
                                const actions = card.querySelector('.device-actions');
                                if (actions) {
                                    // Preload to verify image exists
                                    const testImg = new Image();
                                    testImg.onload = () => {
                                        // Image loads successfully, inject the thumbnail
                                        const wrap = document.createElement('div');
                                        wrap.className =
                                            'nowplay-thumb nowplay-thumb-right js-media-hover';
                                        const img = document.createElement('img');
                                        img.setAttribute('src', src);
                                        img.setAttribute(
                                            'alt',
                                            (cs.title || d.name || '').toString()
                                        );
                                        img.setAttribute('loading', 'lazy');
                                        img.setAttribute('decoding', 'async');
                                        img.setAttribute('referrerpolicy', 'no-referrer');
                                        img.setAttribute('width', '48');
                                        img.setAttribute('height', '72');
                                        img.setAttribute(
                                            'onerror',
                                            "this.parentElement.remove();this.closest('.device-card').classList.remove('has-nowplay');"
                                        );
                                        // Quick entrance fade-in
                                        img.style.opacity = '0';
                                        img.style.transition = 'opacity 160ms ease-in-out';
                                        wrap.appendChild(img);
                                        actions.insertBefore(wrap, actions.firstChild);
                                        card.classList.add('has-nowplay');
                                        try {
                                            bindHover && bindHover('.js-media-hover', mediaCard);
                                        } catch (_) {
                                            /* force add open class failed (panel may still open later) */
                                        }
                                        requestAnimationFrame(() => {
                                            img.style.opacity = '1';
                                        });
                                    };
                                    testImg.onerror = () => {
                                        // Image fails to load, don't inject thumbnail
                                        card.classList.remove('has-nowplay');
                                    };
                                    // Start loading to test if image is valid
                                    testImg.src = src;
                                }
                            }
                        } catch (_) {
                            /* inner wrapper flatten (A) failed (layout unaffected) */
                        }
                    });

                    // If a hovercard is currently open, refresh its content live
                    try {
                        const hcStatus = document.getElementById('hc-status');
                        if (hcStatus && hcStatus.classList.contains('open') && hcStatus._trigger) {
                            const tr = hcStatus._trigger;
                            const cardEl = tr.closest('.device-card');
                            const did = cardEl?.getAttribute('data-id');
                            const d = byId.get(did);
                            if (d) {
                                const status = getStatusClass(d);
                                const ws = d.wsConnected ? 'Connected' : 'Not connected';
                                const lastTs = Date.parse(d.lastSeenAt || 0) || 0;
                                const last = lastTs
                                    ? `${fmtAgo(lastTs)}\u00A0·\u00A0${new Date(lastTs).toLocaleString()}`
                                    : '—';
                                const sc = d?.clientInfo?.screen || {};
                                const w = Number(sc.w || sc.width || 0) || 0;
                                const h = Number(sc.h || sc.height || 0) || 0;
                                const dpr = Number(sc.dpr || sc.scale || 1) || 1;
                                const res =
                                    w && h
                                        ? `${w}×${h}${dpr && dpr !== 1 ? ` @${dpr}x` : ''}`
                                        : '—';
                                const mode = d?.clientInfo?.mode || d?.mode || '';
                                const ua = (
                                    d?.clientInfo?.userAgent ||
                                    d?.clientInfo?.ua ||
                                    ''
                                ).trim();
                                const isPO = d?.currentState?.poweredOff === true;
                                const dotCls =
                                    isPO && status === 'live'
                                        ? 'sd-poweredoff'
                                        : statusDotClass(status);
                                const titleHTML = `<div class="hc-title"><span class="status-dot ${dotCls}"></span><span>${escapeHtml(isPO && status === 'live' ? 'Powered off' : statusPretty(status))}</span></div>`;
                                const html = [
                                    titleHTML,
                                    '<div class="hc-list">',
                                    `<div class="hc-row"><i class="fas fa-plug"></i><span>WebSocket</span><span class="mono value ${d.wsConnected ? '' : 'dim'}">${escapeHtml(ws)}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-clock"></i><span>Last seen</span><span class="mono value ${lastTs ? '' : 'dim'}">${escapeHtml(last)}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-hashtag"></i><span>Device ID</span><span class="mono value">${escapeHtml(d.id || '—')}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-expand"></i><span>Resolution</span><span class="mono value ${w && h ? '' : 'dim'}">${escapeHtml(res)}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-sliders"></i><span>Mode</span><span class="mono value ${mode ? '' : 'dim'}">${escapeHtml(modeLabel(mode) || '—')}</span></div>`,
                                    `<div class="hc-row hc-ua"><i class="fas fa-globe"></i><span>User agent</span><span class="mono value ${ua ? '' : 'dim'}" title="${escapeHtml(ua)}">${escapeHtml(ua || '—')}</span></div>`,
                                    '</div>',
                                ].join('');
                                hcStatus.innerHTML = html;
                                positionHover(hcStatus, tr);
                            }
                        }
                        const hcMedia = document.getElementById('hc-media');
                        if (hcMedia && hcMedia.classList.contains('open') && hcMedia._trigger) {
                            const tr = hcMedia._trigger;
                            const cardEl = tr.closest('.device-card');
                            const did = cardEl?.getAttribute('data-id');
                            const d = byId.get(did);
                            if (d) {
                                const cs = d?.currentState || {};
                                const title = cs.title || '—';
                                const year = Number.isFinite(Number(cs.year))
                                    ? String(cs.year)
                                    : '—';
                                const rating = Number.isFinite(Number(cs.rating))
                                    ? Number(cs.rating).toFixed(1)
                                    : '—';
                                // Runtime: handle both ms and minutes, with safety checks
                                let runtime = '—';
                                const runtimeVal = Number(cs.runtime || cs.duration);
                                if (Number.isFinite(runtimeVal) && runtimeVal > 0) {
                                    // If value is very large (>1000), assume it's in milliseconds
                                    // Otherwise assume it's already in minutes
                                    const minutes =
                                        runtimeVal > 1000
                                            ? Math.round(runtimeVal / 60000)
                                            : Math.round(runtimeVal);
                                    runtime = minutes > 0 ? `${minutes} min` : '—';
                                }
                                const genres = Array.isArray(cs.genres)
                                    ? cs.genres.join(', ')
                                    : '—';
                                const tagline = (cs.tagline || '').trim() || '—';
                                const contentRating = (cs.contentRating || '').trim() || '—';
                                const html = [
                                    '<div class="hc-title"><i class="fas fa-film"></i><span>Media</span></div>',
                                    '<div class="hc-list">',
                                    `<div class="hc-row"><i class="fas fa-heading"></i><span>Title</span><span class="mono value ${title === '—' ? 'dim' : ''}">${escapeHtml(title)}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-calendar"></i><span>Year</span><span class="mono value ${year === '—' ? 'dim' : ''}">${escapeHtml(year)}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-star"></i><span>Rating</span><span class="mono value ${rating === '—' ? 'dim' : ''}">${escapeHtml(rating)}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-clock"></i><span>Runtime</span><span class="mono value ${runtime === '—' ? 'dim' : ''}">${escapeHtml(runtime)}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-shapes"></i><span>Genres</span><span class="mono value ${genres === '—' ? 'dim' : ''}">${escapeHtml(genres)}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-shield-alt"></i><span>Content Rating</span><span class="mono value ${contentRating === '—' ? 'dim' : ''}">${escapeHtml(contentRating)}</span></div>`,
                                    `<div class="hc-row"><i class="fas fa-quote-left"></i><span>Tagline</span><span class="mono value ${tagline === '—' ? 'dim' : ''}" style="max-width:520px;white-space:normal;line-height:1.35;font-style:italic;">${escapeHtml(tagline)}</span></div>`,
                                    '</div>',
                                ].join('');
                                hcMedia.innerHTML = html;
                                positionHover(hcMedia, tr);
                            }
                        }
                    } catch (_) {
                        /* hovercard live refresh failed (will retry next cycle) */
                    }
                    const t1 = performance.now?.() || Date.now();
                    ddbg('reconcileDeviceToolbarStatesOnce duration', Math.round(t1 - t0) + 'ms');
                } catch (_) {
                    /* ignore transient errors */
                }
                // After applying live updates, re-evaluate filters; if set changed, re-render
                try {
                    const before = Array.isArray(state.filteredIds)
                        ? state.filteredIds.slice()
                        : [];
                    applyFilters();
                    const after = state.filteredIds || [];
                    const changed =
                        before.length !== after.length || before.some((id, i) => id !== after[i]);
                    if (changed) {
                        renderPage();
                        return;
                    }
                } catch (_) {
                    /* devices filter change diff check failed (re-render skipped) */
                }
            }
            function startDevicesLiveReconcile() {
                stopDevicesLiveReconcile();
                if (!isDevicesSectionVisible()) return;
                devicesLiveTimer = setInterval(() => {
                    if (!isDevicesSectionVisible()) return;
                    reconcileDeviceToolbarStatesOnce();
                }, DEVICES_LIVE_INTERVAL);
            }
            function stopDevicesLiveReconcile() {
                if (devicesLiveTimer) {
                    clearInterval(devicesLiveTimer);
                    devicesLiveTimer = null;
                }
            }
            // Expose an immediate reconcile hook for SSE push events
            try {
                window.admin2 = window.admin2 || {};
                window.admin2.reconcileDevicesNow = list => reconcileDeviceToolbarStatesOnce(list);
            } catch (_) {
                /* expose reconcileDevicesNow hook failed (optional SSE push hook) */
            }
            // Start live reconcile now and on tab visibility changes
            startDevicesLiveReconcile();
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) stopDevicesLiveReconcile();
                else startDevicesLiveReconcile();
            });

            // Bulk selection bar (events are bound to selection changes in bindCardEvents)
            document.getElementById('bulk-clear')?.addEventListener('click', () => {
                document.querySelectorAll('#device-grid .device-select').forEach(cb => {
                    cb.checked = false;
                    cb.closest('.device-card')?.classList.remove('selected');
                });
                updateBulkUI();
            });
            document.getElementById('bulk-reload')?.addEventListener('click', async () => {
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                for (const id of ids) await sendCommand(id, 'core.mgmt.reload');
                window.notify?.toast({
                    type: 'info',
                    title: 'Reload',
                    message: `Requested reload for ${ids.length} device${ids.length !== 1 ? 's' : ''}`,
                });
            });
            document.getElementById('bulk-clearcache')?.addEventListener('click', async () => {
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                for (const id of ids) await sendCommand(id, 'core.mgmt.clearCache');
                window.notify?.toast({
                    type: 'success',
                    title: 'Clear cache',
                    message: `Cleared cache on ${ids.length} device${ids.length !== 1 ? 's' : ''}`,
                });
            });
            // Note: 'All devices' Clear+Reload button removed from Operations; bulk actions remain under Device Management.
            document.getElementById('bulk-pair')?.addEventListener('click', async () => {
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                try {
                    if (window.__uiDebug) console.info('[BulkAction] pair', ids);
                } catch (_) {
                    /* debug log best-effort (console unavailable) */
                }
                await openPairingFor(ids);
            });
            (function () {
                const el = document.getElementById('bulk-remote');
                if (el) el.remove();
            })();
            document.getElementById('bulk-override')?.addEventListener('click', async () => {
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                try {
                    if (window.__uiDebug) console.info('[BulkAction] override', ids);
                } catch (_) {
                    /* debug log best-effort (console unavailable) */
                }
                await openOverrideFor(ids);
            });
            document.getElementById('bulk-sendcmd')?.addEventListener('click', async () => {
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                try {
                    if (window.__uiDebug) console.info('[BulkAction] sendcmd', ids);
                } catch (_) {
                    /* debug log best-effort (console unavailable) */
                }
                await openSendCmdFor(ids);
            });
            document.getElementById('bulk-clearoverrides')?.addEventListener('click', async () => {
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                if (!ids.length) {
                    window.notify?.toast?.({
                        type: 'info',
                        title: 'No devices selected',
                        message: 'Select one or more devices first',
                    });
                    return;
                }
                const proceed = await (async () => {
                    try {
                        return await confirmAction({
                            title: 'Clear Display Overrides',
                            message: `Remove all display settings overrides for <strong>${ids.length}</strong> device${ids.length !== 1 ? 's' : ''}? They will then only inherit server and group configuration.`,
                            okText: 'Clear Overrides',
                            okClass: 'btn-accent btn-confirm-accent',
                            okIcon: 'eraser',
                        });
                    } catch (_) {
                        return window.confirm(
                            `Clear overrides for ${ids.length} device${ids.length !== 1 ? 's' : ''}?`
                        );
                    }
                })();
                if (!proceed) return;
                let ok = 0,
                    fail = 0;
                for (const id of ids) {
                    try {
                        await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ settingsOverride: {} }),
                        });
                        ok++;
                    } catch (_) {
                        fail++;
                    }
                }
                if (ok)
                    window.notify?.toast?.({
                        type: 'success',
                        title: 'Overrides cleared',
                        message: `Cleared ${ok} device${ok !== 1 ? 's' : ''}`,
                    });
                if (fail)
                    window.notify?.toast?.({
                        type: 'warning',
                        title: 'Some failed',
                        message: `${fail} could not be cleared`,
                    });
                await loadDevices();
            });
            document.getElementById('bulk-playpause')?.addEventListener('click', async () => {
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                for (const id of ids) await sendCommand(id, 'playback.toggle');
            });
            document.getElementById('bulk-delete')?.addEventListener('click', async () => {
                // reuse existing delete modal flow
                const selectedCards = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                );
                if (!selectedCards.length) {
                    window.notify?.toast({
                        type: 'info',
                        title: 'No devices selected',
                        message: 'Select one or more devices first',
                    });
                    return;
                }
                const ids = selectedCards.map(c => c.getAttribute('data-id')).filter(Boolean);
                const names = selectedCards
                    .map(
                        c =>
                            c.querySelector('.device-title .name')?.textContent?.trim() ||
                            c.getAttribute('data-id')
                    )
                    .filter(Boolean);
                const overlay = document.getElementById('modal-delete-devices');
                const content = document.getElementById('modal-delete-content');
                const confirmBtn = document.getElementById('btn-confirm-delete-devices');
                if (content) {
                    const list = names
                        .slice(0, 6)
                        .map(n => `<li>${escapeHtml(n)}</li>`)
                        .join('');
                    const more = names.length > 6 ? `<li>…and ${names.length - 6} more</li>` : '';
                    content.innerHTML = `<p>You're about to permanently delete <strong>${ids.length}</strong> device${ids.length !== 1 ? 's' : ''}. This action cannot be undone.</p><ul style="margin:10px 0 0 18px;">${list}${more}</ul>`;
                }
                if (confirmBtn) {
                    const newBtn = confirmBtn.cloneNode(true);
                    confirmBtn.parentNode.replaceChild(newBtn, confirmBtn);
                    newBtn.addEventListener('click', async () => {
                        newBtn.classList.add('btn-loading');
                        newBtn.disabled = true;
                        let ok = 0,
                            fail = 0;
                        for (const id of ids) {
                            try {
                                await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                                    method: 'DELETE',
                                });
                                ok++;
                            } catch (_) {
                                fail++;
                            }
                        }
                        document.getElementById('modal-delete-devices')?.classList.remove('open');
                        if (ok)
                            window.notify?.toast({
                                type: 'success',
                                title: 'Deleted',
                                message: `Deleted ${ok} device${ok !== 1 ? 's' : ''}`,
                            });
                        if (fail)
                            window.notify?.toast({
                                type: 'error',
                                title: 'Some failed',
                                message: `${fail} could not be deleted`,
                            });
                        await loadDevices();
                    });
                }
                if (overlay) {
                    if (window.__uiDebug) console.info('[BulkAction] delete open modal', { ids });
                    __showOverlay(overlay, 'modal-delete-devices');
                    // zero-rect repair if needed
                    try {
                        const r = overlay.getBoundingClientRect();
                        if (
                            (r.width === 0 || r.height === 0) &&
                            overlay.parentElement !== document.body
                        ) {
                            document.body.appendChild(overlay);
                            overlay.setAttribute('data-portal', 'true');
                            requestAnimationFrame(() => {
                                const r2 = overlay.getBoundingClientRect();
                                if (window.__uiDebug)
                                    console.info(
                                        '[BulkAction] delete rect after portal',
                                        r2.toJSON()
                                    );
                                if (r2.width === 0 || r2.height === 0) {
                                    overlay.style.width = '100vw';
                                    overlay.style.height = '100vh';
                                }
                            });
                        }
                    } catch (_) {
                        /* bulk action overlay portalization guard failed (fallback applies) */
                    }
                }
            });
            document.getElementById('bulk-poweroff')?.addEventListener('click', async () => {
                const selectedCards = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                );
                const ids = selectedCards.map(c => c.getAttribute('data-id'));
                const offline = [];
                // For per-device toast, determine pre-toggle state from state.all
                for (const id of ids) {
                    const dev = (state.all || []).find(d => d.id === id);
                    const statusClass = dev ? getStatusClass(dev) : 'unknown';
                    if (statusClass === 'offline') {
                        offline.push(dev || { id });
                        continue;
                    }
                    const wasOff = !!dev?.currentState?.poweredOff;
                    const res = await sendCommand(id, 'power.toggle');
                    if (!res || res?.ack?.status === 'timeout') {
                        // sendCommand already showed a warning/error toast; skip success toast
                        continue;
                    }
                    const nowOff =
                        typeof res?.state?.poweredOff === 'boolean'
                            ? res.state.poweredOff
                            : !wasOff;
                    const turned = nowOff ? 'off' : 'on';
                    window.notify?.toast({
                        type: nowOff ? 'warning' : 'success',
                        title: 'Power toggle',
                        message: `${dev?.name || id}: ${turned}`,
                    });
                    // Optimistically update local state so subsequent actions reflect new status
                    if (dev) {
                        dev.currentState = dev.currentState || {};
                        dev.currentState.poweredOff = nowOff;
                    }
                }
                if (offline.length > 0) {
                    const names = offline.map(d => d?.name || d?.id || 'Unknown');
                    const preview = names.slice(0, 5).join(', ');
                    const more = names.length > 5 ? ` +${names.length - 5} more` : '';
                    window.notify?.toast({
                        type: 'info',
                        title: 'Offline devices',
                        message: `${names.length} skipped: ${preview}${more}`,
                    });
                }
                // Re-render current page to reflect updated power icon/title tooltips
                renderPage?.();
            });
            updateBulkUI();

            // Modal open buttons in device cards will be bound per-card after render

            // Group modal logic
            const groupSelect = document.getElementById('group-select');
            const btnAssign = document.getElementById('btn-group-assign');
            const btnRemove = document.getElementById('btn-group-remove');
            const btnCreateAssign = document.getElementById('btn-group-create-assign');
            const newGroupInput = document.getElementById('new-group-name');
            let __groupsLoading = false;
            async function loadGroups() {
                if (!groupSelect) return;
                if (__groupsLoading) return; // prevent concurrent stacking
                __groupsLoading = true;
                try {
                    // Accessible loading placeholder (will be replaced)
                    groupSelect.innerHTML =
                        '<option value="" disabled selected>Loading groups...</option>';
                    let list = await fetchJSON('/api/groups');
                    if (!Array.isArray(list)) list = [];
                    // Fallback: if empty, attempt to refresh config (in case groups created recently)
                    if (list.length === 0) {
                        try {
                            await fetchJSON('/get-config');
                            const retry = await fetchJSON('/api/groups');
                            if (Array.isArray(retry)) list = retry;
                        } catch (_) {
                            /* ignore fallback errors */
                        }
                    }
                    const seen = new Set();
                    const options = [];
                    for (const g of list) {
                        const id = g && g.id;
                        if (!id || seen.has(id)) continue;
                        seen.add(id);
                        const label = escapeHtml(g.name || id);
                        options.push(`<option value="${id}">${label}</option>`);
                    }
                    if (options.length === 0) {
                        groupSelect.innerHTML =
                            '<option value="" disabled selected>(No groups defined)</option>';
                    } else {
                        groupSelect.innerHTML = options.join('');
                    }
                } catch (_) {
                    groupSelect.innerHTML =
                        '<option value="" disabled selected>(Failed to load groups)</option>';
                } finally {
                    __groupsLoading = false;
                }
            }
            function openGroupModal() {
                loadGroups();
                const overlay = document.getElementById('modal-group-assign');
                if (!overlay) return;
                __showOverlay(overlay, 'modal-group-assign');
                try {
                    if (window.__uiDebug)
                        console.info(
                            '[ModalDebug] group-assign rect',
                            overlay.getBoundingClientRect().toJSON()
                        );
                } catch (_) {
                    /* plex days checkbox toggle wire failed (user can toggle manually) */
                }
            }
            async function patchDeviceGroups(deviceId, mutate) {
                try {
                    const dev = state.all.find(d => d.id === deviceId);
                    const current = Array.isArray(dev?.groups) ? dev.groups.slice() : [];
                    const next = mutate(current);
                    await fetchJSON(`/api/devices/${encodeURIComponent(deviceId)}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ groups: next }),
                    });
                    return true;
                } catch (_) {
                    return false;
                }
            }
            btnAssign?.addEventListener('click', async () => {
                const gid = groupSelect?.value;
                if (!gid) return;
                const selected = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                let ok = 0;
                for (const id of selected) {
                    // add if missing
                    const res = await patchDeviceGroups(id, arr =>
                        arr.includes(gid) ? arr : [...arr, gid]
                    );
                    if (res) ok++;
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Group updated',
                    message: `${ok}/${selected.length} devices updated`,
                });
                document.getElementById('modal-group-assign')?.classList.remove('open');
                await loadDevices();
            });
            btnRemove?.addEventListener('click', async () => {
                const gid = groupSelect?.value;
                if (!gid) return;
                const selected = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                let ok = 0;
                for (const id of selected) {
                    const res = await patchDeviceGroups(id, arr => arr.filter(x => x !== gid));
                    if (res) ok++;
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Removed from group',
                    message: `${ok}/${selected.length} devices updated`,
                });
                document.getElementById('modal-group-assign')?.classList.remove('open');
                await loadDevices();
            });
            // Assign Preset modal logic
            const presetSelect = document.getElementById('preset-select');
            const btnPresetApply = document.getElementById('btn-preset-apply');
            const btnPresetClear = document.getElementById('btn-preset-clear');
            function openAssignPresetModal() {
                // Populate from state.presets
                const list = Array.isArray(state.presets) ? state.presets : [];
                if (presetSelect) {
                    if (!list.length) {
                        presetSelect.innerHTML =
                            '<option value="" disabled selected>No presets defined</option>';
                    } else {
                        presetSelect.innerHTML = list
                            .map(
                                p =>
                                    `<option value="${(p.key || '').replace(/"/g, '&quot;')}">${(p.name || p.key || '').replace(/</g, '&lt;')}</option>`
                            )
                            .join('');
                    }
                }
                const overlay = document.getElementById('modal-assign-preset');
                if (!overlay) return;
                __showOverlay(overlay, 'modal-assign-preset');
                try {
                    if (window.__uiDebug)
                        console.info(
                            '[ModalDebug] assign-preset rect',
                            overlay.getBoundingClientRect().toJSON()
                        );
                } catch (_) {
                    /* jellyfin days checkbox toggle wire failed (user can toggle manually) */
                }
            }
            btnPresetApply?.addEventListener('click', async () => {
                const preset = presetSelect?.value || '';
                if (!preset) return;
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                if (!ids.length) {
                    window.notify?.toast({
                        type: 'info',
                        title: 'No devices selected',
                        message: 'Select one or more devices first',
                    });
                    return;
                }
                let ok = 0;
                for (const id of ids) {
                    try {
                        await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ preset }),
                        });
                        ok++;
                    } catch (_) {
                        /* preset apply API failed for device (continue others) */
                    }
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Preset applied',
                    message: `Applied to ${ok}/${ids.length} device${ids.length !== 1 ? 's' : ''}`,
                });
                document.getElementById('modal-assign-preset')?.classList.remove('open');
                await loadDevices();
            });
            btnPresetClear?.addEventListener('click', async () => {
                const ids = Array.from(
                    document.querySelectorAll('#device-grid .device-card.selected')
                ).map(c => c.getAttribute('data-id'));
                if (!ids.length) {
                    window.notify?.toast({
                        type: 'info',
                        title: 'No devices selected',
                        message: 'Select one or more devices first',
                    });
                    return;
                }
                let ok = 0;
                for (const id of ids) {
                    try {
                        await fetchJSON(`/api/devices/${encodeURIComponent(id)}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ preset: null }),
                        });
                        ok++;
                    } catch (_) {
                        /* preset clear API failed for device (continue others) */
                    }
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Preset cleared',
                    message: `Cleared on ${ok}/${ids.length}`,
                });
                document.getElementById('modal-assign-preset')?.classList.remove('open');
                await loadDevices();
            });
            // Enter key triggers Create & assign
            newGroupInput?.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    btnCreateAssign?.click();
                }
            });
            // Create a new group and assign selected devices
            btnCreateAssign?.addEventListener('click', async () => {
                const name = (newGroupInput?.value || '').trim();
                if (!name) {
                    window.notify?.toast({ type: 'info', title: 'Group name required' });
                    return;
                }
                try {
                    const created = await fetchJSON('/api/groups', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name }),
                    });
                    const gid = created?.id || created?.name || name;
                    await loadGroups();
                    if (groupSelect && gid) groupSelect.value = gid;
                    const selected = Array.from(
                        document.querySelectorAll('#device-grid .device-card.selected')
                    ).map(c => c.getAttribute('data-id'));
                    let ok = 0;
                    for (const id of selected) {
                        const res = await patchDeviceGroups(id, arr =>
                            arr.includes(gid) ? arr : [...arr, gid]
                        );
                        if (res) ok++;
                    }
                    window.notify?.toast({
                        type: 'success',
                        title: 'Group created',
                        message: `Assigned ${ok}/${selected.length} devices to ${gid}`,
                    });
                    document.getElementById('modal-group-assign')?.classList.remove('open');
                    await loadDevices();
                } catch (e) {
                    const msg = e?.message || '';
                    if (/exists|409/i.test(msg)) {
                        window.notify?.toast({
                            type: 'warning',
                            title: 'Group already exists',
                            message: name,
                        });
                    } else {
                        window.notify?.toast({
                            type: 'error',
                            title: 'Create group failed',
                            message: msg || 'Unknown error',
                        });
                    }
                }
            });
        };

        // 2FA disable flow
        btn2faDisable?.addEventListener('click', () => openModal('modal-2fa-disable'));
        const btn2faDisableConfirm = document.getElementById('btn-2fa-disable-confirm');
        const input2faDisablePassword = document.getElementById('input-2fa-disable-password');

        // Allow Enter key to submit disable form
        input2faDisablePassword?.addEventListener('keydown', e => {
            if (e.key === 'Enter' && input2faDisablePassword.value.trim()) {
                btn2faDisableConfirm?.click();
            }
        });

        ensureSpinner(btn2faDisableConfirm);
        btn2faDisableConfirm?.addEventListener('click', async () => {
            const pw = document.getElementById('input-2fa-disable-password');
            const password = pw?.value || '';
            if (!password) {
                return window.notify?.toast({
                    type: 'warning',
                    title: 'Password Required',
                    message: 'Enter your current password to disable two-factor authentication',
                    duration: 3500,
                });
            }
            try {
                btn2faDisableConfirm.classList.add('btn-loading');
                btn2faDisableConfirm.disabled = true;
                const r = await fetch('/api/admin/2fa/disable', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ password }),
                });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j?.error || j?.message || 'Failed to disable 2FA');
                window.notify?.toast({
                    type: 'success',
                    title: '2FA Disabled',
                    message: 'Two-Factor Authentication has been disabled for your account.',
                    duration: 3500,
                });
                closeModal('modal-2fa-disable');
                refreshSecurity();
                // Clear password field
                if (pw) pw.value = '';
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Disable Failed',
                    message: e?.message || 'Invalid password or failed to disable 2FA',
                    duration: 5000,
                });
                // Focus password field for retry
                if (pw) {
                    pw.focus();
                    pw.select();
                }
            } finally {
                btn2faDisableConfirm?.classList.remove('btn-loading');
                btn2faDisableConfirm.disabled = false;
            }
        });

        // Change Password Modal
        const btnChangePasswordModal = document.getElementById('btn-change-password');
        const currentPwInput = document.getElementById('input-current-password');
        const newPwInput = document.getElementById('input-new-password');
        const confirmPwInput = document.getElementById('input-confirm-password');
        const strengthIndicator = document.getElementById('password-strength');
        const strengthBars = document.querySelectorAll('.strength-bar');
        const strengthText = document.getElementById('strength-text');

        if (!btnChangePasswordModal) {
            console.error('Change password button not found! ID: btn-change-password');
            return;
        }

        // Password strength checker
        function checkPasswordStrength(password) {
            if (!password) return { score: 0, text: '', color: '' };

            let score = 0;
            const feedback = [];

            // Length check
            if (password.length >= 8) score++;
            else feedback.push('8+ characters');

            // Uppercase check
            if (/[A-Z]/.test(password)) score++;
            else feedback.push('uppercase letter');

            // Lowercase check
            if (/[a-z]/.test(password)) score++;
            else feedback.push('lowercase letter');

            // Number check
            if (/\d/.test(password)) score++;
            else feedback.push('number');

            // Special character check
            if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) score++;
            else feedback.push('special character');

            const strength = ['Very Weak', 'Weak', 'Fair', 'Good', 'Strong'][Math.min(score, 4)];
            const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#10b981'];

            return {
                score,
                text: feedback.length ? `Add: ${feedback.join(', ')}` : strength,
                color: colors[Math.min(score, 4)],
                strength,
            };
        }

        // Real-time password strength checking
        newPwInput?.addEventListener('input', e => {
            const password = e.target.value;

            if (password) {
                strengthIndicator.style.display = 'block';
                const result = checkPasswordStrength(password);

                // Update strength bars
                strengthBars.forEach((bar, index) => {
                    if (index < result.score) {
                        bar.style.background = result.color;
                    } else {
                        bar.style.background = 'rgba(255,255,255,0.1)';
                    }
                });

                // Update text
                strengthText.textContent = result.text;
                strengthText.style.color = result.color;

                // Update input border
                e.target.style.borderColor =
                    result.score >= 3
                        ? 'var(--color-success)'
                        : result.score >= 2
                          ? 'var(--color-warning)'
                          : 'var(--color-error)';
            } else {
                strengthIndicator.style.display = 'none';
                e.target.style.borderColor = 'rgba(255,255,255,0.1)';
            }

            // Also check password matching when new password changes
            checkPasswordMatch();
        });

        // Function to check password matching
        function checkPasswordMatch() {
            const newPassword = newPwInput?.value || '';
            const confirmPassword = confirmPwInput?.value || '';

            if (confirmPassword) {
                if (newPassword === confirmPassword) {
                    confirmPwInput.style.borderColor = 'var(--color-success)';
                    // Add a small checkmark indicator
                    if (
                        !confirmPwInput.nextElementSibling ||
                        !confirmPwInput.nextElementSibling.classList.contains(
                            'password-match-indicator'
                        )
                    ) {
                        const indicator = document.createElement('div');
                        indicator.className = 'password-match-indicator';
                        indicator.style.cssText = `
                            position: absolute;
                            right: 12px;
                            top: 50%;
                            transform: translateY(-50%);
                            color: var(--color-success);
                            font-size: 14px;
                            pointer-events: none;
                        `;
                        indicator.innerHTML = '<i class="fas fa-check-circle"></i>';
                        confirmPwInput.parentElement.style.position = 'relative';
                        confirmPwInput.parentElement.appendChild(indicator);
                    }
                } else {
                    confirmPwInput.style.borderColor = 'var(--color-error)';
                    // Remove checkmark if it exists
                    const indicator = confirmPwInput.parentElement.querySelector(
                        '.password-match-indicator'
                    );
                    if (indicator) indicator.remove();
                }
            } else {
                confirmPwInput.style.borderColor = 'rgba(255,255,255,0.1)';
                // Remove checkmark if it exists
                const indicator = confirmPwInput.parentElement.querySelector(
                    '.password-match-indicator'
                );
                if (indicator) indicator.remove();
            }
        }

        // Real-time confirm password checking
        confirmPwInput?.addEventListener('input', () => {
            checkPasswordMatch();
        });

        // Enter key support
        [currentPwInput, newPwInput, confirmPwInput].forEach(input => {
            input?.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    btnChangePasswordModal?.click();
                }
            });
        });

        ensureSpinner(btnChangePasswordModal);

        // Remove any existing event listeners to prevent duplicates
        const newButton = btnChangePasswordModal.cloneNode(true);
        btnChangePasswordModal.parentNode.replaceChild(newButton, btnChangePasswordModal);
        const btnChangePasswordModalClean = document.getElementById('btn-change-password');
        ensureSpinner(btnChangePasswordModalClean);

        btnChangePasswordModalClean.addEventListener('click', async _event => {
            try {
                // Prevent multiple submissions
                if (btnChangePasswordModalClean.disabled) {
                    return;
                }

                // Debug: Event object and status element checks

                const statusEl = document.getElementById('password-status');
                // Debug: Status element found check

                const currentPassword = currentPwInput?.value || '';
                const newPassword = newPwInput?.value || '';
                const confirmPassword = confirmPwInput?.value || '';

                // Debug: Password values validation
                // current: currentPassword ? `has value (${currentPassword.length} chars)` : 'empty',
                // new: newPassword ? `has value (${newPassword.length} chars)` : 'empty',
                // confirm: confirmPassword ? `has value (${confirmPassword.length} chars)` : 'empty'

                // Clear status
                if (statusEl) {
                    statusEl.style.display = 'none';
                    statusEl.className = 'status-message';
                }

                // Validate inputs
                if (!currentPassword || !newPassword || !confirmPassword) {
                    // Validation failed: missing fields
                    if (statusEl) {
                        statusEl.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <i class="fas fa-exclamation-triangle" style="color: var(--color-error);"></i>
                                <span>Please fill in all password fields</span>
                            </div>
                        `;
                        statusEl.className = 'status-message error';
                        statusEl.style.display = 'block';
                    }
                    return;
                }

                if (newPassword !== confirmPassword) {
                    // Validation failed: passwords do not match
                    if (statusEl) {
                        statusEl.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <i class="fas fa-times-circle" style="color: var(--color-error);"></i>
                                <span>New passwords do not match</span>
                            </div>
                        `;
                        statusEl.className = 'status-message error';
                        statusEl.style.display = 'block';
                    }
                    return;
                }

                const strengthResult = checkPasswordStrength(newPassword);
                // Password strength check result: strengthResult
                if (strengthResult.score < 2) {
                    // Validation failed: password too weak
                    if (statusEl) {
                        statusEl.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <i class="fas fa-shield-alt" style="color: var(--color-warning);"></i>
                                <span>Please choose a stronger password</span>
                            </div>
                        `;
                        statusEl.className = 'status-message error';
                        statusEl.style.display = 'block';
                    }
                    return;
                }

                // All validations passed, making API call...
                btnChangePasswordModalClean.classList.add('btn-loading');
                btnChangePasswordModalClean.disabled = true;

                const requestBody = {
                    currentPassword,
                    newPassword,
                    confirmPassword: confirmPassword,
                };
                // Request body (passwords masked): currentPassword, newPassword, confirmPassword

                const response = await fetch('/api/admin/change-password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(requestBody),
                });

                // API response status: response.status
                const result = await response.json();
                // API response data: result

                if (response.ok) {
                    // Password change successful
                    if (statusEl) {
                        statusEl.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <i class="fas fa-check-circle" style="color: var(--color-success);"></i>
                                <span>Password changed successfully! You will be logged out for security.</span>
                            </div>
                        `;
                        statusEl.className = 'status-message success';
                        statusEl.style.display = 'block';
                    }

                    // Clear form
                    if (currentPwInput) currentPwInput.value = '';
                    if (newPwInput) newPwInput.value = '';
                    if (confirmPwInput) confirmPwInput.value = '';
                    if (strengthIndicator) strengthIndicator.style.display = 'none';

                    // Reset input borders
                    [currentPwInput, newPwInput, confirmPwInput].forEach(input => {
                        if (input) input.style.borderColor = 'rgba(255,255,255,0.1)';
                    });

                    // Show success message longer and redirect to login
                    setTimeout(() => {
                        closeModal('modal-change-password');
                        if (statusEl) statusEl.style.display = 'none';
                        // Redirect to login page since user is logged out
                        window.location.href = '/admin';
                    }, 3000); // Increased to 3 seconds

                    if (window.notify?.toast) {
                        window.notify.toast({
                            type: 'success',
                            title: 'Password Changed',
                            message: 'Your password has been updated successfully',
                            duration: 3000,
                        });
                    }
                } else {
                    // Password change failed: result
                    if (statusEl) {
                        statusEl.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <i class="fas fa-exclamation-circle" style="color: var(--color-error);"></i>
                                <span>${result.error || 'Failed to change password'}</span>
                            </div>
                        `;
                        statusEl.className = 'status-message error';
                        statusEl.style.display = 'block';
                    }
                }
            } catch (error) {
                console.error('MAJOR ERROR in change password handler:', error);
                console.error('Error stack:', error.stack);

                const statusEl = document.getElementById('password-status');
                if (statusEl) {
                    statusEl.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-wifi" style="color: var(--color-error);"></i>
                            <span>An error occurred: ${error.message}</span>
                        </div>
                    `;
                    statusEl.className = 'status-message error';
                    statusEl.style.display = 'block';
                }
            } finally {
                btnChangePasswordModalClean.classList.remove('btn-loading');
                btnChangePasswordModalClean.disabled = false;
            }
        });

        // Also add a manual test data flag
        if (btnChangePasswordModal) {
            btnChangePasswordModal.setAttribute('data-debug', 'ready');
        }

        // API key management
        const btnApiGenerate = document.getElementById('generate-api-key-button');
        const btnApiRevoke = document.getElementById('revoke-api-key-button');
        ensureSpinner(btnApiGenerate);
        ensureSpinner(btnApiRevoke);
        const btnApiToggle = document.getElementById('toggle-api-key-visibility-button');
        const btnApiCopy = document.getElementById('copy-api-key-button');
        btnApiGenerate?.addEventListener('click', async () => {
            try {
                btnApiGenerate.classList.add('btn-loading');
                const r = await fetch('/api/admin/api-key/generate', {
                    method: 'POST',
                    credentials: 'include',
                });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j?.error || 'Failed to generate API key');
                const input = document.getElementById('api-key-input');
                if (input) input.value = j.apiKey || '';
                window.notify?.toast({
                    type: 'success',
                    title: 'API key generated',
                    message: 'Copy and store this key securely.',
                    duration: 5000,
                });
                await refreshSecurity();
                await refreshApiKeyStatus(); // Also refresh in Operations section
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Generate failed',
                    message: e?.message || 'Unable to generate key',
                    duration: 5000,
                });
            } finally {
                btnApiGenerate.classList.remove('btn-loading');
            }
        });
        btnApiRevoke?.addEventListener('click', () => openModal('modal-revoke-api-key'));
        const btnApiRevokeConfirm = document.getElementById('btn-revoke-api-key-confirm');
        btnApiRevokeConfirm?.addEventListener('click', async () => {
            try {
                btnApiRevokeConfirm.classList.add('btn-loading');
                const r = await fetch('/api/admin/api-key/revoke', {
                    method: 'POST',
                    credentials: 'include',
                });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j?.error || 'Failed to revoke API key');
                window.notify?.toast({
                    type: 'success',
                    title: 'API key revoked',
                    message: 'Key has been removed.',
                    duration: 3500,
                });
                closeModal('modal-revoke-api-key');
                await refreshSecurity();
                await refreshApiKeyStatus(); // Also refresh in Operations section
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Revoke failed',
                    message: e?.message || 'Unable to revoke key',
                    duration: 5000,
                });
            } finally {
                btnApiRevokeConfirm.classList.remove('btn-loading');
            }
        });
        btnApiToggle?.addEventListener('click', () => {
            const input = document.getElementById('api-key-input');
            if (!input) return;
            const icon = btnApiToggle.querySelector('i');
            const toText = input.type === 'password';
            input.type = toText ? 'text' : 'password';
            if (icon) icon.className = toText ? 'fas fa-eye-slash' : 'fas fa-eye';
        });
        btnApiCopy?.addEventListener('click', async () => {
            const input = document.getElementById('api-key-input');
            if (!input || !input.value) return;
            try {
                await navigator.clipboard.writeText(input.value);
                window.notify?.toast({
                    type: 'success',
                    title: 'Copied',
                    message: 'API key copied to clipboard',
                    duration: 2000,
                });
            } catch (_) {
                window.notify?.toast({
                    type: 'warning',
                    title: 'Clipboard blocked',
                    message: 'Copy not permitted in this context',
                    duration: 2500,
                });
            }
        });

        // OPERATIONS: Refresh Media
        const btnRefreshMedia = document.getElementById('btn-refresh-media');
        if (btnRefreshMedia) {
            if (!btnRefreshMedia.querySelector('.spinner')) {
                const sp = document.createElement('span');
                sp.className = 'spinner';
                btnRefreshMedia.insertBefore(sp, btnRefreshMedia.firstChild);
            }
            btnRefreshMedia.addEventListener('click', async () => {
                try {
                    btnRefreshMedia.classList.add('btn-loading');
                    const r = await fetch('/api/admin/refresh-media', {
                        method: 'POST',
                        credentials: 'include',
                    });
                    const j = await r.json().catch(() => ({}));
                    if (!r.ok) throw new Error(j?.error || 'Refresh failed');
                    window.notify?.toast({
                        type: 'success',
                        title: 'Media refreshed',
                        message: j?.message || 'Sources reloaded',
                        duration: 3500,
                    });
                    // Update "Last sync" values on the Media Sources overview immediately
                    try {
                        await refreshOverviewLastSync();
                    } catch (_) {
                        /* non-fatal */
                    }
                } catch (e) {
                    window.notify?.toast({
                        type: 'error',
                        title: 'Refresh failed',
                        message: e?.message || 'Unable to refresh media',
                        duration: 5000,
                    });
                } finally {
                    btnRefreshMedia.classList.remove('btn-loading');
                }
            });
        }

        // OPERATIONS: Auto-Update controls
        const btnStartUpdate = document.getElementById('btn-start-update');
        const btnRollbackUpdate = document.getElementById('btn-rollback-update');
        const btnListBackups = document.getElementById('btn-list-backups');
        const btnCleanupBackups = document.getElementById('btn-cleanup-backups');

        const ensureBtnSpinner = btn => {
            if (!btn) return;
            if (!btn.querySelector('.spinner')) {
                const sp = document.createElement('span');
                sp.className = 'spinner';
                btn.insertBefore(sp, btn.firstChild);
            }
        };
        [btnStartUpdate, btnRollbackUpdate, btnListBackups, btnCleanupBackups].forEach(
            ensureBtnSpinner
        );

        async function pollUpdateStatusOnce() {
            try {
                const r = await fetch('/api/admin/update/status', { credentials: 'include' });
                if (!r.ok) throw new Error('Status failed');
                const s = await r.json();
                applyUpdateStatusToUI(s);
                return s;
            } catch (e) {
                // Non-fatal; keep idle
                return null;
            }
        }

        let updatePollTimer = null;
        function startUpdatePolling() {
            stopUpdatePolling();
            updatePollTimer = setInterval(pollUpdateStatusOnce, 1500);
        }
        function stopUpdatePolling() {
            if (updatePollTimer) {
                clearInterval(updatePollTimer);
                updatePollTimer = null;
            }
        }

        function applyUpdateStatusToUI(status) {
            const idle = document.getElementById('update-idle-state');
            const prog = document.getElementById('update-progress-state');
            if (!idle || !prog) return;
            const phaseEl = document.getElementById('update-phase-text');
            const pctEl = document.getElementById('update-progress-percent');
            const idlePill = document.getElementById('update-idle-pill');
            const barEl = document.getElementById('update-progress-bar');
            const msgEl = document.getElementById('update-message');
            const isUpdating = !!status?.isUpdating;
            if (isUpdating) {
                idle.style.display = 'none';
                prog.style.display = '';
                if (idlePill) idlePill.style.display = 'none';
                if (phaseEl) phaseEl.style.display = '';
                if (pctEl) pctEl.style.display = '';
                const phase = status?.phase || 'working';
                const pct = Math.max(0, Math.min(100, Number(status?.progress ?? 0)));
                if (phaseEl) phaseEl.textContent = String(phase);
                if (pctEl) pctEl.textContent = pct + '%';
                if (barEl) barEl.style.width = pct + '%';
                if (msgEl) msgEl.textContent = status?.message || '';
                startUpdatePolling();
            } else {
                prog.style.display = 'none';
                idle.style.display = '';
                if (idlePill) idlePill.style.display = '';
                if (phaseEl) phaseEl.style.display = 'none';
                if (pctEl) pctEl.style.display = 'none';
                stopUpdatePolling();
            }
        }

        async function refreshUpdateStatusUI() {
            const s = await pollUpdateStatusOnce();
            if (!s || !s.isUpdating) stopUpdatePolling();
        }

        btnStartUpdate?.addEventListener('click', async () => {
            // Open confirmation modal like legacy Management
            await openUpdateModal();
        });

        btnRollbackUpdate?.addEventListener('click', async () => {
            try {
                btnRollbackUpdate.classList.add('btn-loading');
                const r = await fetch('/api/admin/update/rollback', {
                    method: 'POST',
                    credentials: 'include',
                });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j?.error || 'Rollback failed');
                window.notify?.toast({
                    type: 'success',
                    title: 'Rollback complete',
                    message: j?.message || 'Application rolled back',
                    duration: 4000,
                });
                await refreshUpdateStatusUI();
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Rollback failed',
                    message: e?.message || 'Unable to rollback',
                    duration: 5000,
                });
            } finally {
                btnRollbackUpdate.classList.remove('btn-loading');
            }
        });

        btnListBackups?.addEventListener('click', async () => {
            const container = document.getElementById('backups-display');
            const list = document.getElementById('backups-content');
            if (!container || !list) return;
            container.style.display = '';
            list.innerHTML = '<div class="subtle">Loading…</div>';
            try {
                const r = await fetch('/api/admin/update/backups', { credentials: 'include' });
                const arr = r.ok ? await r.json() : [];
                if (!Array.isArray(arr) || arr.length === 0) {
                    list.innerHTML = '<div class="subtle">No backups available</div>';
                    return;
                }
                list.innerHTML = '';
                arr.forEach(b => {
                    const row = document.createElement('div');
                    row.className = 'chip';
                    row.innerHTML = `<div class="left"><i class="fas fa-archive"></i><span class="title">${b.name || b.version || 'Backup'}</span></div><span class="subtle">${(b.created || b.timestamp || '').toString()}</span>`;
                    list.appendChild(row);
                });
            } catch (e) {
                list.innerHTML = '<div class="subtle">Failed to load backups</div>';
            }
        });

        btnCleanupBackups?.addEventListener('click', async () => {
            const keepEl = document.getElementById('input-keep-backups');
            const keepCount = Math.max(1, Math.min(20, Number(keepEl?.value || 5)));
            try {
                btnCleanupBackups.classList.add('btn-loading');
                const r = await fetch('/api/admin/update/cleanup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ keepCount }),
                    credentials: 'include',
                });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j?.error || 'Cleanup failed');
                window.notify?.toast({
                    type: 'success',
                    title: 'Cleanup completed',
                    message: j?.message || `Kept ${j?.kept ?? keepCount}`,
                    duration: 4000,
                });
                // refresh list
                document.getElementById('btn-list-backups')?.click();
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Cleanup failed',
                    message: e?.message || 'Unable to cleanup backups',
                    duration: 5000,
                });
            } finally {
                btnCleanupBackups.classList.remove('btn-loading');
            }
        });

        // Initial population if Operations is default later
        if (document.getElementById('section-operations')?.classList.contains('active')) {
            refreshOperationsPanels();
        }
    }

    // exportMetrics removed with header Export button

    async function refreshAll() {
        await Promise.all([refreshDevices(), refreshPerfDashboard(), refreshVersionAndUpdate()]);
        await refreshCacheStatsV2();
    }

    // Initialize cache actions and kick off initial refreshes
    wireCacheActions();
    refreshAll();
    // Fallback: ensure Devices section gets initialized even if user lands directly
    try {
        window.admin2?.initDevices?.();
    } catch (_) {
        /* initial devices init on load failed (user can trigger manually) */
    }
    // If dashboard is the active tab on load, start live updates
    try {
        const dashEl = document.getElementById('section-dashboard');
        const isDash = !!dashEl && dashEl.classList.contains('active');
        if (isDash) {
            startDashboardLive();
            startPerfLive();
        }
    } catch (_) {
        /* no-op */
    }
    // Pause/resume polling when the tab/window visibility changes
    try {
        document.addEventListener('visibilitychange', () => {
            const isHidden = document.visibilityState === 'hidden';
            if (isHidden) {
                stopDashboardLive();
                stopPerfLive();
            } else {
                const isDashActive = document
                    .getElementById('section-dashboard')
                    ?.classList.contains('active');
                if (isDashActive) {
                    startDashboardLive();
                    startPerfLive();
                }
            }
        });
    } catch (_) {
        /* ignore */
    }

    // Wire only the dashboard metric numbers (kept isolated so failures elsewhere don't block it)
    function wireDashboardMetricShortcuts() {
        try {
            const makeClickable = (id, handler, title) => {
                const el = document.getElementById(id);
                if (!el || el.dataset.wired === 'true') return;
                el.dataset.wired = 'true';
                el.tabIndex = 0;
                el.setAttribute('role', 'button');
                if (title) el.setAttribute('title', title);
                el.style.cursor = 'pointer';
                const onActivate = evt => {
                    evt.preventDefault();
                    handler();
                };
                el.addEventListener('click', onActivate);
                el.addEventListener('keydown', e => {
                    if (e.key === 'Enter' || e.key === ' ') onActivate(e);
                });
            };

            makeClickable(
                'metric-active-devices',
                () => {
                    try {
                        showSection('section-devices');
                        window.admin2?.initDevices?.();
                        setTimeout(() => {
                            try {
                                const state = window.admin2?.devicesDebug?.state;
                                if (state) {
                                    state.filterStatus = 'active';
                                    state.filterRoom = null;
                                    state.query = '';
                                }
                                window.admin2?.devicesDebug?.render?.();
                            } catch (_) {
                                /* active devices metric filter apply failed (non-critical) */
                            }
                        }, 0);
                    } catch (_) {
                        /* active devices metric navigation failed (user can navigate manually) */
                    }
                },
                'View active devices'
            );

            makeClickable(
                'metric-offline-devices',
                () => {
                    try {
                        showSection('section-devices');
                        window.admin2?.initDevices?.();
                        setTimeout(() => {
                            try {
                                const state = window.admin2?.devicesDebug?.state;
                                if (state) {
                                    state.filterStatus = 'offline';
                                    state.filterRoom = null;
                                    state.query = '';
                                }
                                window.admin2?.devicesDebug?.render?.();
                            } catch (_) {
                                /* offline devices metric filter apply failed (non-critical) */
                            }
                        }, 0);
                    } catch (_) {
                        /* offline devices metric navigation failed (user can navigate manually) */
                    }
                },
                'View offline devices'
            );

            makeClickable(
                'metric-media-items',
                () => {
                    try {
                        showSection('section-media-sources');
                        const section = document.getElementById('section-media-sources');
                        if (section) {
                            section
                                .querySelectorAll('section.panel')
                                .forEach(p => (p.hidden = p.id !== 'panel-sources-overview'));
                        }
                    } catch (_) {
                        /* media sources overview navigation failed (fallback: no section switch) */
                    }
                },
                'View media sources overview'
            );

            makeClickable(
                'metric-mode',
                () => {
                    try {
                        showSection('section-display');
                        // Ensure the display section is initialized and mode badges reflect state
                        if (!window.__displayInit) {
                            // Lazy init if available
                            try {
                                window.admin2?.initDisplaySection?.();
                            } catch (_) {
                                /* display section lazy init failed (user may open manually) */
                            }
                        }
                    } catch (_) {
                        /* display settings metric navigation failed (ignored) */
                    }
                },
                'Open Display settings'
            );
        } catch (_) {
            /* isolated wiring: do not throw */
        }
    }

    // Update confirmation modal (theme-demo style)
    async function openUpdateModal() {
        const overlay = document.getElementById('modal-update');
        const content = document.getElementById('modal-update-content');
        const btnConfirm = document.getElementById('btn-update-confirm');
        const btnForce = document.getElementById('btn-update-force');
        if (!overlay || !content || !btnConfirm) return;
        btnConfirm.disabled = true;
        btnForce.style.display = 'none';
        content.innerHTML = '<div class="subtle">Loading update information…</div>';
        __showOverlay(overlay, 'modal-update');
        try {
            if (window.__uiDebug)
                console.info(
                    '[ModalDebug] openUpdateModal overlay rect',
                    overlay.getBoundingClientRect().toJSON()
                );
        } catch (_) {
            /* clock rows re-display failed (non-fatal cosmetic) */
        }

        try {
            const r = await fetch('/api/admin/update-check', { credentials: 'include' });
            const j = r.ok ? await r.json() : null;
            const hasUpdate = !!j?.hasUpdate;
            const current = j?.currentVersion || '—';
            const latest = j?.latestVersion || '—';
            const notes = j?.releaseNotes;
            if (!hasUpdate) {
                content.innerHTML = `
                                    <div class="update-status-ok">
                                        <i class="fas fa-check-circle"></i>
                                        <div>Already up to date (v${current})</div>
                                    </div>
                                    <div class="update-repair-box">
                                        <div class="title"><i class="fas fa-hammer"></i> Repair / Force Reinstall</div>
                                        <div class="subtle">Use Force Update to repair your installation even if you're on the latest version.</div>
                                    </div>`;
                btnConfirm.disabled = true;
                btnConfirm.querySelector('span').textContent = 'No Update Needed';
                btnForce.style.display = '';
            } else {
                content.innerHTML = `
                                    <div class="update-grid">
                                        <div class="update-box">
                                            <div class="subtle">Current</div>
                                            <div class="version">v${current}</div>
                                        </div>
                                        <div class="update-box update-box-available">
                                            <div class="available-label">Available</div>
                                            <div class="version">v${latest}</div>
                                        </div>
                                    </div>
                                    ${notes ? `<div class="release-notes"><div class="subtle heading">Release notes</div><div class="notes-content">${notes}</div></div>` : ''}
                                `;
                btnConfirm.disabled = false;
                btnConfirm.querySelector('span').textContent = `Update to v${latest}`;
                btnForce.style.display = '';
            }

            // Wire buttons one-time per open
            // Reset buttons to clear prior listeners
            btnConfirm.replaceWith(btnConfirm.cloneNode(true));
            btnForce.replaceWith(btnForce.cloneNode(true));
            const freshConfirm = document.getElementById('btn-update-confirm');
            const freshForce = document.getElementById('btn-update-force');
            freshConfirm?.addEventListener(
                'click',
                async () => {
                    await startUpdate(false);
                },
                { once: true }
            );
            freshForce?.addEventListener(
                'click',
                async () => {
                    await startUpdate(true);
                },
                { once: true }
            );
        } catch (e) {
            content.innerHTML = '<div class="subtle">Failed to load update info</div>';
            btnConfirm.disabled = true;
        }
    }

    async function startUpdate(force = false) {
        const btn = document.getElementById(force ? 'btn-update-force' : 'btn-update-confirm');
        const overlay = document.getElementById('modal-update');
        try {
            btn?.classList.add('btn-loading');
            const r = await fetch('/api/admin/update/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ force }),
                credentials: 'include',
            });
            const j = await r.json().catch(() => ({}));
            if (!r.ok) throw new Error(j?.error || 'Failed to start update');
            overlay?.classList.remove('open');
            try {
                overlay?.setAttribute('aria-hidden', 'true');
            } catch (_) {
                /* aria-hidden attribute sync failed (modal accessibility may be stale) */
            }
            window.notify?.toast({
                type: 'info',
                title: 'Updating…',
                message: j?.message || 'Auto-update started',
                duration: 0,
            });
            // Begin polling status; UI hook will pick it up
            // eslint-disable-next-line no-undef
            await pollUpdateStatusOnce();
        } catch (e) {
            window.notify?.toast({
                type: 'error',
                title: 'Update failed',
                message: e?.message || 'Unable to start update',
                duration: 5000,
            });
        } finally {
            btn?.classList.remove('btn-loading');
        }
    }

    // Server Settings + Promobox save + Media Sources wiring
    document.addEventListener('DOMContentLoaded', () => {
        // Ensure all interactive UI handlers (including sidebar nav) are wired
        try {
            typeof wireEvents === 'function' && wireEvents();
        } catch (e) {
            try {
                console.warn('wireEvents() init failed', e);
            } catch (_) {
                /* console unavailable to warn about wireEvents failure */
            }
        }
        // Always wire dashboard metric shortcuts
        try {
            wireDashboardMetricShortcuts();
        } catch (_) {
            /* number steppers wiring failed (user can type values) */
        }
        const btnSaveServer = document.getElementById('btn-save-server-settings');
        const btnSavePromo = document.getElementById('btn-save-promobox');
        const btnSaveOps = document.getElementById('btn-save-operations');
        // Sync insecure HTTPS toggles (header and form)
        const jfInsecureForm = document.getElementById('jf.insecureHttps');
        const jfInsecureHeader = document.getElementById('jf.insecureHttpsHeader');
        if (jfInsecureForm && jfInsecureHeader) {
            const syncPair = (src, dest) => {
                if (dest && dest.checked !== src.checked) dest.checked = src.checked;
            };
            jfInsecureForm.addEventListener('change', () =>
                syncPair(jfInsecureForm, jfInsecureHeader)
            );
            jfInsecureHeader.addEventListener('change', () =>
                syncPair(jfInsecureHeader, jfInsecureForm)
            );
            // Ensure the header toggle is interactable even if label-default is blocked
            try {
                const lbl = document.querySelector(
                    'label.header-toggle[for="jf.insecureHttpsHeader"]'
                );
                if (lbl) {
                    const updateLabelState = () => {
                        lbl.classList.toggle('is-on', !!jfInsecureHeader.checked);
                    };
                    lbl.tabIndex = 0;
                    const toggle = () => {
                        jfInsecureHeader.checked = !jfInsecureHeader.checked;
                        jfInsecureHeader.dispatchEvent(new Event('change', { bubbles: true }));
                        updateLabelState();
                    };
                    // Initialize visual state
                    updateLabelState();
                    lbl.addEventListener('click', e => {
                        e.preventDefault();
                        toggle();
                    });
                    lbl.addEventListener('keydown', e => {
                        if (e.key === ' ' || e.key === 'Enter') {
                            e.preventDefault();
                            toggle();
                        }
                    });
                    // Also reflect changes coming from form checkbox
                    jfInsecureHeader.addEventListener('change', updateLabelState);
                }
            } catch (_) {
                /* jf insecure header toggle enhancement failed (basic checkbox still works) */
            }
        }
        const portInput = document.getElementById('SERVER_PORT');
        // Sync Recently header toggles with hidden form checkboxes (Plex/Jellyfin)
        try {
            const plexHeader = document.getElementById('plex.recentOnlyHeader');
            if (plexHeader) {
                plexHeader.addEventListener('change', () => {});
            }
            const jfHeader = document.getElementById('jf.recentOnlyHeader');
            if (jfHeader) {
                jfHeader.addEventListener('change', () => {});
            }
        } catch (_) {
            /* rotten tomatoes snapping setup failed (raw input accepted) */
        }

        // Helper: make header-toggle text dynamic (Enabled/Disabled)
        function attachHeaderToggleText(inputId, onText = 'Enabled', offText = 'Disabled') {
            try {
                const input = document.getElementById(inputId);
                const label = document.querySelector(`label.header-toggle[for="${inputId}"]`);
                if (!input || !label || input.dataset.htTextWired === '1') return;
                let textEl = label.querySelector('.ht-text');
                if (!textEl) {
                    textEl = document.createElement('span');
                    textEl.className = 'ht-text';
                    label.appendChild(textEl);
                }
                const apply = () => {
                    const checked = !!input.checked;
                    textEl.textContent = checked ? onText : offText;
                    label.classList.toggle('is-on', checked);
                };
                input.addEventListener('change', apply);
                apply();
                input.dataset.htTextWired = '1';
            } catch (_) {
                /* header toggle text attach failed (label remains static) */
            }
        }

        // Force update helper: update label text once without wiring
        // Assign implementation (overwrites earlier placeholder for segmented sources tabs)
        const forceUpdateHeaderToggleText = (inputId, onText = 'Enabled', offText = 'Disabled') => {
            try {
                const input = document.getElementById(inputId);
                const label = document.querySelector(`label.header-toggle[for="${inputId}"]`);
                if (!input || !label) return;
                const textEl = label.querySelector('.ht-text');
                if (!textEl) return;
                const checked = !!input.checked;
                textEl.textContent = checked ? onText : offText;
                label.classList.toggle('is-on', checked);
            } catch (_) {
                /* header toggle one-shot text update failed (cosmetic) */
            }
        };

        // Wire Enabled/Disabled text for Media Sources header toggles (and Streaming)
        try {
            attachHeaderToggleText('plex.enabled');
            attachHeaderToggleText('jf.enabled');
            attachHeaderToggleText('tmdb.enabled');
            attachHeaderToggleText('streamingSources.enabled');
        } catch (_) {
            /* poster->metadata dependency apply failed (manual toggling still works) */
        }

        // Helper to fetch config, patch minimal keys, and POST back
        async function saveConfigPatch(patchConfig, patchEnv) {
            // Only send the env keys we intend to change to avoid overwriting secrets with booleans
            const r = await fetch('/api/admin/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ config: patchConfig, env: patchEnv || {} }),
            });
            const j = await r.json().catch(() => ({}));
            if (!r.ok) throw new Error(j?.error || j?.message || 'Save failed');
            // Invalidate any cached GET of /api/admin/config so subsequent reloads see fresh data
            try {
                if (typeof miniCache?.delete === 'function')
                    miniCache.delete('/api/admin/config|GET');
                if (typeof inflight?.delete === 'function')
                    inflight.delete('/api/admin/config|GET');
            } catch (_) {
                /* media source live preview wiring failed (counts will update on manual refresh) */
            }
            return j;
        }

        try {
            if (typeof window !== 'undefined') {
                window.saveConfigPatch = saveConfigPatch;
                window.__saveConfigPatch = saveConfigPatch;
            }
        } catch (_) {
            /* ignore exposure failure */
        }

        // Helpers for Media Sources
        const getInput = id => document.getElementById(id);
        const toInt = v => {
            const n = Number(v);
            return Number.isFinite(n) ? n : undefined;
        };
        // Parse a year expression like "2010, 2011, 1998, 1910-1920" to a canonical string
        function parseYearExpression(input) {
            const raw = String(input || '').trim();
            if (!raw) return undefined;
            const parts = raw
                .split(',')
                .map(s => s.trim())
                .filter(Boolean);
            const tokens = [];
            const yearRe = /^\d{4}$/;
            const rangeRe = /^(\d{4})\s*-\s*(\d{4})$/;
            for (const p of parts) {
                const y = p.match(yearRe);
                if (y) {
                    const year = Number(y[0]);
                    if (year >= 1900) tokens.push(String(year));
                    continue;
                }
                const r = p.match(rangeRe);
                if (r) {
                    const a = Number(r[1]);
                    const b = Number(r[2]);
                    if (a >= 1900 && b >= 1900 && b >= a) tokens.push(`${a}-${b}`);
                    continue;
                }
                // ignore invalid piece
            }
            if (!tokens.length) return undefined;
            return tokens.join(', ');
        }
        function setMultiSelect(id, options, selected) {
            const sel = getInput(id);
            if (!sel) return;
            const prev = new Set(Array.from(sel.selectedOptions).map(o => o.value));
            sel.innerHTML = '';
            const chosen = new Set(selected || Array.from(prev));
            (options || []).forEach(opt => {
                const o = document.createElement('option');
                o.value = opt.value ?? opt.name ?? opt;
                o.textContent = opt.label ?? opt.name ?? String(opt);
                if (opt.count != null) o.textContent += ` (${opt.count})`;
                if (chosen.has(o.value)) o.selected = true;
                sel.appendChild(o);
            });
        }
        function getMultiSelectValues(id) {
            const sel = getInput(id);
            if (!sel) return [];
            return Array.from(sel.selectedOptions).map(o => o.value);
        }
        function parseCsvList(str) {
            return String(str || '')
                .split(',')
                .map(s => s.trim())
                .filter(Boolean);
        }

        // ----- Media Sources Overview (cards) -----
        // Update a single card's dot/pill status
        function setCardStatus(prefix, { enabled, configured, pillText }) {
            try {
                const dot = document.getElementById(`${prefix}-dot`);
                const pill = document.getElementById(`${prefix}-pill`);
                const cls = !enabled ? 'error' : configured ? 'success' : 'warning';
                if (dot) {
                    dot.classList.remove('status-success', 'status-warning', 'status-error');
                    dot.classList.add(`status-${cls}`);
                }
                if (pill) {
                    pill.textContent =
                        pillText ||
                        (configured ? 'Configured' : enabled ? 'Not configured' : 'Disabled');
                    pill.classList.remove('status-success', 'status-warning', 'status-error');
                    pill.classList.add(`status-${cls}`);
                }
            } catch (_) {
                /* setCardStatus UI update failed (non-fatal cosmetic) */
            }
        }

        async function patchSourceEnabled(sourceKey, enabled) {
            try {
                const cfgRes = await window.dedupJSON('/api/admin/config', {
                    credentials: 'include',
                });
                const base = cfgRes.ok ? await cfgRes.json() : {};
                const currentCfg = base?.config || base || {};
                const envPatch = {}; // no env changes for toggle
                // Capture previous enabled state to decide on restart
                const prev = (() => {
                    try {
                        if (sourceKey === 'plex' || sourceKey === 'jellyfin') {
                            const servers = Array.isArray(currentCfg.mediaServers)
                                ? currentCfg.mediaServers
                                : [];
                            const s = servers.find(x => x?.type === sourceKey) || {};
                            return !!s.enabled;
                        }
                        if (sourceKey === 'tmdb') {
                            return !!(currentCfg.tmdbSource && currentCfg.tmdbSource.enabled);
                        }
                    } catch (_) {
                        /* previous enabled state detection failed (restart decision may be skipped) */
                    }
                    return undefined;
                })();

                if (sourceKey === 'plex' || sourceKey === 'jellyfin') {
                    const servers = Array.isArray(currentCfg.mediaServers)
                        ? [...currentCfg.mediaServers]
                        : [];
                    const idx = servers.findIndex(s => s?.type === sourceKey);
                    const s = idx >= 0 ? { ...servers[idx] } : { type: sourceKey };
                    s.enabled = !!enabled;
                    if (idx >= 0) servers[idx] = s;
                    else servers.push(s);
                    await saveConfigPatch({ mediaServers: servers }, envPatch);
                } else if (sourceKey === 'tmdb') {
                    const tmdb = { ...(currentCfg.tmdbSource || {}) };
                    tmdb.enabled = !!enabled;
                    await saveConfigPatch({ tmdbSource: tmdb }, envPatch);
                }
                window.notify?.toast({
                    type: 'success',
                    title: 'Saved',
                    message: `${sourceKey.toUpperCase()} ${enabled ? 'enabled' : 'disabled'}`,
                    duration: 1800,
                });
                // Sync main form toggle state marker if present
                try {
                    const mirrorId =
                        sourceKey === 'plex'
                            ? 'plex.enabled'
                            : sourceKey === 'jellyfin'
                              ? 'jf.enabled'
                              : null;
                    if (mirrorId) {
                        const m = document.getElementById(mirrorId);
                        if (m) {
                            m.checked = !!enabled;
                            m.dataset.originalEnabled = enabled ? 'true' : 'false';
                            if (typeof updateSourceSaveButtonLabel === 'function') {
                                updateSourceSaveButtonLabel(sourceKey);
                            }
                        }
                    }
                } catch (_) {
                    /* source mirror toggle sync failed (form state may be out of date) */
                }
                // Restart app when toggled on/off (only if state changed where detectable)
                try {
                    const shouldRestart = typeof prev === 'boolean' ? prev !== !!enabled : true;
                    if (shouldRestart) {
                        window.notify?.toast({
                            type: 'info',
                            title: 'Restarting…',
                            message: 'Applying source changes and restarting.',
                            duration: 0,
                        });
                        await fetch('/api/admin/restart-app', {
                            method: 'POST',
                            credentials: 'include',
                        }).catch(() => {});
                    }
                } catch (_) {
                    /* mirror toggle state sync failed (overview) */
                }
                return true;
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Save failed',
                    message: e?.message || 'Unable to save setting',
                    duration: 4200,
                });
                return false;
            }
        }

        function wireToggleOnce(id, handler) {
            const el = document.getElementById(id);
            if (!el || el.dataset.wired === 'true') return;
            el.addEventListener('change', handler);
            el.dataset.wired = 'true';
        }

        function updateOverviewCards(cfg, env) {
            try {
                // Prefer shared compute module if present (window global or CommonJS loaded earlier), fallback to inline quick calc.
                let statuses;
                const compute = window.__adminOverviewCompute?.computeOverviewStatuses;
                if (typeof compute === 'function') {
                    statuses = compute(cfg, env);
                } else {
                    const mediaServers = Array.isArray(cfg?.mediaServers) ? cfg.mediaServers : [];
                    const plex = mediaServers.find(s => s?.type === 'plex') || {};
                    const jf = mediaServers.find(s => s?.type === 'jellyfin') || {};
                    const tmdb = cfg?.tmdbSource || {};
                    const basic = (enabled, configured) => ({
                        enabled: !!enabled,
                        configured: !!configured,
                        pillText: !enabled
                            ? 'Disabled'
                            : configured
                              ? 'Configured'
                              : 'Not configured',
                    });
                    statuses = {
                        plex: basic(
                            plex.enabled,
                            plex.hostname && plex.port && env[plex.tokenEnvVar || 'PLEX_TOKEN']
                        ),
                        jellyfin: basic(
                            jf.enabled,
                            jf.hostname && jf.port && env[jf.tokenEnvVar || 'JELLYFIN_API_KEY']
                        ),
                        tmdb: basic(
                            tmdb.enabled,
                            tmdb.apiKey || env[tmdb.apiKeyEnvVar || 'TMDB_API_KEY']
                        ),
                    };
                }

                const { plex = {}, jellyfin = {}, tmdb = {} } = statuses || {};

                // PLEX card + libs
                try {
                    setCardStatus('sc-plex', plex);
                    const plexServer =
                        (Array.isArray(cfg?.mediaServers) ? cfg.mediaServers : []).find(
                            s => s?.type === 'plex'
                        ) || {};
                    const libMovie = Array.isArray(plexServer.movieLibraryNames)
                        ? plexServer.movieLibraryNames.length
                        : 0;
                    const libShow = Array.isArray(plexServer.showLibraryNames)
                        ? plexServer.showLibraryNames.length
                        : 0;
                    const libsEl = document.getElementById('sc-plex-libs');
                    if (libsEl) {
                        const v = libsEl.querySelector('.value');
                        if (v) v.textContent = `${libMovie + libShow}`;
                        libsEl.title = `Libraries selected: Movies ${libMovie}, Shows ${libShow}`;
                    }
                    const tgl = document.getElementById('sc.plex.enabled');
                    if (tgl) tgl.checked = !!plex.enabled;
                    wireToggleOnce('sc.plex.enabled', async e => {
                        const el = e.currentTarget;
                        el.disabled = true;
                        const ok = await patchSourceEnabled('plex', !!el.checked);
                        if (!ok) el.checked = !el.checked;
                        el.disabled = false;
                        const mirror = document.getElementById('plex.enabled');
                        if (mirror) mirror.checked = el.checked;
                        loadMediaSources(true).catch(() => {});
                    });
                } catch (_) {
                    /* mirror toggle state sync failed (overview) */
                }

                // JELLYFIN card + libs
                try {
                    setCardStatus('sc-jf', jellyfin);
                    const jfServer =
                        (Array.isArray(cfg?.mediaServers) ? cfg.mediaServers : []).find(
                            s => s?.type === 'jellyfin'
                        ) || {};
                    const libMovie = Array.isArray(jfServer.movieLibraryNames)
                        ? jfServer.movieLibraryNames.length
                        : 0;
                    const libShow = Array.isArray(jfServer.showLibraryNames)
                        ? jfServer.showLibraryNames.length
                        : 0;
                    const libsEl = document.getElementById('sc-jf-libs');
                    if (libsEl) {
                        const v = libsEl.querySelector('.value');
                        if (v) v.textContent = `${libMovie + libShow}`;
                        libsEl.title = `Libraries selected: Movies ${libMovie}, Shows ${libShow}`;
                    }
                    const tgl = document.getElementById('sc.jf.enabled');
                    if (tgl) tgl.checked = !!jellyfin.enabled;
                    wireToggleOnce('sc.jf.enabled', async e => {
                        const el = e.currentTarget;
                        el.disabled = true;
                        const ok = await patchSourceEnabled('jellyfin', !!el.checked);
                        if (!ok) el.checked = !el.checked;
                        el.disabled = false;
                        const mirror = document.getElementById('jf.enabled');
                        if (mirror) mirror.checked = el.checked;
                        loadMediaSources(true).catch(() => {});
                    });
                } catch (_) {
                    /* mirror toggle state sync failed (overview) */
                }

                // TMDB card + category
                try {
                    setCardStatus('sc-tmdb', tmdb);
                    const tmdbCfg = cfg?.tmdbSource || {};
                    const modeEl = document.getElementById('sc-tmdb-mode');
                    if (modeEl) {
                        const v = modeEl.querySelector('.value');
                        if (v) v.textContent = `${tmdbCfg.category || 'popular'}`;
                        modeEl.title = `Category: ${tmdbCfg.category || 'popular'}`;
                    }
                    const tgl = document.getElementById('sc.tmdb.enabled');
                    if (tgl) tgl.checked = !!tmdb.enabled;
                    wireToggleOnce('sc.tmdb.enabled', async e => {
                        const el = e.currentTarget;
                        el.disabled = true;
                        const ok = await patchSourceEnabled('tmdb', !!el.checked);
                        if (!ok) el.checked = !el.checked;
                        el.disabled = false;
                        const mirror = document.getElementById('tmdb.enabled');
                        if (mirror) mirror.checked = el.checked;
                        loadMediaSources(true).catch(() => {});
                    });
                } catch (_) {
                    /* tmdb overview toggle wiring failed (fallback to form toggle) */
                }
            } catch (_) {
                /* overview card compute or UI update failed (non-fatal) */
            }
        }

        async function refreshOverviewLastSync() {
            try {
                const r = await window.dedupJSON('/api/admin/source-status', {
                    credentials: 'include',
                });
                if (!r.ok) return;
                const j = await r.json();
                const fmt = ms => {
                    if (!ms || typeof ms !== 'number') return '—';
                    const d = new Date(ms);
                    if (Number.isNaN(d.getTime())) return '—';
                    // Show relative first, with ISO title for exact time
                    const now = Date.now();
                    const diff = Math.max(0, now - ms);
                    const mins = Math.floor(diff / 60000);
                    if (mins < 1) return 'just now';
                    if (mins < 60) return `${mins} min ago`;
                    const hrs = Math.floor(mins / 60);
                    if (hrs < 24) return `${hrs} hr${hrs === 1 ? '' : 's'} ago`;
                    const days = Math.floor(hrs / 24);
                    return `${days} day${days === 1 ? '' : 's'} ago`;
                };
                const setSync = (id, ms) => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    const v = el.querySelector('.value');
                    const pretty = fmt(ms);
                    if (v) v.textContent = pretty;
                    if (ms && typeof ms === 'number') {
                        const iso = new Date(ms).toISOString();
                        el.title = `Last sync: ${pretty} (exact: ${iso})`;
                    } else {
                        el.title = 'Last sync: —';
                    }
                };
                setSync('sc-plex-sync', j?.plex?.lastFetchMs || null);
                setSync('sc-jf-sync', j?.jellyfin?.lastFetchMs || null);
                setSync('sc-tmdb-sync', j?.tmdb?.lastFetchMs || null);
            } catch (_) {
                // ignore
            }
        }

        // Simple in-memory cache for library counts to avoid spamming admin APIs
        const __libCountsCache = {
            ts: 0,
            plex: null,
            jf: null,
        };

        async function fetchLibraryCounts(kind) {
            // Normalize alias so both 'jf' and 'jellyfin' share cache
            const originalKind = kind;
            if (kind === 'jellyfin') kind = 'jf';
            const now = Date.now();
            // Reuse cache for 15s
            if (now - __libCountsCache.ts < 15000 && __libCountsCache[kind]) {
                return __libCountsCache[kind];
            }
            try {
                let res;
                if (kind === 'plex') {
                    // Use current UI values (support both dotted & legacy underscore IDs)
                    const hostname =
                        document.getElementById('plex.hostname')?.value?.trim() ||
                        document.getElementById('plex_hostname')?.value?.trim();
                    const port =
                        document.getElementById('plex.port')?.value?.trim() ||
                        document.getElementById('plex_port')?.value?.trim();
                    // Get token from dataset first (actual token), fallback to input value, then global store
                    const tokenInput =
                        document.getElementById('plex.token') ||
                        document.getElementById('plex_token');
                    const token =
                        tokenInput?.dataset?.actualToken ||
                        tokenInput?.value?.trim() ||
                        window.__tokenStore?.plexToken ||
                        undefined;
                    res = await fetch('/api/admin/plex-libraries', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            hostname: hostname || undefined,
                            port: port || undefined,
                            token: token || undefined,
                        }),
                    });
                } else if (kind === 'jf') {
                    const hostname = document.getElementById('jf.hostname')?.value?.trim();
                    const port = document.getElementById('jf.port')?.value?.trim();
                    // Get API key from dataset first (actual key), fallback to input value
                    const apiKeyInput = document.getElementById('jf.apikey');
                    let apiKey = apiKeyInput?.dataset?.actualToken || apiKeyInput?.value?.trim();
                    if (!apiKey) {
                        try {
                            const cfgRes = await window.dedupJSON('/api/admin/config', {
                                credentials: 'include',
                            });
                            if (cfgRes?.ok) {
                                const cfgJson = await cfgRes.json();
                                const servers = Array.isArray(cfgJson?.config?.mediaServers)
                                    ? cfgJson.config.mediaServers
                                    : [];
                                const jfSrv = servers.find(
                                    s => (s.type || '').toLowerCase() === 'jellyfin'
                                );
                                apiKey = jfSrv?.apiKey || jfSrv?.token || apiKey;
                            }
                        } catch (_) {
                            /* button click stopPropagation failed (minor; event may bubble) */
                        }
                    }
                    if (!hostname) return new Map();
                    if (!isJellyfinEnabledCached()) return new Map();
                    try {
                        res = await fetch('/api/admin/jellyfin-libraries', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({
                                hostname: hostname || undefined,
                                port: port || undefined,
                                apiKey: apiKey || undefined, // may be undefined; server can fallback
                            }),
                        });
                    } catch (_) {
                        return new Map();
                    }
                }
                const j = res && res.ok ? await res.json().catch(() => ({})) : {};
                const libs = Array.isArray(j.libraries) ? j.libraries : [];
                const byName = new Map();
                for (const l of libs) {
                    byName.set(l.name, { type: l.type, itemCount: Number(l.itemCount) || 0 });
                }
                __libCountsCache[kind] = byName;
                // If caller used 'jellyfin', also populate alias key for future lookups
                if (originalKind === 'jellyfin') {
                    __libCountsCache.jellyfin = byName;
                } else if (originalKind === 'jf') {
                    __libCountsCache.jellyfin = byName;
                }
                __libCountsCache.ts = now;
                return byName;
            } catch (_) {
                return new Map();
            }
        }

        function getSelectedLibraries(kind) {
            // kind: 'plex' | 'jellyfin'
            if (kind === 'plex') {
                return {
                    movies: getMultiSelectValues('plex.movies'),
                    shows: getMultiSelectValues('plex.shows'),
                };
            }
            return {
                movies: getMultiSelectValues('jf.movies'),
                shows: getMultiSelectValues('jf.shows'),
            };
        }

        function isAnyFilterActive(filters) {
            return (
                !!(filters.years && filters.years.trim()) ||
                !!(filters.genres && filters.genres.trim()) ||
                !!(filters.ratings && filters.ratings.trim()) ||
                !!(filters.qualities && filters.qualities.trim()) ||
                !!(filters.recentOnly && filters.recentDays > 0)
            );
        }

        // Compute live filtered counts per source; when filters are active, use server-side uncapped preview
        async function refreshOverviewCounts() {
            try {
                // Fetch cached playlist first (fast fallback & used when no filters)
                const res = await window.dedupJSON('/get-media', { credentials: 'include' });
                let items = [];
                if (res) {
                    if (res.status === 202) {
                        // Playlist building; schedule a quick retry so counts don't stick at 0
                        const j = (await res.json().catch(() => ({}))) || {};
                        const retryIn = Math.min(Math.max(Number(j.retryIn) || 2000, 500), 5000);
                        setTimeout(() => {
                            try {
                                refreshOverviewCounts();
                            } catch (_) {
                                /* overview counts retry scheduling failed (will update on manual action) */
                            }
                        }, retryIn);
                    } else if (res.ok) {
                        items = (await res.json().catch(() => [])) || [];
                        if (!Array.isArray(items)) items = [];
                    }
                }

                // Helpers: infer source and apply UI filters
                const inferSource = it => {
                    const s = (it.source || it.serverType || '').toString().toLowerCase();
                    if (s) return s;
                    // Best-effort inference for TMDB items that may not set source string
                    if (it.tmdbId != null) return 'tmdb';
                    const k = (it.key || '').toString().toLowerCase();
                    if (k.startsWith('plex-')) return 'plex';
                    if (k.startsWith('jellyfin_')) return 'jellyfin';
                    if (k.startsWith('tmdb-')) return 'tmdb';
                    return '';
                };
                const parseCsv = v =>
                    String(v || '')
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean);
                const yearInExpr = (year, expr) => {
                    if (!expr) return true;
                    const y = Number(year);
                    if (!Number.isFinite(y) || y <= 0) return false;
                    const parts = String(expr)
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean);
                    for (const p of parts) {
                        if (/^\d{4}$/.test(p)) {
                            if (y === Number(p)) return true;
                        } else {
                            const m = p.match(/^(\d{4})\s*-\s*(\d{4})$/);
                            if (m) {
                                const a = Number(m[1]);
                                const b = Number(m[2]);
                                if (Number.isFinite(a) && Number.isFinite(b) && a <= b) {
                                    if (y >= a && y <= b) return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                const anyGenreMatch = (itemGenres, selectedCsv) => {
                    const need = parseCsv(selectedCsv);
                    if (!need.length) return true;
                    const have = Array.isArray(itemGenres)
                        ? itemGenres.map(g => String(g).toLowerCase())
                        : [];
                    return need.some(n => have.includes(String(n).toLowerCase()));
                };
                const ratingIncluded = (itemRating, selectedCsv) => {
                    const need = parseCsv(selectedCsv);
                    if (!need.length) return true;
                    if (!itemRating) return false;
                    const norm = String(itemRating).toLowerCase();
                    return need.some(r => String(r).toLowerCase() === norm);
                };
                // Map backend resolution strings to quality labels like the server does
                const mapResToLabel = res => {
                    const r = (res || '').toString().toLowerCase();
                    if (!r || r === 'sd') return 'SD';
                    if (r === '720' || r === 'hd' || r === '720p') return '720p';
                    if (r === '1080' || r === '1080p' || r === 'fullhd') return '1080p';
                    if (r === '4k' || r === '2160' || r === '2160p' || r === 'uhd') return '4K';
                    return r.toUpperCase();
                };
                // Try to infer Jellyfin quality label from originalData MediaStreams
                const inferJfQuality = it => {
                    const od = it && (it.originalData || it._raw);
                    const sources = od && Array.isArray(od.MediaSources) ? od.MediaSources : [];
                    for (const source of sources) {
                        const streams = Array.isArray(source.MediaStreams)
                            ? source.MediaStreams
                            : [];
                        const vid = streams.find(s => s.Type === 'Video');
                        if (vid && Number.isFinite(Number(vid.Height))) {
                            const h = Number(vid.Height);
                            if (h <= 576) return 'SD';
                            if (h <= 720) return '720p';
                            if (h <= 1080) return '1080p';
                            if (h >= 2160) return '4K';
                            return `${h}p`;
                        }
                    }
                    return null;
                };
                // Try to infer Plex quality label from raw Media videoResolution when available
                const inferPlexQuality = it => {
                    const raw = it && it._raw;
                    const mediaArr = raw && Array.isArray(raw.Media) ? raw.Media : [];
                    for (const m of mediaArr) {
                        if (m && m.videoResolution) return mapResToLabel(m.videoResolution);
                    }
                    return null;
                };

                // Read current UI filters (live, unsaved)
                const plexFilters = {
                    years: (document.getElementById('plex.yearFilter')?.value || '').trim(),
                    genres: (typeof getPlexGenreFilterHidden === 'function'
                        ? getPlexGenreFilterHidden()
                        : ''
                    ).trim(),
                    // MPAA/TV ratings
                    ratings: (typeof getPlexHidden === 'function'
                        ? getPlexHidden('plex.ratingFilter-hidden')
                        : ''
                    ).trim(),
                    qualities: (typeof getPlexHidden === 'function'
                        ? getPlexHidden('plex.qualityFilter-hidden')
                        : ''
                    ).trim(),
                    recentOnly: !!document.getElementById('plex.recentOnlyHeader')?.checked,
                    recentDays: Number(document.getElementById('plex.recentDays')?.value) || 0,
                };
                const jfFilters = {
                    years: (document.getElementById('jf.yearFilter')?.value || '').trim(),
                    genres: (typeof getJfHidden === 'function'
                        ? getJfHidden('jf.genreFilter-hidden')
                        : ''
                    ).trim(),
                    ratings: (typeof getJfHidden === 'function'
                        ? getJfHidden('jf.ratingFilter-hidden')
                        : ''
                    ).trim(),
                    qualities: (typeof getJfHidden === 'function'
                        ? getJfHidden('jf.qualityFilter-hidden')
                        : ''
                    ).trim(),
                    recentOnly: !!document.getElementById('jf.recentOnlyHeader')?.checked,
                    recentDays: Number(document.getElementById('jf.recentDays')?.value) || 0,
                };

                const matchWith = (it, src) => {
                    const s = inferSource(it);
                    if (s !== src) return false;
                    const f = src === 'plex' ? plexFilters : src === 'jellyfin' ? jfFilters : null;
                    if (!f) return true;
                    // Year
                    if (f.years && !yearInExpr(it.year, f.years)) return false;
                    // Genres
                    if (!anyGenreMatch(it.genres, f.genres)) return false;
                    // Content rating (MPAA/TV)
                    const itemRating = src === 'plex' ? it.contentRating : it.officialRating;
                    if (!ratingIncluded(itemRating, f.ratings)) return false;
                    // Quality (best-effort; skip when unknown on item)
                    const allowedQ = parseCsv(f.qualities);
                    if (allowedQ.length) {
                        // Prefer explicit qualityLabel when present (set by backend), else infer
                        const qLabel = (it.qualityLabel || '').toString();
                        const q = qLabel
                            ? qLabel
                            : src === 'plex'
                              ? inferPlexQuality(it)
                              : inferJfQuality(it);
                        if (q) {
                            const allowedLower = allowedQ.map(a => a.toLowerCase());
                            if (!allowedLower.includes(q.toLowerCase())) return false;
                        }
                    }
                    // Recently added only
                    if (f.recentOnly && f.recentDays > 0) {
                        const ts = Number(it.addedAtMs);
                        if (!Number.isFinite(ts)) return false;
                        const daysAgo = Date.now() - f.recentDays * 24 * 60 * 60 * 1000;
                        if (ts < daysAgo) return false;
                    }
                    return true;
                };

                const setCount = (id, n, m, tooltip) => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    const valEl = el.querySelector('.value');
                    // Always show a number (fallback to 0) to avoid lingering em-dash
                    const nn = Number.isFinite(n) ? n : 0;
                    const mm = Number.isFinite(m) ? m : m === 0 ? 0 : null;
                    if (valEl) {
                        valEl.textContent = mm != null ? `${nn}/${mm}` : `${nn}`;
                    } else {
                        // Fallback for header pills without inner .value span
                        el.textContent = mm != null ? `Items: ${nn} of ${mm}` : `Items: ${nn}`;
                    }
                    if (typeof tooltip === 'string' && tooltip) el.title = tooltip;
                };
                // Compute filtered counts from playlist cache (fallback)
                let filteredPlex = items.filter(it => matchWith(it, 'plex')).length;
                let filteredJf = items.filter(it => matchWith(it, 'jellyfin')).length;
                // For TMDB we don't have per-source filters here; show counts from cached playlist
                const filteredTmdb = items.filter(it => inferSource(it) === 'tmdb').length;

                // Always ask the server for full-library uncapped counts to ensure Plex/JF filters reflect immediately
                try {
                    const body = {
                        plex: getSelectedLibraries('plex'),
                        jellyfin: getSelectedLibraries('jellyfin'),
                        // Send filters per source, matching server-side logic
                        filtersPlex: plexFilters,
                        filtersJellyfin: jfFilters,
                    };
                    const r = await fetch('/api/admin/filter-preview', {
                        method: 'POST',
                        credentials: 'include',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body),
                    });
                    if (r.ok) {
                        const j = await r.json().catch(() => ({}));
                        const c = j?.counts || {};
                        if (Number.isFinite(c.plex)) filteredPlex = c.plex;
                        if (Number.isFinite(c.jellyfin)) filteredJf = c.jellyfin;
                    }
                } catch (_) {
                    /* filter-preview fetch failed (falling back to cached playlist counts) */
                }

                // Always compute true totals (sum of selected library counts)
                let totalPlex = null;
                let totalJf = null;
                try {
                    const map = await fetchLibraryCounts('plex');
                    const { movies, shows } = getSelectedLibraries('plex');
                    const sum = arr =>
                        (arr || []).reduce((acc, name) => acc + (map.get(name)?.itemCount || 0), 0);
                    totalPlex = sum(movies) + sum(shows);
                } catch (_) {
                    /* filter-preview fetch failed (falling back to cached playlist counts) */
                }
                try {
                    // We prefer the richer global map built during the last explicit Jellyfin library fetch
                    let map = null;
                    if (window.__jfLibraryCounts instanceof Map && window.__jfLibraryCounts.size) {
                        map = window.__jfLibraryCounts;
                    } else {
                        // Fallback: fetch on-demand (may return empty if enablement cache stale)
                        map = await fetchLibraryCounts('jellyfin');
                    }
                    const { movies, shows } = getSelectedLibraries('jellyfin');
                    const selectedMovies = Array.isArray(movies) ? movies : [];
                    const selectedShows = Array.isArray(shows) ? shows : [];
                    const sumFromMap = (arr, libMap) =>
                        (arr || []).reduce(
                            (acc, name) => acc + (Number(libMap.get(name)?.itemCount) || 0),
                            0
                        );
                    const haveSelection = selectedMovies.length + selectedShows.length > 0;
                    if (map && map.size) {
                        if (haveSelection) {
                            const selTotal =
                                sumFromMap(selectedMovies, map) + sumFromMap(selectedShows, map);
                            totalJf = selTotal;
                        } else {
                            // No selection: sum all to show overall total
                            let all = 0;
                            map.forEach(v => {
                                if (v && Number.isFinite(Number(v.itemCount)))
                                    all += Number(v.itemCount);
                            });
                            totalJf = all;
                        }
                    }
                    // If after computation totalJf is 0 but we had previous non-zero displayed value, preserve previous (avoid flicker to 0)
                    try {
                        const pill = document.getElementById('jf-count-pill');
                        const prevText = pill?.textContent || '';
                        const m = prevText.match(/(\d+)[^0-9]+(\d+)/); // format like "348/1328"
                        if (m && Number(totalJf) === 0) {
                            const prevTotal = Number(m[2]);
                            if (Number.isFinite(prevTotal) && prevTotal > 0) {
                                totalJf = prevTotal; // retain previous total until a non-zero recompute occurs
                            }
                        }
                    } catch (_) {
                        /* previous total pill parse failed (ok to skip) */
                    }
                    // debug removed: Jellyfin counts compute
                } catch (e) {
                    if (__debugOn) {
                        console.debug('[Admin][Jellyfin][Counts][Compute] failed', e);
                    }
                }

                // If no filters are active, prefer true totals; if unavailable, fall back to filtered (playlist-derived)
                // Determine whether any filters are currently active (for display preference only)
                const plexFiltersActive = isAnyFilterActive(plexFilters);
                const jfFiltersActive = isAnyFilterActive(jfFilters);
                const displayPlex = plexFiltersActive
                    ? filteredPlex
                    : Number.isFinite(totalPlex)
                      ? totalPlex
                      : filteredPlex;
                const displayJf = jfFiltersActive
                    ? filteredJf
                    : Number.isFinite(totalJf)
                      ? totalJf
                      : filteredJf;

                // Store filtered counts globally for dashboard calculation
                window.__lastPlexFilteredCount = displayPlex;
                window.__lastJellyfinFilteredCount = displayJf;

                const _fmt = v => (Number.isFinite(v) ? Number(v).toLocaleString() : '—');
                const plexTooltip = `Items — filtered: ${_fmt(filteredPlex)} | total: ${_fmt(totalPlex)}`;
                const jfTooltip = `Items — filtered: ${_fmt(filteredJf)} | total: ${_fmt(totalJf)}`;
                // debug removed: Jellyfin counts summary
                setCount('sc-plex-count', displayPlex, totalPlex, plexTooltip);
                setCount('sc-jf-count', displayJf, totalJf, jfTooltip);
                // Default display for TMDB from cached playlist
                let tmdbTotal = null;
                try {
                    const r = await window.dedupJSON('/api/admin/tmdb-total', {
                        credentials: 'include',
                    });
                    if (r?.ok) {
                        const j = await r.json();
                        const tv = j?.total;
                        if (typeof tv === 'number' && Number.isFinite(tv)) tmdbTotal = tv;
                        else if (typeof tv === 'string' && /^\d+$/.test(tv))
                            tmdbTotal = parseInt(tv, 10);
                    }
                } catch (_) {
                    /* fetchLibraryCounts(plex) failed (totalPlex stays null) */
                }
                // Display counts: for TMDB we don't have UI filters, so show a single total number.
                const displayTmdb = Number.isFinite(tmdbTotal) ? tmdbTotal : filteredTmdb;

                // Store TMDB count globally for dashboard calculation
                window.__lastTmdbCount = displayTmdb;

                // Build helpful tooltips for TMDB
                const fmt = v => (Number.isFinite(v) ? Number(v).toLocaleString() : '—');
                const tmdbTooltip = `TMDB items — cached: ${fmt(filteredTmdb)} | total: ${fmt(tmdbTotal)}`;

                // Overview tiles
                setCount('sc-tmdb-count', displayTmdb, null, tmdbTooltip);
                // Also update per-source panel header pills
                setCount('plex-count-pill', displayPlex, totalPlex);
                setCount('jf-count-pill', displayJf, totalJf);
                // TMDB header pill
                setCount('tmdb-count-pill', displayTmdb, null, tmdbTooltip);

                // Update dashboard media items count with filtered totals from all enabled sources
                updateMediaItemsCount().catch(err => {
                    logger.error('Failed to update dashboard media items count:', err);
                });

                // Local header pill — prefer directory totals if available, fallback to cached playlist
                try {
                    const [dirTotal, filteredLocal] = await Promise.all([
                        (async () => {
                            try {
                                const url = '/api/local/browse?path=/';
                                const r = await (typeof window.dedupJSON === 'function'
                                    ? window.dedupJSON(url)
                                    : fetch(url, { credentials: 'include' }));
                                if (!r || !r.ok) return null;
                                const j = await r.json().catch(() => null);
                                const map = new Map(
                                    (Array.isArray(j?.directories) ? j.directories : []).map(d => [
                                        String(d.name || '').toLowerCase(),
                                        d,
                                    ])
                                );
                                const sum = name => Number(map.get(name)?.itemCount || 0);
                                const total =
                                    sum('posters') +
                                    sum('backgrounds') +
                                    sum('motion') +
                                    sum('complete');
                                return Number.isFinite(total) ? total : null;
                            } catch (_) {
                                return null;
                            }
                        })(),
                        Promise.resolve(items.filter(it => inferSource(it) === 'local').length),
                    ]);
                    const val =
                        Number.isFinite(dirTotal) && dirTotal != null ? dirTotal : filteredLocal;
                    setCount(
                        'local-count-pill',
                        val,
                        null,
                        `Local items — ${Number.isFinite(dirTotal) ? 'directory total' : 'cached'}: ${fmt(val)}`
                    );
                } catch (_) {
                    // ignore; leave as-is if items not available
                }
            } catch (_) {
                // ignore
            }
        }

        // Wire live listeners so count badges and library labels update while editing
        function wireLiveMediaSourcePreview() {
            try {
                if (document.body.dataset.msPreviewWired === 'true') return;
                const safeOn = (id, evt = 'change') => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    if (el.dataset.countWired === 'true') return;
                    el.addEventListener(evt, () => refreshOverviewCounts());
                    el.dataset.countWired = 'true';
                };
                // Plex filters
                safeOn('plex.yearFilter', 'input');
                safeOn('plex.ratingFilter-hidden');
                safeOn('plex.genreFilter-hidden');
                safeOn('plex.qualityFilter-hidden');
                safeOn('plex.recentOnly');
                safeOn('plex.recentDays', 'input');
                // Toggle Plex days enabled state when checkbox changes
                try {
                    const pcb = document.getElementById('plex.recentOnly');
                    const pdy = document.getElementById('plex.recentDays');
                    if (pcb && !pcb.dataset.daysToggleWired) {
                        pcb.addEventListener('change', () => {
                            if (pdy) pdy.disabled = !pcb.checked;
                        });
                        pcb.dataset.daysToggleWired = 'true';
                    }
                } catch (_) {
                    /* plex days checkbox toggle wire failed (user can toggle manually) */
                }
                // Jellyfin filters
                safeOn('jf.yearFilter', 'input');
                safeOn('jf.ratingFilter-hidden');
                safeOn('jf.genreFilter-hidden');
                safeOn('jf.qualityFilter-hidden');
                safeOn('jf.recentOnly');
                safeOn('jf.recentDays', 'input');
                // Toggle Jellyfin days enabled state when checkbox changes
                try {
                    const jcb = document.getElementById('jf.recentOnly');
                    const jdy = document.getElementById('jf.recentDays');
                    if (jcb && !jcb.dataset.daysToggleWired) {
                        jcb.addEventListener('change', () => {
                            if (jdy) jdy.disabled = !jcb.checked;
                        });
                        jcb.dataset.daysToggleWired = 'true';
                    }
                } catch (_) {
                    /* jellyfin days checkbox toggle wire failed (user can toggle manually) */
                }

                // Keep overview "Libraries: Movies X, Shows Y" in sync with current selections
                const updateLibsMeta = () => {
                    try {
                        const plexMovies = document.getElementById('plex.movies');
                        const plexShows = document.getElementById('plex.shows');
                        const jfMovies = document.getElementById('jf.movies');
                        const jfShows = document.getElementById('jf.shows');
                        const countSel = sel =>
                            sel ? Array.from(sel.selectedOptions || []).length : 0;
                        const plexLibsEl = document.getElementById('sc-plex-libs');
                        const jfLibsEl = document.getElementById('sc-jf-libs');
                        if (plexLibsEl) {
                            const v = plexLibsEl.querySelector('.value');
                            const mv = countSel(plexMovies),
                                sv = countSel(plexShows);
                            if (v) v.textContent = `${mv + sv}`;
                            plexLibsEl.title = `Libraries selected: Movies ${mv}, Shows ${sv}`;
                        }
                        if (jfLibsEl) {
                            const v = jfLibsEl.querySelector('.value');
                            const mv = countSel(jfMovies),
                                sv = countSel(jfShows);
                            if (v) v.textContent = `${mv + sv}`;
                            jfLibsEl.title = `Libraries selected: Movies ${mv}, Shows ${sv}`;
                        }
                    } catch (_) {
                        /* previous total pill parse failed (ok to skip) */
                    }
                };
                const onLibChange = selId => {
                    const sel = document.getElementById(selId);
                    if (!sel) return;
                    if (sel.dataset.countWired === 'true') return;
                    sel.addEventListener('change', () => {
                        try {
                            if (selId.startsWith('plex.'))
                                window.__plexUserModifiedSelection = true;
                            if (selId.startsWith('jf.')) window.__jfUserModifiedSelection = true;
                        } catch (e) {
                            if (__debugOn) {
                                console.debug('[Admin][Jellyfin][Counts][Compute] failed', e);
                            }
                        }
                        refreshOverviewCounts();
                    });
                    sel.dataset.countWired = 'true';
                };
                onLibChange('plex.movies');
                onLibChange('plex.shows');
                onLibChange('jf.movies');
                onLibChange('jf.shows');
                // Initial sync
                updateLibsMeta();
                document.body.dataset.msPreviewWired = 'true';
            } catch (_) {
                /* no-op */
            }
        }

        // Prevent autofill/auto-focus on sensitive fields; require explicit user click to edit
        function guardSensitiveInputs() {
            try {
                const ids = ['plex.token', 'jf.apikey', 'tmdb.apikey'];
                // If any of these were auto-focused by the browser, blur them immediately
                try {
                    const ae = document.activeElement;
                    if (ae && ids.includes(ae.id)) ae.blur();
                } catch (_) {
                    /* activeElement blur safeguard failed (benign) */
                }
                ids.forEach(id => {
                    const el = document.getElementById(id);
                    if (!el || el.dataset.requireClickWired === 'true') return;
                    // Make read-only until the user explicitly clicks/taps
                    el.readOnly = true;
                    el.title = el.title || 'Click to edit';
                    const unlock = () => {
                        if (!el.readOnly) return;
                        el.readOnly = false;
                        // focus after unlocking for a smooth experience
                        setTimeout(() => {
                            try {
                                el.focus({ preventScroll: true });
                            } catch (_) {
                                // ignore; leave as-is if items not available
                            }
                        }, 0);
                    };
                    // Pointer interactions unlock editing
                    el.addEventListener('mousedown', unlock);
                    el.addEventListener('touchstart', unlock, { passive: true });
                    // If the browser tries to focus without a click (e.g., autofill), immediately blur
                    el.addEventListener('focus', () => {
                        if (el.readOnly) {
                            try {
                                el.blur();
                            } catch (_) {
                                /* blur safeguard failed (keep readonly focus prevention best-effort) */
                            }
                        }
                    });
                    el.dataset.requireClickWired = 'true';
                });
            } catch (_) {
                /* wireLiveMediaSourcePreview safeguard failed (defer to manual refresh) */
            }
        }

        // Note: initMsForSelect moved earlier in file to fix lint errors

        // Note: rebuildMsForSelect moved earlier in file to fix lint errors

        async function loadMediaSources(forceFresh = false) {
            const r = forceFresh
                ? await fetch('/api/admin/config', { credentials: 'include' })
                : await window.dedupJSON('/api/admin/config', { credentials: 'include' });
            const j = r.ok ? await r.json() : {};
            const env = j?.env || {}; // used by updateOverviewCards and subsequent helpers
            const cfg = j?.config || j || {};
            // Initialize once-per-session auto-fetch guards
            window.__autoFetchedLibs = window.__autoFetchedLibs || { plex: false, jf: false };
            // Plex/Jellyfin server entries
            const plex = (cfg.mediaServers || []).find(s => s.type === 'plex') || {};
            const jf = (cfg.mediaServers || []).find(s => s.type === 'jellyfin') || {};
            try {
                // Stronger debug logging (console.log instead of debug so it always shows) and global exposure for support
                const plexDbg = {
                    hostname: plex.hostname,
                    port: plex.port,
                    enabled: plex.enabled,
                    tokenEnvVar: plex.tokenEnvVar,
                    hasTokenEnv: !!env[plex.tokenEnvVar || 'PLEX_TOKEN'],
                    movieLibraries: plex.movieLibraryNames,
                };
                window.__PLEX_ENTRY = plexDbg;
                // console.log removed: Loaded plex entry
                // Mirror into legacy hidden inputs if they exist so older handlers / cached DOM still read values
                const legacyHost = document.getElementById('plex_hostname');
                const legacyPort = document.getElementById('plex_port');
                if (legacyHost && plex.hostname) legacyHost.value = plex.hostname;
                if (legacyPort && (plex.port || plex.port === 0)) legacyPort.value = plex.port;
                // Inject a one-time small badge to visually confirm script executed & values loaded
                if (!document.getElementById('plex-loaded-badge')) {
                    const badge = document.createElement('span');
                    badge.id = 'plex-loaded-badge';
                    badge.textContent = 'Plex cfg loaded';
                    badge.style.cssText =
                        'margin-left:8px;padding:2px 6px;font-size:11px;border-radius:10px;background:#2d6a4f;color:#fff;';
                    const hdr = document.querySelector(
                        '#plex-panel h2, #plex-panel h3, #plex-panel .panel-header, #plex-panel .panel-title'
                    );
                    (hdr || document.getElementById('plex-panel') || document.body).appendChild(
                        badge
                    );
                }
            } catch (_) {
                /* plex header toggle text force refresh failed (label may be stale) */
            }
            // Plex
            const plexEnabled = !!plex.enabled;
            // Direct config model: use stored hostname/port directly (legacy *EnvVar removed)
            const plexTokenVar = plex.tokenEnvVar || 'PLEX_TOKEN';
            if (getInput('plex.enabled')) {
                const cb = getInput('plex.enabled');
                cb.checked = plexEnabled;
                // Establish baseline so later changes can flip the Save label
                cb.dataset.originalEnabled = plexEnabled ? 'true' : 'false';
                try {
                    updateSourceSaveButtonLabel('plex');
                } catch (_) {
                    /* plex Save button label update failed (label may be stale) */
                }
            }
            try {
                requestAnimationFrame(() => forceUpdateHeaderToggleText('plex.enabled'));
            } catch (_) {
                /* plex enabled header toggle forced text update failed (label may be stale) */
            }
            // Prefill status pill based on enabled + presence of host/port
            try {
                const pill = document.getElementById('plex-status-pill-header');
                const host = plex.hostname || '';
                const portVal = plex.port != null ? String(plex.port) : '';
                if (pill) {
                    pill.classList.remove(
                        'status-success',
                        'status-error',
                        'is-configured',
                        'is-not-configured'
                    );
                    if (!plexEnabled) {
                        pill.textContent = 'Disabled';
                        pill.classList.add('is-not-configured');
                    } else if (host && portVal) {
                        pill.textContent = 'Configured';
                        pill.classList.add('is-configured');
                        // Auto-trigger library/media refresh once after load when configured & enabled
                        try {
                            window.__plexAutoRefreshed = window.__plexAutoRefreshed || false;
                            if (!window.__plexAutoRefreshed && !forceFresh) {
                                window.__plexAutoRefreshed = true;
                                fetchPlexLibraries(true, true);
                            }
                        } catch (_) {
                            /* ms wrap state exposure failed (debug only) */
                        }
                    }
                }
                // Removed globe link rendering in header actions
            } catch (_) {
                /* plex config status pill update failed (UI will fallback to previous state) */
            }
            // Populate Plex host/port more defensively: if empty but we have server config values fallback
            try {
                // Support both dotted IDs (new) and legacy underscore IDs present in HTML
                const hostInput = getInput('plex.hostname');
                const portInput = getInput('plex.port');
                const host = plex.hostname || '';
                const portVal = plex.port != null ? String(plex.port) : '';
                const existingHost = hostInput ? hostInput.value.trim() : '';
                const existingPort = portInput ? portInput.value.trim() : '';
                // Legacy env-based host/port variables removed. Use existing config values only.
                if (hostInput) {
                    hostInput.value = existingHost || host || '';
                    hostInput.classList.toggle('is-placeholder', !hostInput.value);
                }
                if (portInput) {
                    portInput.value = existingPort || portVal || '';
                    portInput.classList.toggle('is-placeholder', !portInput.value);
                }
            } catch (_) {
                /* plex host/port population failed (inputs may be empty) */
            }
            // Install / update Plex health indicator
            try {
                let health = document.getElementById('plex-health-indicator');
                if (!health) {
                    health = document.createElement('div');
                    health.id = 'plex-health-indicator';
                    health.style.cssText = 'margin-top:4px;font-size:11px;opacity:0.85;';
                    const container = document.getElementById('plex-panel') || document.body;
                    container.appendChild(health);
                }
                const updateHealth = (status, extra = '') => {
                    const ts = new Date().toLocaleTimeString();
                    health.textContent = `Plex health: ${status}${extra ? ' - ' + extra : ''} (${ts})`;
                    health.style.color =
                        status === 'OK' ? '#2d6a4f' : status === 'Testing' ? '#555' : '#c92a2a';
                };
                // Periodic lightweight health check using test-plex endpoint if enabled
                if (plexEnabled && plex.hostname && plex.port) {
                    window.__plexHealthTimer && clearTimeout(window.__plexHealthTimer);
                    const doCheck = () => {
                        updateHealth('Testing');
                        fetch('/api/admin/test-plex', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({ hostname: plex.hostname, port: plex.port }),
                        })
                            .then(r =>
                                r
                                    .json()
                                    .then(j => ({ r, j }))
                                    .catch(() => ({ r, j: {} }))
                            )
                            .then(({ r, j }) => {
                                if (r.ok) updateHealth('OK');
                                else updateHealth('Error', j?.error || r.status);
                            })
                            .catch(err => updateHealth('Error', err?.message || 'network'))
                            .finally(() => {
                                window.__plexHealthTimer = setTimeout(doCheck, 60000); // every 60s
                            });
                    };
                    doCheck();
                }
            } catch (e) {
                console.warn('Plex health indicator init failed', e);
            }

            // ---------------- Jellyfin auto wiring (mirror + auto test + libraries) ----------------
            try {
                const jfEnabled = !!jf.enabled;
                const jfDbg = {
                    hostname: jf.hostname,
                    port: jf.port,
                    enabled: jf.enabled,
                    tokenEnvVar: jf.tokenEnvVar,
                };
                window.__JELLYFIN_ENTRY = jfDbg;
                // console.log removed: Loaded jellyfin entry
                // Populate visible inputs if present
                const jfEnabledInput = document.getElementById('jf.enabled');
                if (jfEnabledInput) {
                    jfEnabledInput.checked = !!jf.enabled;
                    jfEnabledInput.dataset.originalEnabled = jfEnabled ? 'true' : 'false';
                    try {
                        updateSourceSaveButtonLabel('jellyfin');
                    } catch (_) {
                        /* save button label update optional; ignore */
                    }
                }
                const jfHostInput = document.getElementById('jf.hostname');
                if (jfHostInput && jf.hostname) jfHostInput.value = jf.hostname;
                const jfPortInput = document.getElementById('jf.port');
                if (jfPortInput && (jf.port || jf.port === 0)) jfPortInput.value = jf.port;
                // Mirror into legacy fields if present
                const legacyJfHost = document.getElementById('jf_hostname');
                const legacyJfPort = document.getElementById('jf_port');
                if (legacyJfHost && jf.hostname) legacyJfHost.value = jf.hostname;
                if (legacyJfPort && (jf.port || jf.port === 0)) legacyJfPort.value = jf.port;
                // Status pill update (reuse existing pill if present)
                const jfPill = document.getElementById('jf-status-pill-header');
                if (jfPill) {
                    jfPill.classList.remove(
                        'status-success',
                        'status-error',
                        'is-configured',
                        'is-not-configured'
                    );
                    if (!jfEnabled) {
                        jfPill.textContent = 'Disabled';
                        jfPill.classList.add('is-not-configured');
                    } else if (jf.hostname && (jf.port || jf.port === 0)) {
                        jfPill.textContent = 'Configured';
                        jfPill.classList.add('is-configured');
                    } else {
                        jfPill.textContent = 'Not configured';
                        jfPill.classList.add('is-not-configured');
                    }
                }
                // Auto test + library fetch (one time per session) similar to Plex
                if (jfEnabled && jf.hostname && (jf.port || jf.port === 0)) {
                    window.__jfAutoRefreshed = window.__jfAutoRefreshed || false;
                    if (!window.__jfAutoRefreshed && !forceFresh) {
                        window.__jfAutoRefreshed = true;
                        // console log removed: Auto refreshing Jellyfin libraries
                        (async () => {
                            try {
                                const body = { hostname: jf.hostname, port: jf.port };
                                const apiKeyEl = getInput('jf.apikey');
                                if (apiKeyEl?.value) body.apiKey = apiKeyEl.value;
                                const insecureHttps = !!(
                                    document.getElementById('jf.insecureHttps')?.checked ||
                                    document.getElementById('jf.insecureHttpsHeader')?.checked
                                );
                                if (insecureHttps) body.insecureHttps = true;
                                const testRes = await fetch('/api/admin/test-jellyfin', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    credentials: 'include',
                                    body: JSON.stringify(body),
                                });
                                if (!testRes.ok)
                                    console.warn(
                                        '[Admin][MediaSources] Auto test-jellyfin failed status',
                                        testRes.status
                                    );
                            } catch (je) {
                                console.warn(
                                    '[Admin][MediaSources] Auto test-jellyfin error',
                                    je?.message || je
                                );
                            } finally {
                                try {
                                    fetchJellyfinLibraries(true, true);
                                } catch (_) {
                                    /* jellyfin libraries auto fetch failed (user can click refresh manually) */
                                }
                            }
                        })();
                    }
                }
            } catch (e) {
                console.warn('Jellyfin auto wiring failed', e);
            }

            // ---------------- Jellyfin health indicator ----------------
            try {
                let jfHealth = document.getElementById('jf-health-indicator');
                if (!jfHealth) {
                    jfHealth = document.createElement('div');
                    jfHealth.id = 'jf-health-indicator';
                    jfHealth.style.cssText = 'margin-top:4px;font-size:11px;opacity:0.85;';
                    const jfPanel =
                        document.getElementById('panel-jellyfin') ||
                        document.getElementById('jellyfin-panel') ||
                        document.body;
                    jfPanel.appendChild(jfHealth);
                }
                const updateJfHealth = (status, extra = '') => {
                    const ts = new Date().toLocaleTimeString();
                    jfHealth.textContent = `Jellyfin health: ${status}${extra ? ' - ' + extra : ''} (${ts})`;
                    jfHealth.style.color =
                        status === 'OK' ? '#2d6a4f' : status === 'Testing' ? '#555' : '#c92a2a';
                };
                if (jf?.enabled && jf?.hostname && (jf.port || jf.port === 0)) {
                    window.__jfHealthTimer && clearTimeout(window.__jfHealthTimer);
                    const doJfCheck = () => {
                        updateJfHealth('Testing');
                        const body = { hostname: jf.hostname, port: jf.port };
                        const apiKeyEl = getInput('jf.apikey');
                        // Get API key with fallback chain (same as save logic)
                        const apiKey =
                            apiKeyEl?.dataset?.actualToken ||
                            apiKeyEl?.value?.trim() ||
                            window.__tokenStore?.jfApiKey ||
                            localStorage.getItem('jf_apikey_temp');
                        // Only add if not masked and not empty
                        if (apiKey && !/^[•]+$/.test(apiKey) && apiKey !== 'EXISTING_TOKEN') {
                            body.apiKey = apiKey;
                        }
                        const insecureHttps = !!(
                            document.getElementById('jf.insecureHttps')?.checked ||
                            document.getElementById('jf.insecureHttpsHeader')?.checked
                        );
                        if (insecureHttps) body.insecureHttps = true;
                        fetch('/api/admin/test-jellyfin', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify(body),
                        })
                            .then(r =>
                                r
                                    .json()
                                    .then(j => ({ r, j }))
                                    .catch(() => ({ r, j: {} }))
                            )
                            .then(({ r, j }) => {
                                if (r.ok) updateJfHealth('OK');
                                else updateJfHealth('Error', j?.error || r.status);
                            })
                            .catch(err => updateJfHealth('Error', err?.message || 'network'))
                            .finally(() => {
                                window.__jfHealthTimer = setTimeout(doJfCheck, 60000);
                            });
                    };
                    doJfCheck();
                }
            } catch (e) {
                console.warn('Jellyfin health indicator init failed', e);
            }

            // === GLOBAL TOKEN STORE ===
            // Always load tokens from localStorage at page init, regardless of which tab is open
            // This ensures tokens are available even when input fields don't exist (e.g., Dashboard tab)
            window.__tokenStore = window.__tokenStore || {};

            try {
                const plexToken = localStorage.getItem('plex_token_temp');
                if (plexToken && plexToken !== 'EXISTING_TOKEN') {
                    window.__tokenStore.plexToken = plexToken;
                    console.log(
                        '[Token Store] ✓ Loaded Plex token from localStorage:',
                        plexToken.length,
                        'chars'
                    );
                }
            } catch (e) {
                console.warn('[Token Store] Failed to load Plex token:', e);
            }

            try {
                const jfApiKey = localStorage.getItem('jf_apikey_temp');
                if (jfApiKey && jfApiKey !== 'EXISTING_TOKEN') {
                    window.__tokenStore.jfApiKey = jfApiKey;
                    console.log(
                        '[Token Store] ✓ Loaded Jellyfin API key from localStorage:',
                        jfApiKey.length,
                        'chars'
                    );
                }
            } catch (e) {
                console.warn('[Token Store] Failed to load Jellyfin API key:', e);
            }

            try {
                const tmdbApiKey = localStorage.getItem('tmdb_apikey_temp');
                if (tmdbApiKey && tmdbApiKey !== 'EXISTING_TOKEN') {
                    window.__tokenStore.tmdbApiKey = tmdbApiKey;
                    console.log(
                        '[Token Store] ✓ Loaded TMDB API key from localStorage:',
                        tmdbApiKey.length,
                        'chars'
                    );
                }
            } catch (e) {
                console.warn('[Token Store] Failed to load TMDB API key:', e);
            }

            if (getInput('plex.token') || getInput('plex_token')) {
                // Show masked placeholder when a token exists, or keep empty for user to fill
                const hasToken = !!env[plexTokenVar];
                const el = getInput('plex.token') || getInput('plex_token');

                // ALWAYS try to restore token from localStorage first (more persistent than sessionStorage)
                const savedToken = localStorage.getItem('plex_token_temp');

                // Priority: localStorage token > existing token marker > empty
                // ALWAYS set dataset.actualToken from localStorage if available
                if (savedToken && savedToken !== 'EXISTING_TOKEN') {
                    el.dataset.actualToken = savedToken;
                    console.log(
                        '[Token Init] ✓ Restored from localStorage:',
                        savedToken.length,
                        'chars'
                    );
                } else if (hasToken) {
                    el.dataset.actualToken = 'EXISTING_TOKEN';
                } else {
                    el.dataset.actualToken = '';
                }

                if (hasToken) {
                    // Set a special masked value that indicates token is set
                    el.value = '••••••••••••••••••••';
                    el.setAttribute('placeholder', 'Plex token already set');
                    el.classList.add('token-masked');
                } else {
                    // No token set, let user fill it in
                    el.value = '';
                    el.setAttribute('placeholder', 'X-Plex-Token');
                    el.classList.remove('token-masked');
                }

                // Capture the actual token when user types it
                el.addEventListener(
                    'input',
                    e => {
                        const val = e.target.value.trim();
                        if (val && !/^[•]+$/.test(val)) {
                            // User entered a real token, store it
                            el.dataset.actualToken = val;
                            // Save to localStorage for persistence across reloads
                            localStorage.setItem('plex_token_temp', val);
                            // Also update the global token store immediately
                            if (!window.__tokenStore) window.__tokenStore = {};
                            window.__tokenStore.plexToken = val;
                            console.log(
                                '[Token Input] Saved to dataset, localStorage, and token store:',
                                val.length,
                                'chars'
                            );
                        }
                    },
                    { once: false }
                );
            }
            // Support legacy ID used in some templates
            (function () {
                const el = document.getElementById('plex_token');
                if (!el) return;
                const hasToken = !!env[plexTokenVar];
                if (hasToken) {
                    // Set a special masked value that indicates token is set
                    el.value = '••••••••••••••••••••';
                    el.setAttribute('placeholder', 'Plex token already set');
                    el.classList.add('token-masked');
                } else {
                    // No token set, let user fill it in
                    el.value = '';
                    el.setAttribute('placeholder', 'X-Plex-Token');
                    el.classList.remove('token-masked');
                }
            })();
            const plexRecentlyHeader = getInput('plex.recentOnlyHeader');
            if (plexRecentlyHeader) plexRecentlyHeader.checked = !!plex.recentlyAddedOnly;
            if (getInput('plex.recentDays'))
                getInput('plex.recentDays').value = plex.recentlyAddedDays ?? 30;
            // Sync enabled/disabled state of days input with checkbox
            try {
                const cb = getInput('plex.recentOnly');
                const days = getInput('plex.recentDays');
                if (days) days.disabled = !(cb && cb.checked);
            } catch (_) {
                /* days enable/disable sync optional; ignore */
            }
            // Plex ratings/qualities multiselects (theme-demo)
            try {
                const ratingsCsv = Array.isArray(plex.ratingFilter)
                    ? plex.ratingFilter.join(',')
                    : plex.ratingFilter || '';
                await loadPlexRatings(ratingsCsv);
            } catch (e) {
                dbg('loadPlexRatings failed', e);
            }
            try {
                await loadPlexQualities(plex.qualityFilter || '');
            } catch (e) {
                dbg('loadPlexQualities failed', e);
            }
            if (getInput('plex.yearFilter')) {
                const v = plex.yearFilter;
                getInput('plex.yearFilter').value = v == null ? '' : String(v);
            }
            // --- Pre-seed Plex library multiselects with config values BEFORE async fetch ---
            try {
                // Only run once per page load to avoid duplicating chips
                if (!window.__plexLibsPreseeded) {
                    window.__plexLibsPreseeded = true;
                    const preMovies = Array.isArray(plex.movieLibraryNames)
                        ? plex.movieLibraryNames.filter(Boolean)
                        : [];
                    const preShows = Array.isArray(plex.showLibraryNames)
                        ? plex.showLibraryNames.filter(Boolean)
                        : [];
                    if (preMovies.length || preShows.length) {
                        // Seed options using names (no counts yet). They will be replaced once real library fetch completes.
                        setMultiSelect(
                            'plex.movies',
                            preMovies.map(n => ({ value: n, label: n })),
                            preMovies
                        );
                        setMultiSelect(
                            'plex.shows',
                            preShows.map(n => ({ value: n, label: n })),
                            preShows
                        );
                        // Ensure theme-demo multiselect UI shows chips immediately if already wired
                        try {
                            rebuildMsForSelect('plex-ms-movies', 'plex.movies');
                            rebuildMsForSelect('plex-ms-shows', 'plex.shows');
                        } catch (_) {
                            /* inner wrapper flatten (B) failed (layout unaffected) */
                        }
                    }
                }
            } catch (_) {
                /* guardSensitiveInputs failed (inputs remain editable normally) */
            }
            setMultiSelect(
                'plex.movies',
                (plex.movieLibraryNames || []).map(n => ({ value: n, label: n })),
                plex.movieLibraryNames || []
            );
            setMultiSelect(
                'plex.shows',
                (plex.showLibraryNames || []).map(n => ({ value: n, label: n })),
                plex.showLibraryNames || []
            );
            // Initialize theme-demo multiselects for Plex libraries
            initMsForSelect('plex-ms-movies', 'plex.movies');
            initMsForSelect('plex-ms-shows', 'plex.shows');
            // Populate Plex genres with counts and apply selected values from config
            await loadPlexGenres(plex.genreFilter || '');
            // Defer fetching Plex libraries until the Plex panel is opened
            // Jellyfin
            const jfEnabled = !!jf.enabled;
            const jfKeyVar = jf.tokenEnvVar || 'JELLYFIN_API_KEY';
            if (getInput('jf.enabled')) getInput('jf.enabled').checked = jfEnabled;
            try {
                requestAnimationFrame(() => forceUpdateHeaderToggleText('jf.enabled'));
            } catch (_) {
                /* header toggle text refresh optional; ignore */
            }
            // Header pill for Jellyfin
            try {
                const pill = document.getElementById('jf-status-pill-header');
                const openLink = document.getElementById('jf-open-link');
                const host = jf.hostname || '';
                const portVal = jf.port != null ? String(jf.port) : '';
                if (pill) {
                    pill.classList.remove(
                        'status-success',
                        'status-error',
                        'is-configured',
                        'is-not-configured'
                    );
                    if (!jfEnabled) {
                        pill.textContent = 'Disabled';
                        pill.classList.add('is-not-configured');
                    } else if (host && portVal) {
                        pill.textContent = 'Configured';
                        pill.classList.add('is-configured');
                    } else {
                        pill.textContent = 'Not configured';
                        pill.classList.add('is-not-configured');
                    }
                }
                if (openLink) {
                    if (jfEnabled && host && portVal) {
                        const portNum = Number(portVal);
                        const hostClean = host.replace(/^https?:\/\//i, '').replace(/\/?$/, '');
                        const protocol =
                            portNum === 443
                                ? 'https'
                                : /^https:\/\//i.test(host)
                                  ? 'https'
                                  : /^http:\/\//i.test(host)
                                    ? 'http'
                                    : 'http';
                        const base = `${protocol}://${hostClean}`;
                        const url = `${base}:${portVal}/web`;
                        openLink.href = url;
                        openLink.removeAttribute('hidden');
                    } else {
                        openLink.setAttribute('hidden', '');
                        openLink.removeAttribute('href');
                    }
                }
            } catch (_) {
                /* header pill update optional; ignore */
            }
            // Legacy Jellyfin env host/port vars removed; rely on config values already loaded above.
            if (getInput('jf.hostname')) {
                const jfHostInput = getInput('jf.hostname');
                jfHostInput.value = jfHostInput.value || jf.hostname || '';
                jfHostInput.classList.toggle('is-placeholder', !jfHostInput.value);
            }
            if (getInput('jf.port')) {
                const jfPortInput = getInput('jf.port');
                jfPortInput.value = jfPortInput.value || (jf.port != null ? String(jf.port) : '');
                jfPortInput.classList.toggle('is-placeholder', !jfPortInput.value);
            }
            if (getInput('jf.apikey')) {
                // Show masked value when a key exists, or keep empty for user to fill
                const hasKey = !!env[jfKeyVar];
                const el = getInput('jf.apikey');

                // ALWAYS try to restore API key from localStorage first
                const savedKey = localStorage.getItem('jf_apikey_temp');

                // Priority: localStorage key > existing key marker > empty
                if (savedKey && savedKey !== 'EXISTING_TOKEN') {
                    el.dataset.actualToken = savedKey;
                    console.log(
                        '[Jellyfin Init] ✓ Restored from localStorage:',
                        savedKey.length,
                        'chars'
                    );
                } else if (hasKey) {
                    el.dataset.actualToken = 'EXISTING_TOKEN';
                } else {
                    el.dataset.actualToken = '';
                }

                if (hasKey) {
                    // Set a special masked value that indicates key is set
                    el.value = '••••••••••••••••••••';
                    el.setAttribute('placeholder', 'Jellyfin API Key already set');
                    el.classList.add('token-masked');
                } else {
                    // No key set, let user fill it in
                    el.value = '';
                    el.setAttribute('placeholder', 'Jellyfin API Key');
                    el.classList.remove('token-masked');
                }

                // Capture the actual API key when user types it
                el.addEventListener(
                    'input',
                    e => {
                        const val = e.target.value.trim();
                        if (val && !/^[•]+$/.test(val)) {
                            el.dataset.actualToken = val;
                            localStorage.setItem('jf_apikey_temp', val);
                            // Also update the global token store immediately
                            if (!window.__tokenStore) window.__tokenStore = {};
                            window.__tokenStore.jfApiKey = val;
                            console.log(
                                '[Jellyfin Input] Saved to dataset, localStorage, and token store:',
                                val.length,
                                'chars'
                            );
                        }
                    },
                    { once: false }
                );
            }
            // Initialize Jellyfin Insecure HTTPS header toggle from env or default false
            try {
                const headerTgl = document.getElementById('jf.insecureHttpsHeader');
                const formCb = document.getElementById('jf.insecureHttps');
                const envFlag =
                    (env.JELLYFIN_INSECURE_HTTPS || '').toString().toLowerCase() === 'true';
                if (headerTgl) headerTgl.checked = envFlag;
                if (formCb) formCb.checked = envFlag;
            } catch (_) {
                /* init insecure https flag optional; ignore */
            }
            const jfRecentlyHeader = getInput('jf.recentOnlyHeader');
            if (jfRecentlyHeader) jfRecentlyHeader.checked = !!jf.recentlyAddedOnly;
            if (getInput('jf.recentDays'))
                getInput('jf.recentDays').value = jf.recentlyAddedDays ?? 30;
            // Sync enabled/disabled state of days input with checkbox
            try {
                const cb = getInput('jf.recentOnly');
                const days = getInput('jf.recentDays');
                if (days) days.disabled = !(cb && cb.checked);
            } catch (_) {
                /* sync days enablement optional; ignore */
            }
            if (getInput('jf.yearFilter')) {
                const v = jf.yearFilter;
                getInput('jf.yearFilter').value = v == null ? '' : String(v);
            }
            // Preload Jellyfin rating/genre/quality selectors using config values
            // Initialize library selects before fetching dependent data (genres need libraries)
            setMultiSelect(
                'jf.movies',
                (jf.movieLibraryNames || []).map(n => ({ value: n, label: n })),
                jf.movieLibraryNames || []
            );
            setMultiSelect(
                'jf.shows',
                (jf.showLibraryNames || []).map(n => ({ value: n, label: n })),
                jf.showLibraryNames || []
            );
            // Initialize theme-demo multiselects for Jellyfin libraries
            initMsForSelect('jf-ms-movies', 'jf.movies');
            initMsForSelect('jf-ms-shows', 'jf.shows');
            // Now load dependent selectors
            try {
                await loadJellyfinRatings(
                    Array.isArray(jf.ratingFilter)
                        ? jf.ratingFilter.join(',')
                        : jf.ratingFilter || ''
                );
            } catch (e) {
                dbg('loadJellyfinRatings failed', e);
            }
            try {
                await loadJellyfinGenres(jf.genreFilter || '');
            } catch (e) {
                dbg('loadJellyfinGenres failed', e);
            }
            try {
                // Jellyfin qualities disabled
                await loadJellyfinQualities('');
            } catch (e) {
                dbg('loadJellyfinQualities failed', e);
            }
            // Defer fetching Jellyfin libraries until the Jellyfin panel is opened
            // TMDB
            const tmdb = cfg.tmdbSource || {};
            if (getInput('tmdb.enabled')) getInput('tmdb.enabled').checked = !!tmdb.enabled;
            try {
                requestAnimationFrame(() => forceUpdateHeaderToggleText('tmdb.enabled'));
            } catch (_) {
                /* requestAnimationFrame optional; ignore */
            }
            // Header pill for TMDB
            try {
                const pill = document.getElementById('tmdb-status-pill-header');
                if (pill) {
                    pill.classList.remove(
                        'status-success',
                        'status-error',
                        'is-configured',
                        'is-not-configured'
                    );
                    if (!tmdb.enabled) {
                        pill.textContent = 'Disabled';
                        pill.classList.add('is-not-configured');
                    } else if (tmdb.apiKey) {
                        pill.textContent = 'Configured';
                        pill.classList.add('is-configured');
                    } else {
                        pill.textContent = 'Not configured';
                        pill.classList.add('is-not-configured');
                    }
                }
            } catch (_) {
                /* TMDB header pill update optional; ignore */
            }
            if (getInput('tmdb.apikey')) {
                // Show masked value when an API key exists, or keep empty for user to fill
                const el = getInput('tmdb.apikey');

                // ALWAYS try to restore API key from localStorage first
                const savedKey = localStorage.getItem('tmdb_apikey_temp');

                // Priority: localStorage key > existing key marker > empty
                if (savedKey && savedKey !== 'EXISTING_TOKEN') {
                    el.dataset.actualToken = savedKey;
                    console.log(
                        '[TMDB Init] ✓ Restored from localStorage:',
                        savedKey.length,
                        'chars'
                    );
                } else if (tmdb.apiKey) {
                    el.dataset.actualToken = 'EXISTING_TOKEN';
                } else {
                    el.dataset.actualToken = '';
                }

                if (tmdb.apiKey) {
                    // Set a special masked value that indicates key is set
                    el.value = '••••••••••••••••••••';
                    el.setAttribute('placeholder', 'TMDB API Key already set');
                    el.classList.add('token-masked');
                } else {
                    // No key set, let user fill it in
                    el.value = '';
                    el.setAttribute('placeholder', 'TMDB API Key');
                    el.classList.remove('token-masked');
                }

                // Capture the actual API key when user types it
                el.addEventListener(
                    'input',
                    e => {
                        const val = e.target.value.trim();
                        if (val && !/^[•]+$/.test(val)) {
                            el.dataset.actualToken = val;
                            localStorage.setItem('tmdb_apikey_temp', val);
                            // Also update the global token store immediately
                            if (!window.__tokenStore) window.__tokenStore = {};
                            window.__tokenStore.tmdbApiKey = val;
                            console.log(
                                '[TMDB Input] Saved to dataset, localStorage, and token store:',
                                val.length,
                                'chars'
                            );
                        }
                    },
                    { once: false }
                );
            }
            if (getInput('tmdb.category')) {
                const el = getInput('tmdb.category');
                el.value = tmdb.category || 'popular';
                // Update overlay icon via change event (native select only)
                try {
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                } catch (_) {
                    // ignore (icon refresh)
                }
            }
            // Ensure TMDB Min Rating remains a compact number input (not a dropdown)
            (function ensureTmdbMinRatingNumber() {
                const existing = getInput('tmdb.minRating');
                if (!existing) return;
                // If a previous session converted it to a <select>, convert back to number input
                if (existing.tagName === 'SELECT') {
                    const sel = /** @type {HTMLSelectElement} */ (existing);
                    const current = Number(sel.value);
                    const wrap = sel.closest('.select-wrap') || sel;
                    const niw = document.createElement('div');
                    niw.className = 'number-input-wrapper niw-compact niw-sized-sm';
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = sel.id;
                    input.name = sel.getAttribute('name') || sel.id;
                    input.min = '0';
                    input.max = '10';
                    input.step = '0.1';
                    input.placeholder = '0';
                    input.value = Number.isFinite(current) ? String(current) : '0';
                    niw.appendChild(input);
                    const controls = document.createElement('div');
                    controls.className = 'number-controls';
                    const btnUp = document.createElement('button');
                    btnUp.type = 'button';
                    btnUp.className = 'number-btn number-inc';
                    btnUp.setAttribute('aria-label', 'Increase value');
                    btnUp.innerHTML = '<i class="fas fa-chevron-up"></i>';
                    const btnDown = document.createElement('button');
                    btnDown.type = 'button';
                    btnDown.className = 'number-btn number-dec';
                    btnDown.setAttribute('aria-label', 'Decrease value');
                    btnDown.innerHTML = '<i class="fas fa-chevron-down"></i>';
                    controls.appendChild(btnUp);
                    controls.appendChild(btnDown);
                    niw.appendChild(controls);
                    wrap.parentNode?.replaceChild(niw, wrap);
                    // Wire steppers for this wrapper (delegated handler expects correct structure)
                    try {
                        window.admin2?.wireNumberWrappers?.(niw.closest('.form-grid') || document);
                    } catch (_) {
                        /* panel zero-rect sizing fallback failed (panel may remain hidden) */
                    }
                } else {
                    // Plain number input exists: ensure value is clamped and wrapper enhanced
                    const input = /** @type {HTMLInputElement} */ (existing);
                    const raw = Number(tmdb.minRating);
                    const v = Number.isFinite(raw) ? Math.min(10, Math.max(0, Math.round(raw))) : 0;
                    input.value = String(v);
                    try {
                        window.admin2?.enhanceNumberInput?.(input);
                    } catch (_) {
                        /* posterpack library populate optional; ignore */
                    }
                }
            })();
            if (getInput('tmdb.yearFilter')) {
                const v = tmdb.yearFilter;
                getInput('tmdb.yearFilter').value = v == null ? '' : String(v);
            }
            // Defer loading TMDB genres until the TMDB panel is opened
            // Streaming Releases (TMDB-based)
            try {
                const streaming = cfg.streamingSources || {};
                const setBool = (id, v) => {
                    const el = getInput(id);
                    if (el) el.checked = !!v;
                };
                const setVal = (id, v) => {
                    const el = getInput(id);
                    if (el) el.value = v ?? '';
                };
                setBool('streamingSources.enabled', streaming.enabled);
                setVal('streamingSources.region', streaming.region || 'US');
                // Ensure Streaming Min Rating remains a compact number input (not a dropdown)
                (function ensureStreamingMinRatingNumber() {
                    const existing = getInput('streamingSources.minRating');
                    if (!existing) return;
                    if (existing.tagName === 'SELECT') {
                        const sel = /** @type {HTMLSelectElement} */ (existing);
                        const current = Number(sel.value);
                        const wrap = sel.closest('.select-wrap') || sel;
                        const niw = document.createElement('div');
                        niw.className = 'number-input-wrapper niw-compact niw-sized-sm';
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.id = sel.id;
                        input.name = sel.getAttribute('name') || sel.id;
                        input.min = '0';
                        input.max = '10';
                        input.step = '0.1';
                        input.placeholder = '0';
                        input.value = Number.isFinite(current) ? String(current) : '0';
                        niw.appendChild(input);
                        const controls = document.createElement('div');
                        controls.className = 'number-controls';
                        const btnUp = document.createElement('button');
                        btnUp.type = 'button';
                        btnUp.className = 'number-btn number-inc';
                        btnUp.setAttribute('aria-label', 'Increase value');
                        btnUp.innerHTML = '<i class="fas fa-chevron-up"></i>';
                        const btnDown = document.createElement('button');
                        btnDown.type = 'button';
                        btnDown.className = 'number-btn number-dec';
                        btnDown.setAttribute('aria-label', 'Decrease value');
                        btnDown.innerHTML = '<i class="fas fa-chevron-down"></i>';
                        controls.appendChild(btnUp);
                        controls.appendChild(btnDown);
                        niw.appendChild(controls);
                        wrap.parentNode?.replaceChild(niw, wrap);
                        try {
                            window.admin2?.wireNumberWrappers?.(
                                niw.closest('.form-grid') || document
                            );
                        } catch (_) {
                            /* notification panel visibility flag set failed (non-blocking) */
                        }
                    } else {
                        const input = /** @type {HTMLInputElement} */ (existing);
                        const raw = Number(streaming.minRating);
                        const v = Number.isFinite(raw)
                            ? Math.min(10, Math.max(0, Math.round(raw)))
                            : 0;
                        input.value = String(v);
                        try {
                            window.admin2?.enhanceNumberInput?.(input);
                        } catch (_) {
                            /* optional enhancement of number input failed; ignore */
                        }
                    }
                })();
                // Build provider multiselect options
                const providerOpts = [
                    { value: 'netflix', label: 'Netflix' },
                    { value: 'disney', label: 'Disney+' },
                    { value: 'prime', label: 'Prime Video' },
                    { value: 'hbo', label: 'Max (HBO)' },
                    { value: 'hulu', label: 'Hulu' },
                    { value: 'apple', label: 'Apple TV+' },
                    { value: 'paramount', label: 'Paramount+' },
                    { value: 'crunchyroll', label: 'Crunchyroll' },
                ];
                setMultiSelect(
                    'streaming.providers',
                    providerOpts,
                    Object.entries(streaming)
                        .filter(([k, v]) => v && providerOpts.some(p => p.value === k))
                        .map(([k]) => k)
                );
                initMsForSelect('streaming-ms-providers', 'streaming.providers');
                // New Releases toggle remains a standalone flag
                setBool('streamingSources.newReleases', streaming.newReleases);
            } catch (_) {
                // ignore (streaming UI init optional)
            }

            // Finally, paint overview cards (status + toggles + meta)
            updateOverviewCards(cfg, env);
            // Then fetch and paint last sync times
            refreshOverviewLastSync();
            // And compute current playlist counts per source
            refreshOverviewCounts();
            // Wire live listeners once per page load
            wireLiveMediaSourcePreview();
            // Enforce explicit click to edit sensitive fields and suppress auto-focus
            guardSensitiveInputs();
        }

        // Expose Plex field debug helper
        try {
            window.admin2 = window.admin2 || {};
            window.admin2.debugPlexFields = () => {
                const hostInput =
                    getInput('plex.hostname') || document.getElementById('plex_hostname');
                const portInput = getInput('plex.port') || document.getElementById('plex_port');
                const tokenInput = getInput('plex.token') || document.getElementById('plex_token');
                return {
                    hostValue: hostInput ? hostInput.value : null,
                    portValue: portInput ? portInput.value : null,
                    tokenPlaceholder: tokenInput ? tokenInput.getAttribute('placeholder') : null,
                    classes: {
                        host: hostInput ? hostInput.className : null,
                        port: portInput ? portInput.className : null,
                        token: tokenInput ? tokenInput.className : null,
                    },
                    idMatch: {
                        hostUsed: hostInput ? hostInput.id : null,
                        portUsed: portInput ? portInput.id : null,
                        tokenUsed: tokenInput ? tokenInput.id : null,
                    },
                };
            };
        } catch (_) {
            /* clock timezone/format row visibility toggle failed */
        }
        // Expose for reuse
        window.admin2 = window.admin2 || {};
        window.admin2.loadMediaSources = loadMediaSources;

        // Lazy fetch helpers: fire-and-forget conditional loads on panel open
        function maybeFetchPlexOnOpen() {
            try {
                (async () => {
                    window.__autoFetchedLibs = window.__autoFetchedLibs || {
                        plex: false,
                        jf: false,
                    };

                    // Mark that libraries need to be fetched on first multiselect open
                    window.__plexLibsFetchNeeded = true;

                    // Check if Plex is enabled
                    const plexEnabled = !!getInput('plex.enabled')?.checked;

                    if (plexEnabled && !window.__autoFetchedLibs.plex) {
                        window.__autoFetchedLibs.plex = true;

                        // Auto-test connection silently to populate filters (ratings/genres)
                        try {
                            const hostname = getInput('plex.hostname')?.value || '';
                            const port = getInput('plex.port')?.value || '';
                            const tokenInput = getInput('plex.token');
                            const token =
                                tokenInput?.dataset?.actualToken || tokenInput?.value || '';

                            if (hostname && port) {
                                // Test connection silently
                                await fetch('/api/admin/test-plex', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    credentials: 'include',
                                    body: JSON.stringify({
                                        hostname,
                                        port,
                                        token: token || undefined,
                                    }),
                                });
                                // Don't fetch libraries here - let the user click on the multiselect to trigger that
                            }
                        } catch (e) {
                            // Silently fail - user can manually test if needed
                            if (window.__debugOn)
                                console.debug('[Plex] Auto-test failed:', e.message);
                        }
                    }
                })();
            } catch (_) {
                /* ignore */
            }
        }

        function maybeFetchJellyfinOnOpen() {
            try {
                (async () => {
                    window.__autoFetchedLibs = window.__autoFetchedLibs || {
                        plex: false,
                        jf: false,
                    };

                    // Mark that libraries need to be fetched on first multiselect open
                    window.__jfLibsFetchNeeded = true;

                    // Check if Jellyfin is enabled
                    const jfEnabled = !!getInput('jf.enabled')?.checked;

                    if (jfEnabled && !window.__autoFetchedLibs.jf) {
                        window.__autoFetchedLibs.jf = true;

                        // Auto-test connection silently to populate filters (ratings/genres)
                        try {
                            const hostname = getInput('jf.hostname')?.value || '';
                            const port = getInput('jf.port')?.value || '';
                            const apiKeyInput = getInput('jf.apikey');
                            const apiKey =
                                apiKeyInput?.dataset?.actualToken || apiKeyInput?.value || '';
                            const insecureHttps = !!(
                                document.getElementById('jf.insecureHttps')?.checked ||
                                document.getElementById('jf.insecureHttpsHeader')?.checked
                            );

                            if (hostname && port) {
                                // Test connection silently
                                await fetch('/api/admin/test-jellyfin', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    credentials: 'include',
                                    body: JSON.stringify({
                                        hostname,
                                        port,
                                        apiKey: apiKey || undefined,
                                        insecureHttps,
                                    }),
                                });
                                // Don't fetch libraries here - let the user click on the multiselect to trigger that
                            }
                        } catch (e) {
                            // Silently fail - user can manually test if needed
                            if (window.__debugOn)
                                console.debug('[Jellyfin] Auto-test failed:', e.message);
                        }
                    }
                })();
            } catch (_) {
                /* ignore */
            }
        }

        function maybeFetchTmdbOnOpen() {
            try {
                (async () => {
                    // Ensure structure has tmdb flag
                    window.__autoFetchedLibs = window.__autoFetchedLibs || {
                        plex: false,
                        jf: false,
                        tmdb: false,
                    };
                    if (window.__tmdbGenresLoaded) return; // already fully loaded
                    if (window.__tmdbGenresLoading) return; // in-flight
                    if (!window.__autoFetchedLibs.tmdb) {
                        window.__autoFetchedLibs.tmdb = true;
                        // Retry with small backoff because config + panel markup may still be hydrating
                        const maxAttempts = 3;
                        let attempt = 0;
                        window.__tmdbGenreFetchAttempts = window.__tmdbGenreFetchAttempts || [];
                        const run = async () => {
                            attempt++;
                            const stamp = Date.now();
                            window.__tmdbGenreFetchAttempts.push({ attempt, ts: stamp });
                            window.__tmdbGenresLoading = true;
                            try {
                                const cfgRes = await window.dedupJSON('/api/admin/config', {
                                    credentials: 'include',
                                });
                                const base = cfgRes?.ok ? await cfgRes.json() : {};
                                const tmdb = base?.config?.tmdbSource || base?.tmdbSource || {};
                                // Only try if enabled & apiKey present
                                if (!tmdb.enabled || !tmdb.apiKey) {
                                    window.__tmdbGenresLoading = false;
                                    return; // nothing to load yet
                                }
                                await loadTMDBGenres(tmdb.genreFilter || '');
                                window.__tmdbGenresLoaded = true;
                            } catch (e) {
                                // swallow but retry if attempts remain
                                if (attempt < maxAttempts) {
                                    const delay = 400 * attempt; // linear backoff
                                    setTimeout(run, delay);
                                }
                            } finally {
                                if (window.__tmdbGenresLoaded || attempt >= maxAttempts) {
                                    window.__tmdbGenresLoading = false;
                                }
                            }
                        };
                        run();
                    }
                })();
            } catch (_) {
                /* ignore */
            }
        }

        // Silent auto-hydration for Streaming Providers (TMDB dependent) with retry & instrumentation
        function maybeFetchStreamingProvidersOnOpen() {
            try {
                (async () => {
                    if (window.__streamingProvidersLoaded || window.__streamingProvidersLoading)
                        return;
                    const selectEl = document.getElementById('streaming.providers');
                    const hasOptions = !!(selectEl && selectEl.querySelector('option'));
                    if (hasOptions) {
                        window.__streamingProvidersLoaded = true;
                        return;
                    }
                    window.__streamingProvidersLoading = true;
                    const maxAttempts = 3;
                    let attempt = 0;
                    window.__streamingProvidersAttempts = window.__streamingProvidersAttempts || [];
                    const providerOpts = [
                        { value: 'netflix', label: 'Netflix' },
                        { value: 'disney', label: 'Disney+' },
                        { value: 'prime', label: 'Prime Video' },
                        { value: 'hbo', label: 'Max (HBO)' },
                        { value: 'hulu', label: 'Hulu' },
                        { value: 'apple', label: 'Apple TV+' },
                        { value: 'paramount', label: 'Paramount+' },
                        { value: 'crunchyroll', label: 'Crunchyroll' },
                    ];
                    const run = async () => {
                        attempt++;
                        window.__streamingProvidersAttempts.push({ attempt, ts: Date.now() });
                        try {
                            const cfgRes = await window.dedupJSON('/api/admin/config', {
                                credentials: 'include',
                            });
                            const base = cfgRes?.ok ? await cfgRes.json() : {};
                            const streaming =
                                base?.config?.streamingSources || base?.streamingSources || {};
                            const selected = Object.entries(streaming)
                                .filter(([k, v]) => v && providerOpts.some(p => p.value === k))
                                .map(([k]) => k);
                            if (typeof setMultiSelect === 'function') {
                                setMultiSelect('streaming.providers', providerOpts, selected);
                                if (typeof initMsForSelect === 'function') {
                                    initMsForSelect(
                                        'streaming-ms-providers',
                                        'streaming.providers'
                                    );
                                }
                            }
                            window.__streamingProvidersLoaded = true;
                        } catch (e) {
                            if (attempt < maxAttempts) setTimeout(run, 350 * attempt);
                        } finally {
                            if (window.__streamingProvidersLoaded || attempt >= maxAttempts) {
                                window.__streamingProvidersLoading = false;
                            }
                        }
                    };
                    run();
                })();
            } catch (_) {
                /* ignore */
            }
        }

        // attach helpers to admin2 namespace
        window.admin2.maybeFetchPlexOnOpen = maybeFetchPlexOnOpen;
        window.admin2.maybeFetchJellyfinOnOpen = maybeFetchJellyfinOnOpen;
        window.admin2.maybeFetchTmdbOnOpen = maybeFetchTmdbOnOpen;
        window.admin2.maybeFetchStreamingProvidersOnOpen = maybeFetchStreamingProvidersOnOpen;
        // Expose debug helpers for console diagnostics
        try {
            window.admin2.fetchLibraryCounts = fetchLibraryCounts;
            window.admin2.refreshOverviewCounts = refreshOverviewCounts;
            window.admin2.getSelectedLibraries = getSelectedLibraries;
            window.admin2.getMultiSelectValues = getMultiSelectValues;
            window.admin2.debugJf = async () => {
                const sel = getSelectedLibraries('jellyfin');
                const map = await fetchLibraryCounts('jellyfin');
                const keys = Array.from(map.keys());
                const norm = s => s.trim().toLowerCase();
                const mismatches = [...sel.movies, ...sel.shows].filter(
                    n => !keys.some(k => norm(k) === norm(n))
                );
                return {
                    selected: sel,
                    fetchedKeys: keys,
                    mismatches,
                    manualTotal: (() => {
                        const sum = arr =>
                            (arr || []).reduce((a, n) => {
                                const m = keys.find(k => norm(k) === norm(n));
                                return a + (m ? map.get(m)?.itemCount || 0 : 0);
                            }, 0);
                        return sum(sel.movies) + sum(sel.shows);
                    })(),
                };
            };
        } catch (_) {
            /* rotten tomatoes input snap failed (raw value accepted) */
        }

        // Fetch libraries
        async function fetchPlexLibraries(refreshFilters = false, silent = false) {
            // If any caller requests dependent refresh, mark it globally for this flight
            if (refreshFilters) window.__plexLibsRefreshRequested = true;
            // Deduplicate concurrent calls so only one request + toast occurs
            if (window.__plexLibsInFlight) return window.__plexLibsInFlight;
            window.__plexLibsInFlight = (async () => {
                try {
                    const hostname =
                        getInput('plex.hostname')?.value ||
                        document.getElementById('plex_hostname')?.value ||
                        undefined;
                    const port =
                        getInput('plex.port')?.value ||
                        document.getElementById('plex_port')?.value ||
                        undefined;
                    // Get token from: 1) dataset, 2) input value, 3) global token store, 4) undefined
                    const tokenInput =
                        getInput('plex.token') || document.getElementById('plex_token');
                    const token =
                        tokenInput?.dataset?.actualToken ||
                        tokenInput?.value ||
                        window.__tokenStore?.plexToken ||
                        undefined;
                    const res = await fetch('/api/admin/plex-libraries', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ hostname, port, token }),
                    });
                    const j = await res.json().catch(() => ({}));
                    if (!res.ok) throw new Error(j?.error || 'Failed to load Plex libraries');
                    const libs = Array.isArray(j.libraries) ? j.libraries : [];

                    // Store Plex name -> key mapping for posterpack generation
                    try {
                        window.__plexLibraryNameToId = new Map();
                        libs.forEach(l => {
                            if (l && l.name && (l.key || l.key === 0)) {
                                window.__plexLibraryNameToId.set(l.name, String(l.key));
                            }
                        });
                        // Also store type/counts for separation (movies vs shows)
                        window.__plexLibraryCounts = new Map();
                        libs.forEach(l => {
                            if (l && l.name) {
                                window.__plexLibraryCounts.set(l.name, {
                                    itemCount: Number(l.itemCount) || 0,
                                    type: l.type,
                                });
                            }
                        });
                    } catch (_) {
                        /* counts refresh optional; ignore */
                    }
                    const movies = libs
                        .filter(l => l.type === 'movie')
                        .map(l => ({ value: l.name, label: l.name, count: l.itemCount }));
                    const shows = libs
                        .filter(l => l.type === 'show')
                        .map(l => ({ value: l.name, label: l.name, count: l.itemCount }));

                    const prevMovies = new Set(getMultiSelectValues('plex.movies'));
                    const prevShows = new Set(getMultiSelectValues('plex.shows'));
                    // Auto-select all Plex libraries on very first successful load if user has none selected yet
                    let appliedAutoSelect = false;
                    if (
                        !window.__plexAutoSelected &&
                        prevMovies.size === 0 &&
                        prevShows.size === 0
                    ) {
                        const allMovieValues = movies.map(m => m.value);
                        const allShowValues = shows.map(s => s.value);
                        setMultiSelect('plex.movies', movies, allMovieValues);
                        setMultiSelect('plex.shows', shows, allShowValues);
                        window.__plexAutoSelected = true;
                        appliedAutoSelect = true;
                    } else if (
                        window.__plexAutoSelected &&
                        prevMovies.size === 0 &&
                        prevShows.size === 0
                    ) {
                        // We previously auto-selected but current selects appear empty (panel switch race). Reapply full selection.
                        const allMovieValues = movies.map(m => m.value);
                        const allShowValues = shows.map(s => s.value);
                        setMultiSelect('plex.movies', movies, allMovieValues);
                        setMultiSelect('plex.shows', shows, allShowValues);
                        appliedAutoSelect = true;
                    }
                    if (!appliedAutoSelect) {
                        setMultiSelect('plex.movies', movies, Array.from(prevMovies));
                        setMultiSelect('plex.shows', shows, Array.from(prevShows));
                    }
                    // If we just auto-selected everything, schedule a deferred rebuild to catch cases
                    // where the multiselect UI root wasn't wired yet at the exact moment of selection.
                    if (appliedAutoSelect) {
                        setTimeout(() => {
                            try {
                                rebuildMsForSelect('plex-ms-movies', 'plex.movies');
                                rebuildMsForSelect('plex-ms-shows', 'plex.shows');
                            } catch (_) {
                                /* delegated increment stopPropagation failed */
                            }
                        }, 0);
                    }
                    // Rebuild multiselect options
                    rebuildMsForSelect('plex-ms-movies', 'plex.movies');
                    rebuildMsForSelect('plex-ms-shows', 'plex.shows');
                    // If Posterpack source is currently Plex, immediately sync Posterpack lists
                    try {
                        const srcSel = document.getElementById('posterpack.source');
                        if (srcSel && srcSel.value === 'plex') {
                            populatePosterpackLibraries('plex');
                        }
                    } catch (_) {
                        /* posterpack library populate optional; ignore */
                    }
                    if (!silent) {
                        window.notify?.toast({
                            type: 'success',
                            title: 'Plex',
                            message: 'Plex libraries loaded',
                            duration: 2200,
                        });
                        window.__plexToastShown = true;
                    }
                    // Immediately refresh counts to update the header pill
                    try {
                        refreshOverviewCounts();
                    } catch (_) {
                        /* counts refresh optional; ignore */
                    }
                    // Optionally refresh dependent filters now that libraries are known
                    if (window.__plexLibsRefreshRequested) {
                        try {
                            const currentGenres = getPlexGenreFilterHidden?.() || '';
                            loadPlexGenres(currentGenres)?.catch?.(() => {});
                            loadPlexRatings?.(getPlexHidden?.('plex.ratingFilter-hidden'));
                            loadPlexQualities?.(getPlexHidden?.('plex.qualityFilter-hidden'));
                        } catch (_) {
                            /* no-op */
                        }
                    }
                } catch (e) {
                    if (!silent) {
                        window.notify?.toast({
                            type: 'error',
                            title: 'Plex',
                            message: e?.message || 'Failed to fetch libraries',
                            duration: 4200,
                        });
                    }
                } finally {
                    // Clear in-flight marker after settle so subsequent manual fetches are allowed
                    window.__plexLibsInFlight = null;
                    // Reset refresh request flag after one settled cycle
                    window.__plexLibsRefreshRequested = false;
                    // Post-fetch integrity safeguard
                    try {
                        ensureLibrarySelectionIntegrity('plex');
                    } catch (_) {
                        /* integrity post-check failed (selections remain as-is) */
                    }
                }
            })();
            return window.__plexLibsInFlight;
        }
        // Make function globally accessible for multiselect click handler
        window.__fetchPlexLibraries = fetchPlexLibraries;

        // Auto-fetch Plex libraries silently if host/port present but no options yet
        try {
            setTimeout(() => {
                try {
                    if (window.__plexAutoLibInit) return;
                    const hostVal =
                        getInput('plex.hostname')?.value ||
                        document.getElementById('plex_hostname')?.value;
                    const portVal =
                        getInput('plex.port')?.value || document.getElementById('plex_port')?.value;
                    const menuCount = document.querySelectorAll(
                        '#plex-ms-movies-menu .ms-option, #plex-ms-shows-menu .ms-option'
                    ).length;
                    if (hostVal && portVal && menuCount === 0) {
                        window.__plexAutoLibInit = true;
                        fetchPlexLibraries(true, true);
                    }
                } catch (_) {
                    /* media sources section observer setup failed (fallback retries still run) */
                }
            }, 600);
        } catch (_) {
            /* auto-fetch init optional; ignore */
        }

        // ------- Plex Genre Filter (chips with hidden input) -------
        function setPlexGenreFilterHidden(val) {
            const hidden = document.getElementById('plex.genreFilter-hidden');
            if (hidden) {
                hidden.value = val || '';
                // Ensure live counts update: trigger change so wireLiveMediaSourcePreview refreshes pills
                try {
                    hidden.dispatchEvent(new Event('change', { bubbles: true }));
                } catch (_) {
                    /* wrap observer setup failed (other triggers still attempt) */
                }
            }
        }
        function getPlexGenreFilterHidden() {
            const hidden = document.getElementById('plex.genreFilter-hidden');
            return hidden ? hidden.value : '';
        }
        function renderChip(container, label, value, selectedValuesSet) {
            const chip = document.createElement('button');
            chip.type = 'button';
            chip.className = 'chip';
            chip.setAttribute('data-value', value);
            chip.setAttribute('aria-pressed', selectedValuesSet.has(value) ? 'true' : 'false');
            const left = document.createElement('div');
            left.className = 'left';
            const icon = document.createElement('i');
            icon.className = selectedValuesSet.has(value) ? 'fas fa-check-circle' : 'far fa-circle';
            const span = document.createElement('span');
            span.className = 'title';
            span.textContent = label;
            left.appendChild(icon);
            left.appendChild(span);
            chip.appendChild(left);
            chip.addEventListener('click', () => {
                const current = new Set(
                    getPlexGenreFilterHidden()
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean)
                );
                if (current.has(value)) current.delete(value);
                else current.add(value);
                const newVal = Array.from(current).join(',');
                setPlexGenreFilterHidden(newVal);
                // toggle visual
                const pressed = chip.getAttribute('aria-pressed') === 'true';
                chip.setAttribute('aria-pressed', pressed ? 'false' : 'true');
                icon.className = pressed ? 'far fa-circle' : 'fas fa-check-circle';
            });
            container.appendChild(chip);
        }

        function populatePlexGenreChips(genres, selectedCsv) {
            const container = document.getElementById('plex.genreFilter');
            const select = document.getElementById('plex.genreFilter-select');
            if (!container) return;
            const selected = new Set(
                String(selectedCsv || '')
                    .split(',')
                    .map(s => s.trim())
                    .filter(Boolean)
            );
            container.innerHTML = '';
            if (select) {
                // Build dropdown with an "Add genre…" placeholder
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = 'Add genre…';
                select.innerHTML = '';
                select.appendChild(placeholder);
            }
            // Sort by count desc then name (normalize objects -> string names)
            const normName = g =>
                typeof g === 'string'
                    ? g
                    : (g && (g.genre || g.name || g.value || g.label || g.Title)) || String(g);
            const list = (genres || []).slice().sort((a, b) => {
                const ac = Number((a && a.count) || 0);
                const bc = Number((b && b.count) || 0);
                if (bc !== ac) return bc - ac;
                return String(normName(a)).localeCompare(String(normName(b)));
            });
            list.forEach(g => {
                const name = normName(g);
                const label = g.count != null ? `${name} (${g.count})` : name;
                renderChip(container, label, name, selected);
                if (select) {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    select.appendChild(opt);
                }
            });
            if (select) {
                // When user picks a genre from dropdown, add to selection and re-render icon state
                select.onchange = () => {
                    const val = select.value;
                    if (!val) return;
                    const current = new Set(
                        getPlexGenreFilterHidden()
                            .split(',')
                            .map(s => s.trim())
                            .filter(Boolean)
                    );
                    current.add(val);
                    const newVal = Array.from(current).join(',');
                    setPlexGenreFilterHidden(newVal);
                    // Update chip pressed state if it exists
                    const chip = container.querySelector(`[data-value="${CSS.escape(val)}"]`);
                    if (chip) {
                        chip.setAttribute('aria-pressed', 'true');
                        const icon = chip.querySelector('i');
                        if (icon) icon.className = 'fas fa-check-circle';
                    }
                    // reset dropdown to placeholder
                    select.value = '';
                };
            }
        }
        // Expose for reuse
        window.populatePlexGenreChips = populatePlexGenreChips;
        async function loadPlexGenres(currentValueCsv = '') {
            const chipsRoot = document.getElementById('plex-ms-genres-chips');
            const optsEl = document.getElementById('plex-ms-genres-options');
            const root = document.getElementById('plex-ms-genres');
            const control = root?.querySelector('.ms-control');
            const search = document.getElementById('plex-ms-genres-search');
            const menu = document.getElementById('plex-ms-genres-menu');
            if (!chipsRoot || !optsEl || !root || !control || !search) return;
            chipsRoot.innerHTML = '<div class="subtle">Loading genres…</div>';
            try {
                // Prefer test endpoint if user provided connection params
                const hostname = getInput('plex.hostname')?.value;
                const port = getInput('plex.port')?.value;
                // Get token from dataset first (actual token), fallback to input value
                const tokenInput = getInput('plex.token') || document.getElementById('plex_token');
                const token = tokenInput?.dataset?.actualToken || tokenInput?.value;
                let res;
                if (hostname && port) {
                    res = await window.dedupJSON('/api/admin/plex-genres-with-counts-test', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ hostname, port, token: token || undefined }),
                    });
                } else {
                    res = await window.dedupJSON('/api/admin/plex-genres-with-counts', {
                        credentials: 'include',
                    });
                }
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json().catch(() => ({}));
                const genres = Array.isArray(data?.genres) ? data.genres : [];
                // Build options list using normalized names from server objects
                const normName = g =>
                    typeof g === 'string'
                        ? g
                        : (g && (g.genre || g.name || g.value || g.label || g.Title)) || String(g);
                const names = genres
                    .slice()
                    .map(normName)
                    .sort((a, b) => a.localeCompare(b));
                const selected = new Set(
                    String(currentValueCsv || '')
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean)
                );
                // Options
                optsEl.innerHTML = '';
                names.forEach(n => {
                    const row = document.createElement('div');
                    row.className = 'ms-option';
                    row.dataset.value = n;
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = selected.has(n);
                    const span = document.createElement('span');
                    span.textContent = n;
                    row.appendChild(cb);
                    row.appendChild(span);
                    optsEl.appendChild(row);
                });
                // Chips render
                const renderChips = () => {
                    chipsRoot.innerHTML = '';
                    selected.forEach(v => {
                        const chip = document.createElement('span');
                        chip.className = 'ms-chip';
                        chip.dataset.value = v;
                        chip.innerHTML = `${v} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
                        chip.querySelector('.ms-chip-remove')?.addEventListener('click', e => {
                            e.stopPropagation();
                            selected.delete(v);
                            setPlexGenreFilterHidden(Array.from(selected).join(','));
                            syncOptions();
                            renderChips();
                            control.classList.toggle('has-selection', selected.size > 0);
                        });
                        chipsRoot.appendChild(chip);
                    });
                    control.classList.toggle('has-selection', selected.size > 0);
                };
                const syncOptions = () => {
                    document.querySelectorAll('#plex-ms-genres-options .ms-option').forEach(row => {
                        const v = row.dataset.value;
                        const cb = row.querySelector('input[type="checkbox"]');
                        if (cb) cb.checked = selected.has(v);
                    });
                };
                // Portalize menu to body and position it near control to avoid clipping
                if (menu && menu.parentElement !== document.body) {
                    document.body.appendChild(menu);
                    menu.style.position = 'fixed';
                    menu.style.zIndex = '9999';
                    menu.style.display = 'none';
                    menu.style.maxHeight = '60vh';
                    menu.style.overflow = 'auto';
                    menu.style.minWidth = '240px';
                }
                let onReposition;
                const positionMenu = () => {
                    if (!control || !menu) return;
                    const rect = control.getBoundingClientRect();
                    const viewportH = window.innerHeight || document.documentElement.clientHeight;
                    const belowSpace = viewportH - rect.bottom;
                    const estHeight = Math.min(menu.scrollHeight || 320, viewportH * 0.6);
                    const openUp = belowSpace < estHeight && rect.top > estHeight;
                    const top = openUp ? Math.max(8, rect.top - estHeight) : rect.bottom + 4;
                    const left = rect.left;
                    const width = Math.max(rect.width, 240);
                    menu.style.top = `${Math.round(top)}px`;
                    menu.style.left = `${Math.round(left)}px`;
                    menu.style.width = `${Math.round(width)}px`;
                    menu.style.maxHeight = `${Math.round(estHeight)}px`;
                };
                const openMenu = open => {
                    root.classList.toggle('ms-open', !!open);
                    control.setAttribute('aria-expanded', open ? 'true' : 'false');
                    if (!menu) return;
                    if (open) {
                        menu.style.display = 'block';
                        try {
                            menu.scrollTop = 0;
                            if (optsEl) optsEl.scrollTop = 0;
                        } catch (e) {
                            dbg('ms scroll reset failed (plex genres)', e);
                        }
                        positionMenu();
                        onReposition = () => positionMenu();
                        window.addEventListener('resize', onReposition, { passive: true });
                        window.addEventListener('scroll', onReposition, { passive: true });
                    } else {
                        menu.style.display = 'none';
                        if (onReposition) {
                            window.removeEventListener('resize', onReposition);
                            window.removeEventListener('scroll', onReposition);
                            onReposition = null;
                        }
                    }
                };
                // Wire interactions if not already
                if (root && root.dataset.msWired !== 'true') {
                    control.addEventListener('mousedown', e => {
                        e.preventDefault();
                        e.stopPropagation();
                        const willOpen = !root.classList.contains('ms-open');
                        openMenu(willOpen);
                        if (willOpen) setTimeout(() => search.focus(), 0);
                    });
                    document.addEventListener('click', e => {
                        if (!root.contains(e.target) && !(menu && menu.contains(e.target)))
                            openMenu(false);
                    });
                    search.addEventListener('focus', () => openMenu(true));
                    search.addEventListener('keydown', e => {
                        if (e.key === 'Escape') openMenu(false);
                    });
                    search.addEventListener('input', () => {
                        const q = search.value.toLowerCase();
                        Array.from(optsEl.children).forEach(ch => {
                            const label =
                                ch.querySelector('span')?.textContent?.toLowerCase() || '';
                            ch.style.display = label.includes(q) ? '' : 'none';
                        });
                    });
                    document
                        .getElementById('plex-ms-genres-select-all')
                        ?.addEventListener('click', e => {
                            e.preventDefault();
                            names.forEach(n => selected.add(n));
                            setPlexGenreFilterHidden(Array.from(selected).join(','));
                            syncOptions();
                            renderChips();
                        });
                    document
                        .getElementById('plex-ms-genres-clear-all')
                        ?.addEventListener('click', e => {
                            e.preventDefault();
                            selected.clear();
                            setPlexGenreFilterHidden('');
                            syncOptions();
                            renderChips();
                            search.value = '';
                        });
                    document
                        .getElementById('plex-ms-genres-clear')
                        ?.addEventListener('click', e => {
                            e.preventDefault();
                            selected.clear();
                            setPlexGenreFilterHidden('');
                            syncOptions();
                            renderChips();
                            search.value = '';
                        });
                    optsEl.addEventListener('click', e => {
                        const row = e.target.closest('.ms-option');
                        if (!row) return;
                        const v = row.dataset.value;
                        if (selected.has(v)) selected.delete(v);
                        else selected.add(v);
                        setPlexGenreFilterHidden(Array.from(selected).join(','));
                        syncOptions();
                        renderChips();
                    });
                    root.dataset.msWired = 'true';
                }
                // Initial paint and sync
                setPlexGenreFilterHidden(Array.from(selected).join(','));
                renderChips();
            } catch (e) {
                chipsRoot.innerHTML = '<div class="subtle">Failed to load genres</div>';
            }
        }
        async function fetchJellyfinLibraries(refreshFilters = false, silent = false) {
            // If any caller requests dependent refresh, mark it globally for this flight
            if (refreshFilters) window.__jfLibsRefreshRequested = true;
            // Deduplicate concurrent calls so only one request + toast occurs
            if (window.__jfLibsInFlight) return window.__jfLibsInFlight;
            window.__jfLibsInFlight = (async () => {
                try {
                    // debug removed: Jellyfin fetch start
                    const hostname = getInput('jf.hostname')?.value || undefined;
                    const port = getInput('jf.port')?.value || undefined;
                    // Get API key from dataset first (actual key), fallback to input value
                    const apiKeyInput = getInput('jf.apikey');
                    const apiKey =
                        apiKeyInput?.dataset?.actualToken || apiKeyInput?.value || undefined;
                    const insecureHttps = !!(
                        document.getElementById('jf.insecureHttps')?.checked ||
                        document.getElementById('jf.insecureHttpsHeader')?.checked
                    );
                    // debug removed: Jellyfin fetch resolved inputs
                    const effHostname = hostname || window.__JELLYFIN_ENTRY?.hostname;
                    const effPort = port || window.__JELLYFIN_ENTRY?.port;
                    const effApiKey = apiKey || window.__JELLYFIN_ENTRY?.apiKey;

                    // Skip enabled check when explicitly requested via button click (refreshFilters=true)
                    // This allows users to fetch libraries before enabling Jellyfin
                    if (!refreshFilters) {
                        const effEnabled = (() => {
                            try {
                                const cb = document.getElementById('jf.enabled');
                                if (cb) return !!cb.checked;
                            } catch (_) {
                                /* delegated decrement stopPropagation failed */
                            }
                            if (typeof window.__JELLYFIN_ENTRY?.enabled !== 'undefined') {
                                return !!window.__JELLYFIN_ENTRY.enabled;
                            }
                            return isJellyfinEnabledCached();
                        })();
                        if (!effEnabled) {
                            if (__debugOn)
                                console.debug('[Admin][Jellyfin][Fetch] abort: disabled');
                            if (!silent) {
                                window.notify?.toast?.({
                                    type: 'info',
                                    title: 'Jellyfin',
                                    message: 'Jellyfin disabled in configuration',
                                    duration: 2200,
                                });
                            }
                            return { skipped: true, libraries: [] };
                        }
                    }

                    if (!effHostname) {
                        if (__debugOn) console.debug('[Admin][Jellyfin][Fetch] abort: no hostname');
                        if (!silent) {
                            window.notify?.toast({
                                type: 'warning',
                                title: 'Jellyfin',
                                message: 'Hostname is required to fetch libraries',
                                duration: 3200,
                            });
                        }
                        return { skipped: true, libraries: [] };
                    }
                    const res = await fetch('/api/admin/jellyfin-libraries', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({
                            hostname: effHostname,
                            port: effPort,
                            apiKey: effApiKey,
                            insecureHttps,
                        }),
                    });
                    // debug removed: Jellyfin fetch response status
                    const j = await res.json().catch(() => ({}));
                    if (!res.ok) throw new Error(j?.error || 'Failed to load Jellyfin libraries');
                    const libs = Array.isArray(j.libraries) ? j.libraries : [];
                    // Store Jellyfin name -> id mapping for posterpack generation
                    try {
                        window.__jfLibraryNameToId = new Map();
                        libs.forEach(l => {
                            if (l && l.name && (l.key || l.key === 0 || l.id)) {
                                const id = String(l.key || l.id);
                                window.__jfLibraryNameToId.set(l.name, id);
                            }
                        });
                    } catch (_) {
                        /* panelActivated instrumentation failed (wrapping continues) */
                    }
                    // debug removed: Jellyfin libs received
                    // Build internal map for overview counts (parity with Plex fetch flow)
                    try {
                        window.__jfLibraryCounts = new Map();
                        libs.forEach(l => {
                            if (l && l.name) {
                                window.__jfLibraryCounts.set(l.name, {
                                    itemCount: Number(l.itemCount) || 0,
                                    type: l.type,
                                });
                            }
                        });
                    } catch (_) {
                        /* delegated spinner guard reset failed (non-critical) */
                    }
                    const movies = libs
                        .filter(l => l.type === 'movie')
                        .map(l => ({ value: l.name, label: l.name, count: l.itemCount }));
                    const shows = libs
                        .filter(l => l.type === 'show')
                        .map(l => ({ value: l.name, label: l.name, count: l.itemCount }));
                    const prevMovies = new Set(getMultiSelectValues('jf.movies'));
                    const prevShows = new Set(getMultiSelectValues('jf.shows'));
                    // Auto-select all Jellyfin libraries on very first successful load if user has none selected yet
                    let appliedAutoSelect = false;
                    if (!window.__jfAutoSelected && prevMovies.size === 0 && prevShows.size === 0) {
                        const allMovieValues = movies.map(m => m.value);
                        const allShowValues = shows.map(s => s.value);
                        setMultiSelect('jf.movies', movies, allMovieValues);
                        setMultiSelect('jf.shows', shows, allShowValues);
                        window.__jfAutoSelected = true;
                        appliedAutoSelect = true;
                    } else if (
                        window.__jfAutoSelected &&
                        prevMovies.size === 0 &&
                        prevShows.size === 0
                    ) {
                        // We previously auto-selected, but current selects came back empty (likely due to hidden panel rebuild timing).
                        // Preserve full selection instead of clearing.
                        const allMovieValues = movies.map(m => m.value);
                        const allShowValues = shows.map(s => s.value);
                        setMultiSelect('jf.movies', movies, allMovieValues);
                        setMultiSelect('jf.shows', shows, allShowValues);
                        appliedAutoSelect = true;
                    }
                    if (!appliedAutoSelect) {
                        setMultiSelect('jf.movies', movies, Array.from(prevMovies));
                        setMultiSelect('jf.shows', shows, Array.from(prevShows));
                    }
                    // If we just auto-selected everything, schedule a deferred rebuild to ensure chips render
                    // even if the multiselect wasn't wired at the initial moment.
                    if (appliedAutoSelect) {
                        setTimeout(() => {
                            try {
                                rebuildMsForSelect('jf-ms-movies', 'jf.movies');
                                rebuildMsForSelect('jf-ms-shows', 'jf.shows');
                            } catch (_) {
                                /* refreshBadge(true) on open failed (panel still opens) */
                            }
                        }, 0);
                    }
                    // Rebuild multiselect options
                    rebuildMsForSelect('jf-ms-movies', 'jf.movies');
                    rebuildMsForSelect('jf-ms-shows', 'jf.shows');
                    // If Posterpack source is currently Jellyfin, immediately sync Posterpack lists
                    try {
                        const srcSel = document.getElementById('posterpack.source');
                        if (srcSel && srcSel.value === 'jellyfin') {
                            populatePosterpackLibraries('jellyfin');
                        }
                    } catch (_) {
                        /* posterpack library populate optional; ignore */
                    }
                    if (!silent) {
                        window.notify?.toast({
                            type: 'success',
                            title: 'Jellyfin',
                            message: 'Jellyfin libraries loaded',
                            duration: 2200,
                        });
                    }
                    // Force recount after library data updates so totals reflect immediately
                    try {
                        refreshOverviewCounts();
                    } catch (_) {
                        /* counts refresh optional; ignore */
                    }
                    // Optionally refresh dependent filters now that libraries are known
                    try {
                        // Refresh overview item counts now that libraries are known (parity with Plex)
                        refreshOverviewCounts();
                    } catch (_) {
                        /* counts refresh optional; ignore */
                    }
                    if (window.__jfLibsRefreshRequested) {
                        try {
                            loadJellyfinRatings?.(getJfHidden?.('jf.ratingFilter-hidden'));
                            loadJellyfinGenres?.(getJfHidden?.('jf.genreFilter-hidden'));
                            // Jellyfin qualities disabled
                            loadJellyfinQualities?.('');
                        } catch (_) {
                            /* no-op */
                        }
                    }
                } catch (e) {
                    console.error('[Admin][Jellyfin][Fetch] failed', e); // keep errors
                    if (!silent) {
                        window.notify?.toast({
                            type: 'error',
                            title: 'Jellyfin',
                            message: e?.message || 'Failed to fetch libraries',
                            duration: 4200,
                        });
                    }
                } finally {
                    // Clear in-flight marker after settle so subsequent manual fetches are allowed
                    window.__jfLibsInFlight = null;
                    // Reset refresh request flag after one settled cycle
                    window.__jfLibsRefreshRequested = false;
                    // debug removed: Jellyfin fetch end
                    // Post-fetch integrity safeguard
                    try {
                        ensureLibrarySelectionIntegrity('jellyfin');
                    } catch (_) {
                        /* integrity post-check failed (selections remain as-is) */
                    }
                }
            })();
            return window.__jfLibsInFlight;
        }
        // Make function globally accessible for multiselect click handler
        window.__fetchJellyfinLibraries = fetchJellyfinLibraries;

        // ------- Jellyfin Multiselect Helpers (ratings/genres/qualities) -------
        function setJfHidden(id, val) {
            const el = document.getElementById(id);
            if (el) {
                el.value = val || '';
                try {
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                } catch (_) {
                    /* intersection observer setup failed (wrapping relies on other triggers) */
                }
            }
        }
        function getJfHidden(id) {
            const el = document.getElementById(id);
            return el ? el.value : '';
        }
        function jfMsOption(name, checked) {
            const row = document.createElement('div');
            row.className = 'ms-option';
            row.setAttribute('role', 'option');
            row.dataset.value = name;
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = !!checked;
            const label = document.createElement('span');
            label.textContent = name;
            row.appendChild(cb);
            row.appendChild(label);
            return row;
        }
        function jfAttachMsHandlers(baseId, options, selected, onUpdate) {
            const root = document.getElementById(baseId);
            if (!root || root.dataset.msWired === 'true') return;
            const control = root.querySelector('.ms-control');
            const menu = document.getElementById(baseId + '-menu');
            const search = document.getElementById(baseId + '-search');
            const selectAll = document.getElementById(baseId + '-select-all');
            const clearAll = document.getElementById(baseId + '-clear-all');
            const clearBtn = document.getElementById(baseId + '-clear');
            const optsEl = document.getElementById(baseId + '-options');
            const chips = document.getElementById(baseId + '-chips');
            if (!control || !menu || !search || !selectAll || !clearAll || !optsEl || !chips)
                return;

            const renderChips = () => {
                chips.innerHTML = '';
                Array.from(selected).forEach(v => {
                    const chip = document.createElement('span');
                    chip.className = 'ms-chip';
                    chip.dataset.value = v;
                    chip.innerHTML = `${v} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
                    chip.querySelector('.ms-chip-remove')?.addEventListener('click', e => {
                        e.stopPropagation();
                        selected.delete(v);
                        onUpdate(selected);
                        syncOptions();
                        renderChips();
                        control.classList.toggle('has-selection', selected.size > 0);
                    });
                    chips.appendChild(chip);
                });
                control.classList.toggle('has-selection', selected.size > 0);
            };
            const syncOptions = () => {
                Array.from(optsEl.children).forEach(row => {
                    const v = row.dataset.value;
                    const cb = row.querySelector('input[type="checkbox"]');
                    if (cb) cb.checked = selected.has(v);
                });
            };
            // Move menu into body to avoid clipping and position it near control
            if (menu && menu.parentElement !== document.body) {
                document.body.appendChild(menu);
                menu.style.position = 'fixed';
                menu.style.zIndex = '9999';
                menu.style.display = 'none';
                menu.style.maxHeight = '60vh';
                menu.style.overflow = 'auto';
                menu.style.minWidth = '240px';
            }
            let onReposition;
            const positionMenu = () => {
                if (!control || !menu) return;
                const rect = control.getBoundingClientRect();
                const viewportH = window.innerHeight || document.documentElement.clientHeight;
                const belowSpace = viewportH - rect.bottom;
                const estHeight = Math.min(menu.scrollHeight || 320, viewportH * 0.6);
                const openUp = belowSpace < estHeight && rect.top > estHeight;
                const top = openUp ? Math.max(8, rect.top - estHeight) : rect.bottom + 4;
                const left = rect.left;
                const width = Math.max(rect.width, 240);
                menu.style.top = `${Math.round(top)}px`;
                menu.style.left = `${Math.round(left)}px`;
                menu.style.width = `${Math.round(width)}px`;
                menu.style.maxHeight = `${Math.round(estHeight)}px`;
            };
            const openMenu = open => {
                root.classList.toggle('ms-open', !!open);
                control.setAttribute('aria-expanded', open ? 'true' : 'false');
                if (!menu) return;
                if (open) {
                    menu.style.display = 'block';
                    try {
                        menu.scrollTop = 0;
                        if (optsEl) optsEl.scrollTop = 0;
                    } catch (e) {
                        dbg('ms scroll reset failed (jf)', e);
                    }
                    positionMenu();
                    onReposition = () => positionMenu();
                    window.addEventListener('resize', onReposition, { passive: true });
                    window.addEventListener('scroll', onReposition, { passive: true });
                } else {
                    menu.style.display = 'none';
                    if (onReposition) {
                        window.removeEventListener('resize', onReposition);
                        window.removeEventListener('scroll', onReposition);
                        onReposition = null;
                    }
                }
            };
            const filterOptions = q => {
                const qq = (q || '').toLowerCase();
                Array.from(optsEl.children).forEach(child => {
                    const match = child.dataset.value?.toLowerCase().includes(qq);
                    child.style.display = match ? '' : 'none';
                });
            };

            control.addEventListener('mousedown', e => {
                e.preventDefault();
                e.stopPropagation();
                const willOpen = !root.classList.contains('ms-open');
                openMenu(willOpen);
                if (willOpen) setTimeout(() => search.focus(), 0);
            });
            document.addEventListener('click', e => {
                if (!root.contains(e.target) && !(menu && menu.contains(e.target))) openMenu(false);
            });
            search.addEventListener('focus', () => openMenu(true));
            search.addEventListener('keydown', e => {
                if (e.key === 'Escape') openMenu(false);
            });
            search.addEventListener('input', () => filterOptions(search.value));
            selectAll.addEventListener('click', e => {
                e.preventDefault();
                options.forEach(n => selected.add(n));
                onUpdate(selected);
                syncOptions();
                renderChips();
            });
            clearAll.addEventListener('click', e => {
                e.preventDefault();
                selected.clear();
                onUpdate(selected);
                syncOptions();
                renderChips();
                search.value = '';
                filterOptions('');
            });
            clearBtn?.addEventListener('click', e => {
                e.preventDefault();
                selected.clear();
                onUpdate(selected);
                syncOptions();
                renderChips();
                search.value = '';
                filterOptions('');
            });
            optsEl.addEventListener('click', e => {
                const row = e.target.closest('.ms-option');
                if (!row) return;
                const v = row.dataset.value;
                if (selected.has(v)) selected.delete(v);
                else selected.add(v);
                onUpdate(selected);
                syncOptions();
                renderChips();
            });
            root.dataset.msWired = 'true';
            renderChips();
        }
        async function loadJellyfinRatings(currentCsv = '') {
            const chips = document.getElementById('jf-ms-ratings-chips');
            const optsEl = document.getElementById('jf-ms-ratings-options');
            const control = document.querySelector('#jf-ms-ratings .ms-control');
            const root = document.getElementById('jf-ms-ratings');
            if (!chips || !optsEl || !control) return;
            chips.innerHTML = '<div class="subtle">Loading ratings…</div>';
            try {
                const res = await window.dedupJSON('/api/sources/jellyfin/ratings-with-counts', {
                    credentials: 'include',
                });
                const data = await res.json().catch(() => ({}));
                const arr = Array.isArray(data?.data) ? data.data : [];
                const ratings = arr
                    .map(r => r.rating)
                    .filter(Boolean)
                    .sort();
                const selected = new Set(
                    String(currentCsv || '')
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean)
                );
                optsEl.innerHTML = '';
                ratings.forEach(n => optsEl.appendChild(jfMsOption(n, selected.has(n))));
                setJfHidden('jf.ratingFilter-hidden', Array.from(selected).join(','));
                if (root?.dataset.msWired === 'true') {
                    const syncOptions = () => {
                        Array.from(optsEl.children).forEach(row => {
                            const v = row.dataset.value;
                            const cb = row.querySelector('input[type="checkbox"]');
                            if (cb) cb.checked = selected.has(v);
                        });
                    };
                    const renderChips = () => {
                        chips.innerHTML = '';
                        Array.from(selected).forEach(v => {
                            const chip = document.createElement('span');
                            chip.className = 'ms-chip';
                            chip.dataset.value = v;
                            chip.innerHTML = `${v} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
                            chip.querySelector('.ms-chip-remove')?.addEventListener('click', e => {
                                e.stopPropagation();
                                selected.delete(v);
                                setJfHidden(
                                    'jf.ratingFilter-hidden',
                                    Array.from(selected).join(',')
                                );
                                syncOptions();
                                renderChips();
                                control.classList.toggle('has-selection', selected.size > 0);
                            });
                            chips.appendChild(chip);
                        });
                        control.classList.toggle('has-selection', selected.size > 0);
                    };
                    syncOptions();
                    renderChips();
                } else {
                    jfAttachMsHandlers('jf-ms-ratings', ratings, selected, sel =>
                        setJfHidden('jf.ratingFilter-hidden', Array.from(sel).join(','))
                    );
                }
            } catch (e) {
                chips.innerHTML = '<div class="subtle">Failed to load ratings</div>';
            }
        }
        // (No loadJellyfinQualities here — defined later)
        async function loadJellyfinGenres(currentCsv = '') {
            const chips = document.getElementById('jf-ms-genres-chips');
            const optsEl = document.getElementById('jf-ms-genres-options');
            const control = document.querySelector('#jf-ms-genres .ms-control');
            const root = document.getElementById('jf-ms-genres');
            if (!chips || !optsEl || !control) return;
            chips.innerHTML = '<div class="subtle">Loading genres…</div>';
            try {
                const hostname = getInput('jf.hostname')?.value;
                const port = getInput('jf.port')?.value;
                // Get API key from dataset first (actual key), fallback to input value
                const apiKeyInput = getInput('jf.apikey');
                const apiKey = apiKeyInput?.dataset?.actualToken || apiKeyInput?.value;
                const movieLibraries = getMultiSelectValues('jf.movies');
                const showLibraries = getMultiSelectValues('jf.shows');
                // If no libraries are selected yet, don't call the API (it requires at least one)
                if (movieLibraries.length === 0 && showLibraries.length === 0) {
                    chips.innerHTML =
                        '<div class="subtle">Select one or more libraries to load genres</div>';
                    optsEl.innerHTML = '';
                    setJfHidden('jf.genreFilter-hidden', '');
                    return;
                }
                const res = await window.dedupJSON('/api/admin/jellyfin-genres-with-counts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        hostname,
                        port,
                        apiKey: apiKey || undefined,
                        movieLibraries,
                        showLibraries,
                    }),
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok) throw new Error(data?.error || 'Failed');
                const names = (data?.genres || [])
                    .map(g => g.genre || g.name || g.value || String(g))
                    .filter(Boolean)
                    .sort((a, b) => a.localeCompare(b));
                const selected = new Set(
                    String(currentCsv || '')
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean)
                );
                optsEl.innerHTML = '';
                names.forEach(n => optsEl.appendChild(jfMsOption(n, selected.has(n))));
                setJfHidden('jf.genreFilter-hidden', Array.from(selected).join(','));
                if (root?.dataset.msWired === 'true') {
                    const syncOptions = () => {
                        Array.from(optsEl.children).forEach(row => {
                            const v = row.dataset.value;
                            const cb = row.querySelector('input[type="checkbox"]');
                            if (cb) cb.checked = selected.has(v);
                        });
                    };
                    const renderChips = () => {
                        chips.innerHTML = '';
                        Array.from(selected).forEach(v => {
                            const chip = document.createElement('span');
                            chip.className = 'ms-chip';
                            chip.dataset.value = v;
                            chip.innerHTML = `${v} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
                            chip.querySelector('.ms-chip-remove')?.addEventListener('click', e => {
                                e.stopPropagation();
                                selected.delete(v);
                                setJfHidden(
                                    'jf.genreFilter-hidden',
                                    Array.from(selected).join(',')
                                );
                                syncOptions();
                                renderChips();
                                control.classList.toggle('has-selection', selected.size > 0);
                            });
                            chips.appendChild(chip);
                        });
                        control.classList.toggle('has-selection', selected.size > 0);
                    };
                    syncOptions();
                    renderChips();
                } else {
                    jfAttachMsHandlers('jf-ms-genres', names, selected, sel =>
                        setJfHidden('jf.genreFilter-hidden', Array.from(sel).join(','))
                    );
                }
            } catch (e) {
                chips.innerHTML = '<div class="subtle">Failed to load genres</div>';
            }
        }
        async function loadJellyfinQualities(_currentCsv = '') {
            // Disable Jellyfin quality filtering in UI; clear state and show notice
            const root = document.getElementById('jf-ms-qualities');
            const chips = document.getElementById('jf-ms-qualities-chips');
            const optsEl = document.getElementById('jf-ms-qualities-options');
            if (root) root.classList.add('disabled');
            if (chips)
                chips.innerHTML =
                    '<div class="subtle">Qualiteitsfilter is uitgeschakeld voor Jellyfin</div>';
            if (optsEl) optsEl.innerHTML = '';
            if (typeof setJfHidden === 'function') setJfHidden('jf.qualityFilter-hidden', '');
            return;
        }

        // Test connections
        // Small helper to show a spinner on icon-only buttons
        function startBtnSpinner(btn) {
            if (!btn) return;
            if (!btn.dataset.prevHtml) btn.dataset.prevHtml = btn.innerHTML;
            btn.disabled = true;
            btn.classList.add('btn-loading');
            btn.setAttribute('aria-busy', 'true');
            // Use a CSS spinner element (no <i> to avoid being hidden by loading styles)
            btn.innerHTML =
                '<span class="spinner" aria-hidden="true" style="display:inline-block"></span>' +
                (btn.dataset.prevHtml || '');
        }
        function stopBtnSpinner(btn) {
            if (!btn) return;
            btn.innerHTML = btn.dataset.prevHtml || btn.innerHTML;
            btn.classList.remove('btn-loading');
            btn.disabled = false;
            btn.removeAttribute('aria-busy');
        }

        function setPlexStatus(text, variant = '', _url = '') {
            const pill = document.getElementById('plex-status-pill-header');
            if (pill) {
                pill.textContent = text;
                pill.classList.remove('status-success', 'status-error');
                if (variant) pill.classList.add(variant);
            }
            // URL is not shown in the header pill to keep it compact
        }

        async function testPlex() {
            const btn = document.getElementById('btn-plex-test');
            startBtnSpinner(btn);
            try {
                const hostname =
                    getInput('plex.hostname')?.value ||
                    document.getElementById('plex_hostname')?.value ||
                    '';
                const port =
                    getInput('plex.port')?.value ||
                    document.getElementById('plex_port')?.value ||
                    '';
                // Get token from dataset first (actual token), fallback to input value
                const tokenInput = getInput('plex.token') || document.getElementById('plex_token');
                const token = tokenInput?.dataset?.actualToken || tokenInput?.value || '';

                if (__debugOn) {
                    console.debug('[Admin][Plex][Test] Token resolution', {
                        hasDatasetToken: !!tokenInput?.dataset?.actualToken,
                        hasInputValue: !!tokenInput?.value,
                        tokenLength: token.length,
                        usingDataset: !!tokenInput?.dataset?.actualToken,
                    });
                }

                if (__debugOn) {
                    console.debug('[Admin][Plex][Test] Resolved inputs', {
                        fromNewHostname: getInput('plex.hostname')?.value,
                        fromLegacyHostname: document.getElementById('plex_hostname')?.value,
                        fromNewPort: getInput('plex.port')?.value,
                        fromLegacyPort: document.getElementById('plex_port')?.value,
                        finalHostname: hostname,
                        finalPort: port,
                    });
                }
                if (!hostname || !port) throw new Error('Hostname and port are required');
                const res = await fetch('/api/admin/test-plex', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ hostname, port, token: token || undefined }),
                });
                const j = await res.json().catch(() => ({}));
                if (!res.ok) throw new Error(j?.error || 'Connection failed');

                // SUCCESS! Save the token to dataset and localStorage
                if (token && tokenInput) {
                    tokenInput.dataset.actualToken = token;
                    localStorage.setItem('plex_token_temp', token);
                    console.log(
                        '[Plex Test] Success! Token saved to dataset and localStorage:',
                        token.length,
                        'chars'
                    );
                }

                window.notify?.toast({
                    type: 'success',
                    title: 'Plex',
                    message: 'Connection successful',
                    duration: 2200,
                });
                const portNum = Number(port);
                const hostClean = String(hostname)
                    .replace(/^https?:\/\//i, '')
                    .replace(/\/?$/, '');
                const protocol =
                    portNum === 443
                        ? 'https'
                        : /^https:\/\//i.test(hostname)
                          ? 'https'
                          : /^http:\/\//i.test(hostname)
                            ? 'http'
                            : 'http';
                const basePlex = `${protocol}://${hostClean}`;
                const url = `${basePlex}:${port}/web`;
                setPlexStatus('Connected', 'status-success', url);
                const linkPlex = document.getElementById('plex-open-link');
                if (linkPlex) {
                    linkPlex.href = url;
                    linkPlex.removeAttribute('hidden');
                }
                // On success, offer to fetch libraries
                fetchPlexLibraries(true, true);
                // And refresh available filters using the same connection context
                const currentGenres = getPlexGenreFilterHidden();
                loadPlexGenres(currentGenres).catch(() => {});
                loadPlexRatings(getPlexHidden('plex.ratingFilter-hidden'));
                loadPlexQualities(getPlexHidden('plex.qualityFilter-hidden'));
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Plex',
                    message: e?.message || 'Connection failed',
                    duration: 4200,
                });
                setPlexStatus('Connection failed', 'status-error', '');
            } finally {
                stopBtnSpinner(btn);
            }
        }
        async function testJellyfin() {
            const btn = document.getElementById('btn-jf-test');
            startBtnSpinner(btn);
            try {
                const hostname = getInput('jf.hostname')?.value || '';
                const port = getInput('jf.port')?.value || '';
                // Get API key from dataset first (actual key), fallback to input value
                const apiKeyInput = getInput('jf.apikey');
                const apiKey = apiKeyInput?.dataset?.actualToken || apiKeyInput?.value || '';
                const insecureHttps = !!(
                    document.getElementById('jf.insecureHttps')?.checked ||
                    document.getElementById('jf.insecureHttpsHeader')?.checked
                );
                if (!hostname || !port) throw new Error('Hostname and port are required');
                const res = await fetch('/api/admin/test-jellyfin', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        hostname,
                        port,
                        apiKey: apiKey || undefined,
                        insecureHttps,
                    }),
                });
                const j = await res.json().catch(() => ({}));
                if (!res.ok) throw new Error(j?.error || 'Connection failed');

                // SUCCESS! Save the API key to dataset and localStorage
                if (apiKey && apiKeyInput) {
                    apiKeyInput.dataset.actualToken = apiKey;
                    localStorage.setItem('jf_apikey_temp', apiKey);
                    console.log(
                        '[Jellyfin Test] Success! Key saved to dataset and localStorage:',
                        apiKey.length,
                        'chars'
                    );
                }

                window.notify?.toast({
                    type: 'success',
                    title: 'Jellyfin',
                    message: 'Connection successful',
                    duration: 2200,
                });
                const pill = document.getElementById('jf-status-pill-header');
                if (pill) {
                    pill.textContent = 'Connected';
                    pill.classList.remove('status-error', 'is-not-configured');
                    pill.classList.add('status-success', 'is-configured');
                }
                const linkJf = document.getElementById('jf-open-link');
                if (linkJf && hostname && port) {
                    const portNum = Number(port);
                    const hostClean = String(hostname)
                        .replace(/^https?:\/\//i, '')
                        .replace(/\/?$/, '');
                    const protocol =
                        portNum === 443
                            ? 'https'
                            : /^https:\/\//i.test(hostname)
                              ? 'https'
                              : /^http:\/\//i.test(hostname)
                                ? 'http'
                                : 'http';
                    const base = `${protocol}://${hostClean}`;
                    linkJf.href = `${base}:${port}/web`;
                    linkJf.removeAttribute('hidden');
                }
                fetchJellyfinLibraries();
                // Refresh dependent filters
                loadJellyfinRatings(getJfHidden('jf.ratingFilter-hidden'));
                loadJellyfinGenres(getJfHidden('jf.genreFilter-hidden'));
                // Jellyfin qualities disabled
                loadJellyfinQualities('');
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Jellyfin',
                    message: e?.message || 'Connection failed',
                    duration: 4200,
                });
                const pill = document.getElementById('jf-status-pill-header');
                if (pill) {
                    pill.textContent = 'Connection failed';
                    pill.classList.remove('status-success', 'is-configured');
                    pill.classList.add('status-error', 'is-not-configured');
                }
            } finally {
                stopBtnSpinner(btn);
            }
        }
        async function testTMDB() {
            const btn = document.getElementById('btn-tmdb-test');
            startBtnSpinner(btn);
            try {
                // Get API key from dataset first (actual key), fallback to input value
                const apiKeyInput = getInput('tmdb.apikey');
                const apiKey = apiKeyInput?.dataset?.actualToken || apiKeyInput?.value || '';
                const category = getInput('tmdb.category')?.value || 'popular';
                const res = await fetch('/api/admin/test-tmdb', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ apiKey: apiKey || undefined, category }),
                });
                const j = await res.json().catch(() => ({}));
                if (!res.ok || !j?.success) throw new Error(j?.error || 'TMDB test failed');

                // SUCCESS! Save the API key to dataset and localStorage
                if (apiKey && apiKeyInput) {
                    apiKeyInput.dataset.actualToken = apiKey;
                    localStorage.setItem('tmdb_apikey_temp', apiKey);
                    console.log(
                        '[TMDB Test] Success! Key saved to dataset and localStorage:',
                        apiKey.length,
                        'chars'
                    );
                }

                window.notify?.toast({
                    type: 'success',
                    title: 'TMDB',
                    message: 'Connection successful',
                    duration: 2200,
                });
                const pill = document.getElementById('tmdb-status-pill-header');
                if (pill) {
                    pill.textContent = 'Connected';
                    pill.classList.remove('status-error', 'is-not-configured');
                    pill.classList.add('status-success', 'is-configured');
                }
                // On success, reload genres in case API key unlocks genre list
                const curr = getTMDBGenreFilterHidden();
                loadTMDBGenres(curr).catch(() => {});
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'TMDB',
                    message: e?.message || 'Connection failed',
                    duration: 4200,
                });
                const pill = document.getElementById('tmdb-status-pill-header');
                if (pill) {
                    pill.textContent = 'Connection failed';
                    pill.classList.remove('status-success', 'is-configured');
                    pill.classList.add('status-error', 'is-not-configured');
                }
            } finally {
                stopBtnSpinner(btn);
            }
        }
        // Test Streaming (TMDB providers)
        async function testStreaming() {
            const btn = document.getElementById('test-streaming-button');
            if (!btn) return;
            startBtnSpinner(btn);
            const status = document.getElementById('streaming-connection-status');
            try {
                const enabled = !!document.getElementById('streamingSources.enabled')?.checked;
                if (!enabled) {
                    window.notify?.toast({
                        type: 'warning',
                        title: 'Streaming',
                        message: 'Streaming sources are disabled',
                        duration: 3000,
                    });
                    return;
                }
                // No inline 'Testing…' status; use toasts only for disabled/failure/errors
                const region = document.getElementById('streamingSources.region')?.value || 'US';
                let apiKey = document.getElementById('tmdb.apikey')?.value?.trim() || '';
                // If the field shows the masked placeholder, use the stored key on the server
                if (apiKey === '••••••••') apiKey = 'stored_key';
                if (!apiKey) apiKey = 'stored_key';
                const res = await fetch('/api/admin/test-tmdb', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ testType: 'streaming', region, apiKey }),
                });
                const j = await res.json().catch(() => ({}));
                if (res.ok && j?.success) {
                    if (status) {
                        status.textContent = `Streaming API ready (Region: ${region})`;
                        status.style.color = '#51cf66';
                    }
                    window.notify?.toast({
                        type: 'success',
                        title: 'Streaming',
                        message: `Connection successful (Region: ${region})`,
                        duration: 2400,
                    });
                } else {
                    const err = j?.error || `HTTP ${res.status}`;
                    window.notify?.toast({
                        type: 'error',
                        title: 'Streaming',
                        message: `Connection failed: ${err}`,
                        duration: 4200,
                    });
                }
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Streaming',
                    message: `Test error: ${e?.message || 'Unknown error'}`,
                    duration: 4200,
                });
            } finally {
                stopBtnSpinner(btn);
            }
        }

        // Per-source save helpers
        async function savePlex() {
            const btn = document.getElementById('btn-save-plex');
            btn?.classList.add('btn-loading');
            try {
                // Capture pre-click restart intent as a fallback
                let preNeedsRestart = false;
                try {
                    preNeedsRestart = !!sourceRestartNeeded?.('plex');
                    if (preNeedsRestart && btn) btn.dataset.restartRequired = 'true';
                } catch (_) {
                    /* DOMContentLoaded hook wiring failed (later load handlers still run) */
                }
                const cfgRes = await window.dedupJSON('/api/admin/config', {
                    credentials: 'include',
                });
                const base = cfgRes.ok ? await cfgRes.json() : {};
                const currentCfg = base?.config || base || {};
                // Determine pre-save enabled state based on persisted config first (source of truth)
                const plexToggle = getInput('plex.enabled');
                let originalEnabled;
                const sCfg = (
                    Array.isArray(currentCfg.mediaServers) ? currentCfg.mediaServers : []
                ).find(x => x.type === 'plex');
                if (sCfg && typeof sCfg.enabled === 'boolean') {
                    originalEnabled = !!sCfg.enabled;
                } else {
                    // Fallback to UI baseline if config parsing failed
                    originalEnabled =
                        plexToggle?.dataset?.originalEnabled === 'true'
                            ? true
                            : plexToggle?.dataset?.originalEnabled === 'false'
                              ? false
                              : undefined;
                }
                const servers = Array.isArray(currentCfg.mediaServers)
                    ? [...currentCfg.mediaServers]
                    : [];
                const plexIdx = servers.findIndex(s => s.type === 'plex');
                const plex = plexIdx >= 0 ? { ...servers[plexIdx] } : { type: 'plex' };
                // Update Plex fields
                plex.enabled = !!getInput('plex.enabled')?.checked;
                plex.recentlyAddedOnly = !!getInput('plex.recentOnlyHeader')?.checked;
                plex.recentlyAddedDays = toInt(getInput('plex.recentDays')?.value) ?? 30;
                // From multiselect hidden fields
                plex.ratingFilter = parseCsvList(getPlexHidden('plex.ratingFilter-hidden'));
                // Save Plex qualities as CSV (supports multiple)
                plex.qualityFilter = (getPlexHidden('plex.qualityFilter-hidden') || '').trim();
                {
                    const expr = parseYearExpression(getInput('plex.yearFilter')?.value);
                    plex.yearFilter = expr;
                }
                plex.genreFilter = getPlexGenreFilterHidden();
                plex.movieLibraryNames = getMultiSelectValues('plex.movies');
                plex.showLibraryNames = getMultiSelectValues('plex.shows');
                // Ensure token env var retained; hostname/port now stored directly in config
                plex.tokenEnvVar = plex.tokenEnvVar || 'PLEX_TOKEN';
                if (plexIdx >= 0) servers[plexIdx] = plex;
                else servers.push(plex);
                // Env updates (only if provided)
                const envPatch = {};
                const setIfProvided = (key, val) => {
                    if (val != null && String(val).trim() !== '')
                        envPatch[key] = String(val).trim();
                };
                const plexTokenEl = getInput('plex.token');
                const plexToken = plexTokenEl?.value?.trim();
                // Try to get token from data attribute, then localStorage, then field value
                const actualToken =
                    plexTokenEl?.dataset?.actualToken ||
                    plexToken ||
                    window.__tokenStore?.plexToken ||
                    localStorage.getItem('plex_token_temp');

                // DEBUG: Log token state for troubleshooting
                console.log(
                    '[PLEX SAVE DEBUG] Token field value:',
                    plexToken ? `"${plexToken.substring(0, 10)}..."` : '(empty)'
                );
                console.log(
                    '[PLEX SAVE DEBUG] Token from dataset:',
                    actualToken ? `"${actualToken.substring(0, 10)}..."` : '(empty)'
                );
                console.log(
                    '[PLEX SAVE DEBUG] Token length:',
                    actualToken ? actualToken.length : 0
                );
                // Check if it's a masked value (all bullet points) or the EXISTING_TOKEN marker
                const isMaskedToken =
                    actualToken && (/^[•]+$/.test(actualToken) || actualToken === 'EXISTING_TOKEN');
                console.log('[PLEX SAVE DEBUG] Is masked token:', isMaskedToken);
                console.log(
                    '[PLEX SAVE DEBUG] Will send token:',
                    !!(actualToken && !isMaskedToken)
                );
                // Only update token if user entered a new value (not empty, not masked)
                if (actualToken && !isMaskedToken) {
                    setIfProvided(plex.tokenEnvVar, actualToken);
                    // Save token to localStorage so it persists after page reload
                    localStorage.setItem('plex_token_temp', actualToken);
                    console.log(
                        '[PLEX SAVE DEBUG] Token added to envPatch with key:',
                        plex.tokenEnvVar
                    );
                    console.log('[PLEX SAVE DEBUG] Token saved to localStorage');
                } else {
                    console.log(
                        '[PLEX SAVE DEBUG] Token SKIPPED - will preserve existing value on server'
                    );
                }
                // If empty or masked, token is intentionally omitted so backend preserves existing value
                // Persist direct hostname/port inside mediaServers entry
                // Some templates (legacy or cached) still render inputs with ids 'plex_hostname' / 'plex_port'.
                // Use both modern (dot) and legacy (underscore) IDs so a stale cached HTML file does not block saving.
                const hostEl =
                    getInput('plex.hostname') || document.getElementById('plex_hostname');
                const portEl = getInput('plex.port') || document.getElementById('plex_port');
                const hostRaw = hostEl?.value?.trim();
                if (hostRaw) plex.hostname = hostRaw;
                const portRaw = portEl?.value?.trim();
                if (portRaw && !Number.isNaN(Number(portRaw))) plex.port = Number(portRaw);
                // DEBUG: Log what we're sending
                console.log('[PLEX SAVE DEBUG] envPatch keys:', Object.keys(envPatch));
                console.log('[PLEX SAVE DEBUG] envPatch:', envPatch);
                await saveConfigPatch({ mediaServers: servers }, envPatch);
                window.notify?.toast({
                    type: 'success',
                    title: 'Saved',
                    message: 'Plex settings updated',
                    duration: 2500,
                });
                // After saving, if enabled state changed, update marker and restart
                try {
                    if (plexToggle) {
                        plexToggle.dataset.originalEnabled = plex.enabled ? 'true' : 'false';
                    }
                    const changed =
                        typeof originalEnabled === 'boolean'
                            ? originalEnabled !== !!plex.enabled
                            : true;
                    // Also detect by pre-click need or visible label text
                    const spanText = (btn?.querySelector('span')?.textContent || '').toLowerCase();
                    const needsRestart =
                        changed ||
                        preNeedsRestart ||
                        btn?.dataset?.restartRequired === 'true' ||
                        spanText.includes('restart');

                    if (needsRestart) {
                        const span = btn?.querySelector('span');
                        if (span) span.textContent = 'Save Settings & Restart';
                        btn && (btn.dataset.restartRequired = 'true');
                        await window.triggerRestartAndPoll();
                    }
                } catch (e) {
                    console.error('Plex restart check error:', e);
                }
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Save failed',
                    message: e?.message || 'Unable to save Plex',
                    duration: 4500,
                });
            } finally {
                btn?.classList.remove('btn-loading');
                // allow one auto-fetch after save on next load
                if (window.__autoFetchedLibs) window.__autoFetchedLibs.plex = false;
                loadMediaSources(true)
                    .then(() => {
                        const r = getPlexGenreFilterHidden();
                        loadPlexGenres(r).catch(() => {});
                        loadPlexRatings(getPlexHidden('plex.ratingFilter-hidden'));
                        loadPlexQualities(getPlexHidden('plex.qualityFilter-hidden'));
                    })
                    .catch(() => {});
            }
        }

        async function saveJellyfin() {
            const btn = document.getElementById('btn-save-jellyfin');
            btn?.classList.add('btn-loading');
            try {
                // Capture pre-click restart intent as a fallback
                let preNeedsRestart = false;
                try {
                    preNeedsRestart = !!sourceRestartNeeded?.('jellyfin');
                    if (preNeedsRestart && btn) btn.dataset.restartRequired = 'true';
                } catch (_) {
                    /* admin2 wrap debug export failed (diagnostic only) */
                }
                const cfgRes = await window.dedupJSON('/api/admin/config', {
                    credentials: 'include',
                });
                const base = cfgRes.ok ? await cfgRes.json() : {};
                const currentCfg = base?.config || base || {};
                // Determine pre-save enabled state for restart decision
                const jfToggle = getInput('jf.enabled');
                let originalEnabled;
                const sCfg = (
                    Array.isArray(currentCfg.mediaServers) ? currentCfg.mediaServers : []
                ).find(x => x.type === 'jellyfin');
                if (sCfg && typeof sCfg.enabled === 'boolean') {
                    originalEnabled = !!sCfg.enabled;
                } else {
                    originalEnabled =
                        jfToggle?.dataset?.originalEnabled === 'true'
                            ? true
                            : jfToggle?.dataset?.originalEnabled === 'false'
                              ? false
                              : undefined;
                }
                const servers = Array.isArray(currentCfg.mediaServers)
                    ? [...currentCfg.mediaServers]
                    : [];
                const jfIdx = servers.findIndex(s => s.type === 'jellyfin');
                const jf = jfIdx >= 0 ? { ...servers[jfIdx] } : { type: 'jellyfin' };
                jf.enabled = !!getInput('jf.enabled')?.checked;
                jf.recentlyAddedOnly = !!getInput('jf.recentOnlyHeader')?.checked;
                jf.recentlyAddedDays = toInt(getInput('jf.recentDays')?.value) ?? 30;
                {
                    const expr = parseYearExpression(getInput('jf.yearFilter')?.value);
                    jf.yearFilter = expr;
                }
                // Collect multiselect values
                const ratingCsv = getJfHidden('jf.ratingFilter-hidden');
                jf.ratingFilter = parseCsvList(ratingCsv);
                jf.genreFilter = getJfHidden('jf.genreFilter-hidden');
                // Jellyfin qualities disabled
                jf.qualityFilter = '';
                jf.movieLibraryNames = getMultiSelectValues('jf.movies');
                jf.showLibraryNames = getMultiSelectValues('jf.shows');
                jf.tokenEnvVar = jf.tokenEnvVar || 'JELLYFIN_API_KEY';
                if (jfIdx >= 0) servers[jfIdx] = jf;
                else servers.push(jf);
                const envPatch = {};
                const setIfProvided = (key, val) => {
                    if (val != null && String(val).trim() !== '')
                        envPatch[key] = String(val).trim();
                };
                // Get API key from dataset first (actual key), fallback to input value
                const jfKeyInput = getInput('jf.apikey');
                const jfKey =
                    jfKeyInput?.dataset?.actualToken ||
                    jfKeyInput?.value?.trim() ||
                    window.__tokenStore?.jfApiKey ||
                    localStorage.getItem('jf_apikey_temp');
                // Check if it's a masked value (all bullet points) or EXISTING_TOKEN marker
                const isMaskedKey = jfKey && (/^[•]+$/.test(jfKey) || jfKey === 'EXISTING_TOKEN');
                // Only update API key if user entered a new value (not empty, not masked)
                if (jfKey && !isMaskedKey) {
                    setIfProvided(jf.tokenEnvVar, jfKey);
                    localStorage.setItem('jf_apikey_temp', jfKey);
                    console.log(
                        '[Jellyfin Save] Key saved to localStorage:',
                        jfKey.length,
                        'chars'
                    );
                }
                // If empty or masked, key is intentionally omitted so backend preserves existing value
                envPatch.JELLYFIN_INSECURE_HTTPS =
                    document.getElementById('jf.insecureHttpsHeader')?.checked ||
                    document.getElementById('jf.insecureHttps')?.checked
                        ? 'true'
                        : 'false';
                jf.hostname = getInput('jf.hostname')?.value?.trim() || jf.hostname;
                const jfPortRaw = getInput('jf.port')?.value?.trim();
                if (jfPortRaw && !Number.isNaN(Number(jfPortRaw))) jf.port = Number(jfPortRaw);
                await saveConfigPatch({ mediaServers: servers }, envPatch);
                window.notify?.toast({
                    type: 'success',
                    title: 'Saved',
                    message: 'Jellyfin settings updated',
                    duration: 2500,
                });
                try {
                    if (jfToggle) jfToggle.dataset.originalEnabled = jf.enabled ? 'true' : 'false';
                    const changed =
                        typeof originalEnabled === 'boolean'
                            ? originalEnabled !== !!jf.enabled
                            : true;
                    const spanText = (btn?.querySelector('span')?.textContent || '').toLowerCase();
                    const needsRestart =
                        changed ||
                        preNeedsRestart ||
                        btn?.dataset?.restartRequired === 'true' ||
                        spanText.includes('restart');

                    if (needsRestart) {
                        const span = btn?.querySelector('span');
                        if (span) span.textContent = 'Save Settings & Restart';
                        btn && (btn.dataset.restartRequired = 'true');
                        await window.triggerRestartAndPoll();
                    }
                } catch (e) {
                    console.error('Jellyfin restart check error:', e);
                }
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Save failed',
                    message: e?.message || 'Unable to save Jellyfin',
                    duration: 4500,
                });
            } finally {
                btn?.classList.remove('btn-loading');
                // allow one auto-fetch after save on next load
                if (window.__autoFetchedLibs) window.__autoFetchedLibs.jf = false;
                loadMediaSources(true).catch(() => {});
            }
        }

        async function saveTMDB() {
            const btn = document.getElementById('btn-save-tmdb');
            btn?.classList.add('btn-loading');
            try {
                const cfgRes = await window.dedupJSON('/api/admin/config', {
                    credentials: 'include',
                });
                const base = cfgRes.ok ? await cfgRes.json() : {};
                const currentCfg = base?.config || base || {};
                const tmdb = { ...(currentCfg.tmdbSource || {}) };
                tmdb.enabled = !!getInput('tmdb.enabled')?.checked;
                tmdb.category = getInput('tmdb.category')?.value || 'popular';
                {
                    const raw = getInput('tmdb.minRating')?.value;
                    const mr = Math.round(Number(raw));
                    tmdb.minRating = Number.isFinite(mr)
                        ? Math.min(10, Math.max(0, mr))
                        : undefined;
                }
                {
                    const expr = parseYearExpression(getInput('tmdb.yearFilter')?.value);
                    tmdb.yearFilter = expr;
                }
                // Selected genres as CSV from hidden field
                tmdb.genreFilter = getTMDBGenreFilterHidden();
                // Get API key from dataset first (actual key), fallback to input value
                const tmdbApiKeyInput = getInput('tmdb.apikey');
                const tmdbApiKeyVal =
                    tmdbApiKeyInput?.dataset?.actualToken ||
                    tmdbApiKeyInput?.value?.trim() ||
                    window.__tokenStore?.tmdbApiKey ||
                    localStorage.getItem('tmdb_apikey_temp') ||
                    '';
                // Check if it's a masked value (all bullet points) or EXISTING_TOKEN marker
                const isMaskedApiKey =
                    tmdbApiKeyVal &&
                    (/^[•]+$/.test(tmdbApiKeyVal) || tmdbApiKeyVal === 'EXISTING_TOKEN');
                // Only update API key if user entered a new value (not empty, not masked)
                if (tmdbApiKeyVal && !isMaskedApiKey) {
                    tmdb.apiKey = tmdbApiKeyVal;
                    localStorage.setItem('tmdb_apikey_temp', tmdbApiKeyVal);
                    console.log(
                        '[TMDB Save] Key saved to localStorage:',
                        tmdbApiKeyVal.length,
                        'chars'
                    );
                } else {
                    // Omit apiKey so backend preserves existing value (send null to signal "don't change")
                    tmdb.apiKey = null;
                }
                // Include Streaming Releases selections (server converts object -> array)
                const streaming = {
                    enabled: !!document.getElementById('streamingSources.enabled')?.checked,
                    region: document.getElementById('streamingSources.region')?.value || 'US',
                    minRating: (() => {
                        const mr = Math.round(
                            Number(document.getElementById('streamingSources.minRating')?.value)
                        );
                        return Number.isFinite(mr) ? Math.min(10, Math.max(0, mr)) : 0;
                    })(),
                    // Map multiselect selections back to boolean flags
                    ...(() => {
                        const sel = new Set(getMultiSelectValues('streaming.providers'));
                        return {
                            netflix: sel.has('netflix'),
                            disney: sel.has('disney'),
                            prime: sel.has('prime'),
                            hbo: sel.has('hbo'),
                            hulu: sel.has('hulu'),
                            apple: sel.has('apple'),
                            paramount: sel.has('paramount'),
                            crunchyroll: sel.has('crunchyroll'),
                        };
                    })(),
                    newReleases: !!document.getElementById('streamingSources.newReleases')?.checked,
                };
                await saveConfigPatch({ tmdbSource: tmdb, streamingSources: streaming });
                window.notify?.toast({
                    type: 'success',
                    title: 'Saved',
                    message: 'TMDB settings updated',
                    duration: 2500,
                });
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Save failed',
                    message: e?.message || 'Unable to save TMDB',
                    duration: 4500,
                });
            } finally {
                btn?.classList.remove('btn-loading');
                // Force a fresh reload so the UI immediately reflects saved values
                loadMediaSources(true)
                    .then(() => {
                        // Ensure TMDB genres UI stays hydrated after save
                        try {
                            const curr = getTMDBGenreFilterHidden();
                            loadTMDBGenres(curr).catch(() => {});
                        } catch (_) {
                            /* no-op */
                        }
                    })
                    .catch(() => {});
            }
        }

        // ------- TMDB Genre Filter (theme-demo multiselect) -------
        function setTMDBGenreFilterHidden(val) {
            const hidden = document.getElementById('tmdb.genreFilter-hidden');
            if (hidden) hidden.value = val || '';
        }
        function getTMDBGenreFilterHidden() {
            const hidden = document.getElementById('tmdb.genreFilter-hidden');
            return hidden ? hidden.value : '';
        }
        // Build option row
        function tmdbMsOption(name, checked) {
            const row = document.createElement('div');
            row.className = 'ms-option';
            row.setAttribute('role', 'option');
            row.dataset.value = name;
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = !!checked;
            const label = document.createElement('span');
            label.textContent = name;
            row.appendChild(cb);
            row.appendChild(label);
            return row;
        }
        function tmdbRenderChips(selected) {
            const chipsEl = document.getElementById('tmdb-ms-genres-chips');
            const control = document.querySelector('#tmdb-ms-genres .ms-control');
            if (!chipsEl || !control) return;
            chipsEl.innerHTML = '';
            const vals = Array.from(selected);
            vals.forEach(v => {
                const chip = document.createElement('span');
                chip.className = 'ms-chip';
                chip.dataset.value = v;
                chip.innerHTML = `${v} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
                chip.querySelector('.ms-chip-remove').addEventListener('click', e => {
                    e.stopPropagation();
                    selected.delete(v);
                    setTMDBGenreFilterHidden(Array.from(selected).join(','));
                    tmdbSyncOptions(selected);
                    tmdbRenderChips(selected);
                    control.classList.toggle('has-selection', selected.size > 0);
                });
                chipsEl.appendChild(chip);
            });
            control.classList.toggle('has-selection', selected.size > 0);
        }
        function tmdbSyncOptions(selected) {
            document.querySelectorAll('#tmdb-ms-genres-options .ms-option').forEach(opt => {
                const v = opt.dataset.value;
                const cb = opt.querySelector('input[type="checkbox"]');
                if (cb) cb.checked = selected.has(v);
            });
        }
        function tmdbOpenMenu(open) {
            const root = document.getElementById('tmdb-ms-genres');
            const control = root?.querySelector('.ms-control');
            if (!root || !control) return;
            root.classList.toggle('ms-open', !!open);
            control.setAttribute('aria-expanded', open ? 'true' : 'false');
        }
        function tmdbAttachMsHandlers(options, selected) {
            const root = document.getElementById('tmdb-ms-genres');
            if (!root) return;
            if (root.dataset.msWired === 'true') return; // avoid duplicate listeners
            const control = root?.querySelector('.ms-control');
            // no top input; use search field inside menu
            // const input = null;
            const menu = document.getElementById('tmdb-ms-genres-menu');
            const search = document.getElementById('tmdb-ms-genres-search');
            const selectAll = document.getElementById('tmdb-ms-genres-select-all');
            const clearAll = document.getElementById('tmdb-ms-genres-clear-all');
            const clearBtn = document.getElementById('tmdb-ms-genres-clear');
            const optsEl = document.getElementById('tmdb-ms-genres-options');
            if (!root || !control || !menu || !search || !selectAll || !clearAll || !optsEl) return;

            const filterOptions = q => {
                const qq = (q || '').toLowerCase();
                Array.from(optsEl.children).forEach(child => {
                    const match = child.dataset.value?.toLowerCase().includes(qq);
                    child.style.display = match ? '' : 'none';
                });
            };
            // Open/close on mousedown to avoid focus-before-click flicker.
            // Ignore when user clicks directly in the input (typing should just open via focus).
            control.addEventListener('mousedown', e => {
                // No top input anymore
                e.preventDefault();
                e.stopPropagation();
                const willOpen = !root.classList.contains('ms-open');
                tmdbOpenMenu(willOpen);
                if (willOpen) setTimeout(() => search.focus(), 0);
            });
            document.addEventListener('click', e => {
                if (!root.contains(e.target)) tmdbOpenMenu(false);
            });
            // Focus/typing only in bottom search now
            search.addEventListener('focus', () => tmdbOpenMenu(true));
            search.addEventListener('keydown', e => {
                if (e.key === 'Escape') tmdbOpenMenu(false);
            });
            // Search typing filters list
            search.addEventListener('input', () => filterOptions(search.value));
            // Select all
            selectAll.addEventListener('click', e => {
                e.preventDefault();
                options.forEach(name => selected.add(name));
                setTMDBGenreFilterHidden(Array.from(selected).join(','));
                tmdbSyncOptions(selected);
                tmdbRenderChips(selected);
            });
            // Clear all
            clearAll.addEventListener('click', e => {
                e.preventDefault();
                selected.clear();
                setTMDBGenreFilterHidden('');
                tmdbSyncOptions(selected);
                tmdbRenderChips(selected);
            });
            clearBtn?.addEventListener('click', e => {
                e.preventDefault();
                selected.clear();
                setTMDBGenreFilterHidden('');
                tmdbSyncOptions(selected);
                tmdbRenderChips(selected);
                // Also clear search
                search.value = '';
                filterOptions('');
            });
            // Option click
            optsEl.addEventListener('click', e => {
                const row = e.target.closest('.ms-option');
                if (!row) return;
                const v = row.dataset.value;
                if (selected.has(v)) selected.delete(v);
                else selected.add(v);
                setTMDBGenreFilterHidden(Array.from(selected).join(','));
                tmdbSyncOptions(selected);
                tmdbRenderChips(selected);
            });
            root.dataset.msWired = 'true';
        }
        async function loadTMDBGenres(currentValueCsv = '') {
            const chipsContainer = document.getElementById('tmdb-ms-genres-chips');
            const optsEl = document.getElementById('tmdb-ms-genres-options');
            const control = document.querySelector('#tmdb-ms-genres .ms-control');
            if (!chipsContainer || !optsEl || !control) return;
            chipsContainer.innerHTML = '<div class="subtle">Loading genres…</div>';
            try {
                // Try server-provided genre list
                const r = await window.dedupJSON('/api/admin/tmdb-genres', {
                    credentials: 'include',
                });
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                const data = await r.json().catch(() => ({}));
                const genres = Array.isArray(data?.genres) ? data.genres : [];
                // Build sorted option list
                const names = genres
                    .slice()
                    .map(g => g.name || g.value || String(g))
                    .sort((a, b) => a.localeCompare(b));
                optsEl.innerHTML = '';
                const selected = new Set(
                    String(currentValueCsv || '')
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean)
                );
                names.forEach(n => optsEl.appendChild(tmdbMsOption(n, selected.has(n))));
                setTMDBGenreFilterHidden(Array.from(selected).join(','));
                tmdbRenderChips(selected);
                tmdbAttachMsHandlers(names, selected);
            } catch (e) {
                chipsContainer.innerHTML = '<div class="subtle">Failed to load genres</div>';
            }
        }

        // ------- Plex Ratings/Qualities (theme-demo multiselects) -------
        function setPlexHidden(id, val) {
            const el = document.getElementById(id);
            if (el) {
                el.value = val || '';
                try {
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                } catch (_) {
                    /* change event dispatch optional; ignore */
                }
            }
        }
        function getPlexHidden(id) {
            const el = document.getElementById(id);
            return el ? el.value : '';
        }
        function plexMsOption(name, checked) {
            const row = document.createElement('div');
            row.className = 'ms-option';
            row.setAttribute('role', 'option');
            row.dataset.value = name;
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = !!checked;
            const label = document.createElement('span');
            label.textContent = name;
            row.appendChild(cb);
            row.appendChild(label);
            return row;
        }
        function plexAttachMsHandlers(baseId, options, selected, onUpdate) {
            const root = document.getElementById(baseId);
            if (!root || root.dataset.msWired === 'true') return;
            const control = root.querySelector('.ms-control');
            const menu = document.getElementById(baseId + '-menu');
            const search = document.getElementById(baseId + '-search');
            const selectAll = document.getElementById(baseId + '-select-all');
            const clearAll = document.getElementById(baseId + '-clear-all');
            const clearBtn = document.getElementById(baseId + '-clear');
            const optsEl = document.getElementById(baseId + '-options');
            const chips = document.getElementById(baseId + '-chips');
            if (!control || !menu || !search || !selectAll || !clearAll || !optsEl || !chips)
                return;
            const renderChips = () => {
                chips.innerHTML = '';
                Array.from(selected).forEach(v => {
                    const chip = document.createElement('span');
                    chip.className = 'ms-chip';
                    chip.dataset.value = v;
                    chip.innerHTML = `${v} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
                    chip.querySelector('.ms-chip-remove')?.addEventListener('click', e => {
                        e.stopPropagation();
                        selected.delete(v);
                        onUpdate(selected);
                        syncOptions();
                        renderChips();
                        control.classList.toggle('has-selection', selected.size > 0);
                    });
                    chips.appendChild(chip);
                });
                control.classList.toggle('has-selection', selected.size > 0);
            };
            const syncOptions = () => {
                Array.from(optsEl.children).forEach(row => {
                    const v = row.dataset.value;
                    const cb = row.querySelector('input[type="checkbox"]');
                    if (cb) cb.checked = selected.has(v);
                });
            };
            // Move menu into body to avoid clipping and position it near control
            if (menu && menu.parentElement !== document.body) {
                document.body.appendChild(menu);
                menu.style.position = 'fixed';
                menu.style.zIndex = '9999';
                menu.style.display = 'none';
                menu.style.maxHeight = '60vh';
                menu.style.overflow = 'auto';
                menu.style.minWidth = '240px';
            }
            let onReposition;
            const positionMenu = () => {
                if (!control || !menu) return;
                const rect = control.getBoundingClientRect();
                const viewportH = window.innerHeight || document.documentElement.clientHeight;
                const belowSpace = viewportH - rect.bottom;
                const estHeight = Math.min(menu.scrollHeight || 320, viewportH * 0.6);
                const openUp = belowSpace < estHeight && rect.top > estHeight;
                const top = openUp ? Math.max(8, rect.top - estHeight) : rect.bottom + 4;
                const left = rect.left;
                const width = Math.max(rect.width, 240);
                menu.style.top = `${Math.round(top)}px`;
                menu.style.left = `${Math.round(left)}px`;
                menu.style.width = `${Math.round(width)}px`;
                menu.style.maxHeight = `${Math.round(estHeight)}px`;
            };
            const openMenu = open => {
                root.classList.toggle('ms-open', !!open);
                control.setAttribute('aria-expanded', open ? 'true' : 'false');
                if (!menu) return;
                if (open) {
                    menu.style.display = 'block';
                    try {
                        menu.scrollTop = 0;
                        if (optsEl) optsEl.scrollTop = 0;
                    } catch (e) {
                        dbg('ms scroll reset failed (plex)', e);
                    }
                    positionMenu();
                    onReposition = () => positionMenu();
                    window.addEventListener('resize', onReposition, { passive: true });
                    window.addEventListener('scroll', onReposition, { passive: true });
                } else {
                    menu.style.display = 'none';
                    if (onReposition) {
                        window.removeEventListener('resize', onReposition);
                        window.removeEventListener('scroll', onReposition);
                        onReposition = null;
                    }
                }
            };
            const filterOptions = q => {
                const qq = (q || '').toLowerCase();
                Array.from(optsEl.children).forEach(child => {
                    const match = child.dataset.value?.toLowerCase().includes(qq);
                    child.style.display = match ? '' : 'none';
                });
            };
            // Ensure the left clear (x) button doesn't toggle the menu on press
            clearBtn?.addEventListener('mousedown', e => {
                e.stopPropagation();
            });
            control.addEventListener('mousedown', e => {
                e.preventDefault();
                e.stopPropagation();
                const willOpen = !root.classList.contains('ms-open');
                openMenu(willOpen);
                if (willOpen) setTimeout(() => search.focus(), 0);
            });
            document.addEventListener('click', e => {
                if (!root.contains(e.target) && !(menu && menu.contains(e.target))) openMenu(false);
            });
            search.addEventListener('focus', () => openMenu(true));
            search.addEventListener('keydown', e => {
                if (e.key === 'Escape') openMenu(false);
            });
            search.addEventListener('input', () => filterOptions(search.value));
            selectAll.addEventListener('click', e => {
                e.preventDefault();
                options.forEach(n => selected.add(n));
                onUpdate(selected);
                syncOptions();
                renderChips();
            });
            clearAll.addEventListener('click', e => {
                e.preventDefault();
                selected.clear();
                onUpdate(selected);
                syncOptions();
                renderChips();
                search.value = '';
                filterOptions('');
            });
            clearBtn?.addEventListener('click', e => {
                e.preventDefault();
                selected.clear();
                onUpdate(selected);
                syncOptions();
                renderChips();
                search.value = '';
                filterOptions('');
            });
            optsEl.addEventListener('click', e => {
                const row = e.target.closest('.ms-option');
                if (!row) return;
                const v = row.dataset.value;
                if (selected.has(v)) selected.delete(v);
                else selected.add(v);
                onUpdate(selected);
                syncOptions();
                renderChips();
            });
            root.dataset.msWired = 'true';
            renderChips();
        }
        async function loadPlexRatings(currentCsv = '') {
            const chips = document.getElementById('plex-ms-ratings-chips');
            const optsEl = document.getElementById('plex-ms-ratings-options');
            const control = document.querySelector('#plex-ms-ratings .ms-control');
            const root = document.getElementById('plex-ms-ratings');
            if (!chips || !optsEl || !control) return;
            chips.innerHTML = '<div class="subtle">Loading ratings…</div>';
            try {
                const res = await window.dedupJSON('/api/sources/plex/ratings-with-counts', {
                    credentials: 'include',
                });
                const data = await res.json().catch(() => ({}));
                const arr = Array.isArray(data?.data) ? data.data : [];
                const ratings = arr
                    .map(r => r.rating)
                    .filter(Boolean)
                    .sort();
                const selected = new Set(
                    String(currentCsv || '')
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean)
                );
                optsEl.innerHTML = '';
                ratings.forEach(n => optsEl.appendChild(plexMsOption(n, selected.has(n))));
                setPlexHidden('plex.ratingFilter-hidden', Array.from(selected).join(','));
                if (root?.dataset.msWired === 'true') {
                    const syncOptions = () => {
                        Array.from(optsEl.children).forEach(row => {
                            const v = row.dataset.value;
                            const cb = row.querySelector('input[type="checkbox"]');
                            if (cb) cb.checked = selected.has(v);
                        });
                    };
                    const renderChips = () => {
                        chips.innerHTML = '';
                        Array.from(selected).forEach(v => {
                            const chip = document.createElement('span');
                            chip.className = 'ms-chip';
                            chip.dataset.value = v;
                            chip.innerHTML = `${v} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
                            chip.querySelector('.ms-chip-remove')?.addEventListener('click', e => {
                                e.stopPropagation();
                                selected.delete(v);
                                setPlexHidden(
                                    'plex.ratingFilter-hidden',
                                    Array.from(selected).join(',')
                                );
                                syncOptions();
                                renderChips();
                                control.classList.toggle('has-selection', selected.size > 0);
                            });
                            chips.appendChild(chip);
                        });
                        control.classList.toggle('has-selection', selected.size > 0);
                    };
                    syncOptions();
                    renderChips();
                } else {
                    plexAttachMsHandlers('plex-ms-ratings', ratings, selected, sel =>
                        setPlexHidden('plex.ratingFilter-hidden', Array.from(sel).join(','))
                    );
                }
            } catch (e) {
                chips.innerHTML = '<div class="subtle">Failed to load ratings</div>';
            }
        }
        async function loadPlexQualities(currentCsv = '') {
            const chips = document.getElementById('plex-ms-qualities-chips');
            const optsEl = document.getElementById('plex-ms-qualities-options');
            const control = document.querySelector('#plex-ms-qualities .ms-control');
            const root = document.getElementById('plex-ms-qualities');
            if (!chips || !optsEl || !control) return;
            chips.innerHTML = '<div class="subtle">Loading qualities…</div>';
            try {
                const res = await window.dedupJSON('/api/admin/plex-qualities-with-counts', {
                    credentials: 'include',
                });
                const data = await res.json().catch(() => ({}));
                const arr = Array.isArray(data?.qualities) ? data.qualities : [];
                const names = arr
                    .map(q => q.quality || q)
                    .filter(Boolean)
                    .sort((a, b) => {
                        const order = ['SD', '720p', '1080p', '4K'];
                        const ai = order.indexOf(a);
                        const bi = order.indexOf(b);
                        if (ai !== -1 && bi !== -1) return ai - bi;
                        if (ai !== -1) return -1;
                        if (bi !== -1) return 1;
                        return a.localeCompare(b);
                    });
                const selected = new Set(
                    String(currentCsv || '')
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean)
                );
                optsEl.innerHTML = '';
                names.forEach(n => optsEl.appendChild(plexMsOption(n, selected.has(n))));
                setPlexHidden('plex.qualityFilter-hidden', Array.from(selected).join(','));
                if (root?.dataset.msWired === 'true') {
                    const syncOptions = () => {
                        Array.from(optsEl.children).forEach(row => {
                            const v = row.dataset.value;
                            const cb = row.querySelector('input[type="checkbox"]');
                            if (cb) cb.checked = selected.has(v);
                        });
                    };
                    const renderChips = () => {
                        chips.innerHTML = '';
                        Array.from(selected).forEach(v => {
                            const chip = document.createElement('span');
                            chip.className = 'ms-chip';
                            chip.dataset.value = v;
                            chip.innerHTML = `${v} <i class="fas fa-xmark ms-chip-remove" title="Remove"></i>`;
                            chip.querySelector('.ms-chip-remove')?.addEventListener('click', e => {
                                e.stopPropagation();
                                selected.delete(v);
                                setPlexHidden(
                                    'plex.qualityFilter-hidden',
                                    Array.from(selected).join(',')
                                );
                                syncOptions();
                                renderChips();
                                control.classList.toggle('has-selection', selected.size > 0);
                            });
                            chips.appendChild(chip);
                        });
                        control.classList.toggle('has-selection', selected.size > 0);
                    };
                    syncOptions();
                    renderChips();
                } else {
                    plexAttachMsHandlers('plex-ms-qualities', names, selected, sel =>
                        setPlexHidden('plex.qualityFilter-hidden', Array.from(sel).join(','))
                    );
                }
            } catch (e) {
                chips.innerHTML = '<div class="subtle">Failed to load qualities</div>';
            }
        }

        // Wire buttons
        document.getElementById('btn-plex-libraries')?.addEventListener('click', () => {
            fetchPlexLibraries(true);
        });
        document.getElementById('btn-jf-libraries')?.addEventListener('click', () => {
            fetchJellyfinLibraries(true);
        });
        document.getElementById('btn-plex-test')?.addEventListener('click', testPlex);
        document.getElementById('btn-jf-test')?.addEventListener('click', testJellyfin);
        document.getElementById('btn-tmdb-test')?.addEventListener('click', testTMDB);
        document.getElementById('test-streaming-button')?.addEventListener('click', testStreaming);
        // (deduped) listener already set above near other source listeners
        // Update category icon based on selection
        const tmdbCat = document.getElementById('tmdb.category');
        const tmdbCatIcon = document.getElementById('tmdb-category-icon')?.querySelector('i');
        const iconFor = val => {
            switch (val) {
                // Shared
                case 'top_rated':
                case 'tv_top_rated':
                    return 'fas fa-star';
                case 'popular':
                case 'tv_popular':
                    return 'fas fa-fire';
                // Movies
                case 'now_playing':
                    return 'fas fa-ticket-alt';
                case 'upcoming':
                    return 'fas fa-calendar-alt';
                case 'latest':
                case 'tv_latest':
                    return 'fas fa-bolt';
                // TV specific
                case 'tv_on_the_air':
                    return 'fas fa-broadcast-tower';
                case 'tv_airing_today':
                    return 'fas fa-tv';
                // Trending
                case 'trending_all_day':
                case 'trending_movie_day':
                case 'trending_tv_day':
                case 'trending_all_week':
                case 'trending_movie_week':
                case 'trending_tv_week':
                    return 'fas fa-chart-line';
                // Discover/Collections
                case 'discover_movie':
                case 'discover_tv':
                    return 'fas fa-compass';
                default:
                    return 'fas fa-list';
            }
        };
        // TMDB overlay icon only (native select + caret wrapper)
        if (tmdbCat && tmdbCatIcon) {
            tmdbCatIcon.className = iconFor(tmdbCat.value);
            tmdbCat.addEventListener('change', () => {
                tmdbCatIcon.className = iconFor(tmdbCat.value);
            });
        }

        // Enhance TMDB category with a custom menu that displays icons inside the dropdown
        (function enhanceTmdbCategoryDropdown() {
            // Enhancement disabled; cleaned up any previous custom dropdown artifacts to restore native select.
            try {
                const wrap = document
                    .getElementById('tmdb.category')
                    ?.closest('.select-wrap.has-caret');
                const select = document.getElementById('tmdb.category');
                if (wrap) wrap.classList.remove('cs-enhanced');
                if (wrap)
                    wrap.querySelectorAll('.cs-trigger').forEach(
                        el => el.parentNode && el.parentNode.removeChild(el)
                    );
                if (select) select.removeAttribute('data-enhanced');
                const oldMenu = document.getElementById('tmdb-category-menu');
                if (oldMenu?.parentNode) oldMenu.parentNode.removeChild(oldMenu);
                if (window.__tmdbCat) delete window.__tmdbCat;
            } catch (_) {
                /* no-op */
            }
        })(); // end enhanceTmdbCategoryDropdown (custom menu disabled)

        // Live auto-fetch libraries when connection inputs change (Plex/Jellyfin)
        // Simple debounce to avoid rapid calls while typing
        const debounce = (fn, ms = 300) => {
            let t;
            return (...args) => {
                clearTimeout(t);
                t = setTimeout(() => fn(...args), ms);
            };
        };

        const autoFetchPlexIfReady = debounce(() => {
            try {
                const enabled = !!document.getElementById('plex.enabled')?.checked;
                const host = document.getElementById('plex.hostname')?.value?.trim();
                const port = document.getElementById('plex.port')?.value?.trim();
                if (enabled && host && port) fetchPlexLibraries(true, true);
            } catch (_) {
                /* no-op */
            }
        }, 350);

        const autoFetchJfIfReady = debounce(() => {
            try {
                const enabled = !!document.getElementById('jf.enabled')?.checked;
                const host = document.getElementById('jf.hostname')?.value?.trim();
                const port = document.getElementById('jf.port')?.value?.trim();
                if (enabled && host && port) fetchJellyfinLibraries(true);
            } catch (_) {
                /* no-op */
            }
        }, 350);

        // --- Save & Restart helpers for source toggles ---
        function sourceRestartNeeded(sourceKey) {
            try {
                const id =
                    sourceKey === 'plex'
                        ? 'plex.enabled'
                        : sourceKey === 'jellyfin'
                          ? 'jf.enabled'
                          : sourceKey === 'local'
                            ? 'localDirectory.enabled'
                            : null;
                if (!id) return false;
                const el = document.getElementById(id);
                if (!el) return false;
                // If original baseline is not known yet, do not infer or mutate it here.
                // We prefer to avoid false negatives caused by accidentally setting the baseline to the new value.
                if (el.dataset.originalEnabled == null) return false;
                const orig = el.dataset.originalEnabled === 'true';
                const curr = !!el.checked;
                return orig !== curr;
            } catch (_) {
                return false;
            }
        }

        function updateSourceSaveButtonLabel(sourceKey) {
            const map = {
                plex: 'btn-save-plex',
                jellyfin: 'btn-save-jellyfin',
                local: 'btn-save-local',
            };
            const btnId = map[sourceKey];
            if (!btnId) return;
            const btn = document.getElementById(btnId);
            if (!btn) return;
            const span = btn.querySelector('span');
            const needs = sourceRestartNeeded(sourceKey);
            if (span) span.textContent = needs ? 'Save Settings & Restart' : 'Save Settings';
            btn.dataset.restartRequired = needs ? 'true' : 'false';
        }

        function wireSourceRestartLabel(sourceKey) {
            const id =
                sourceKey === 'plex'
                    ? 'plex.enabled'
                    : sourceKey === 'jellyfin'
                      ? 'jf.enabled'
                      : sourceKey === 'local'
                        ? 'localDirectory.enabled'
                        : null;
            if (!id) return;
            const el = document.getElementById(id);
            if (!el || el.dataset.restartWired === 'true') return;
            el.addEventListener('change', () => updateSourceSaveButtonLabel(sourceKey));
            el.dataset.restartWired = 'true';
            // Initialize label once only if original baseline is known
            if (el.dataset.originalEnabled != null) updateSourceSaveButtonLabel(sourceKey);
        }

        // Attach listeners
        ['plex.enabled', 'plex.hostname', 'plex.port'].forEach(id => {
            const el = document.getElementById(id);
            el?.addEventListener('change', autoFetchPlexIfReady);
            // React on typing for inputs (text or number)
            if (el && el.tagName === 'INPUT') {
                el.addEventListener('input', autoFetchPlexIfReady);
            }
        });
        // Keep Plex Save label in sync when enabling/disabling
        wireSourceRestartLabel('plex');
        ['jf.enabled', 'jf.hostname', 'jf.port'].forEach(id => {
            const el = document.getElementById(id);
            el?.addEventListener('change', autoFetchJfIfReady);
            if (el && el.tagName === 'INPUT' && el.type === 'text') {
                el.addEventListener('input', autoFetchJfIfReady);
            }
        });
        // Keep Jellyfin Save label in sync when enabling/disabling
        wireSourceRestartLabel('jellyfin');

        // Initialize Local baseline early so first toggle updates the label instantly
        (function initLocalRestartLabelEarly() {
            try {
                const el = document.getElementById('localDirectory.enabled');
                if (!el) return;
                if (el.dataset.originalEnabled == null) {
                    el.dataset.originalEnabled = el.checked ? 'true' : 'false';
                }
                wireSourceRestartLabel('local');
                // If baseline exists, reflect button label
                try {
                    updateSourceSaveButtonLabel('local');
                } catch (_) {
                    /* best-effort label sync; harmless if helper not available */
                }
            } catch (_) {
                /* plex port sanitization listener failed (user must input valid digits) */
            }
        })();

        document.getElementById('btn-save-plex')?.addEventListener('click', savePlex);
        document.getElementById('btn-save-jellyfin')?.addEventListener('click', saveJellyfin);
        document.getElementById('btn-save-tmdb')?.addEventListener('click', saveTMDB);
        // No extra handlers needed here; dependent refresh is driven by fetchPlexLibraries(true)

        // Initial population
        loadMediaSources().catch(() => {});

        btnSaveServer?.addEventListener('click', async () => {
            const portEl = document.getElementById('SERVER_PORT');
            const serverPort = Math.max(1024, Math.min(65535, Number(portEl?.value || 4000)));
            if (!Number.isFinite(serverPort) || serverPort < 1024 || serverPort > 65535) {
                return window.notify?.toast({
                    type: 'warning',
                    title: 'Invalid Port',
                    message: 'Port must be between 1024 and 65535',
                    duration: 4000,
                });
            }
            try {
                btnSaveServer.classList.add('btn-loading');
                await saveConfigPatch({ serverPort }, { SERVER_PORT: String(serverPort) });
                window.notify?.toast({
                    type: 'success',
                    title: 'Saved',
                    message: 'Server settings updated',
                    duration: 2500,
                });
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Save failed',
                    message: e?.message || 'Unable to save',
                    duration: 4500,
                });
            } finally {
                btnSaveServer.classList.remove('btn-loading');
            }
        });

        btnSavePromo?.addEventListener('click', async () => {
            const enabled = !!document.getElementById('siteServer.enabled')?.checked;
            const portVal = Number(document.getElementById('siteServer.port')?.value || 4001);
            try {
                btnSavePromo.classList.add('btn-loading');
                await saveConfigPatch({ siteServer: { enabled, port: portVal } }, {});
                window.notify?.toast({
                    type: 'success',
                    title: 'Saved',
                    message: 'Promobox settings updated',
                    duration: 2500,
                });
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Save failed',
                    message: e?.message || 'Unable to save',
                    duration: 4500,
                });
            } finally {
                btnSavePromo.classList.remove('btn-loading');
            }
        });

        // Helper: update Operations save button label depending on restart requirement
        function opsRestartNeeded() {
            const portEl = document.getElementById('SERVER_PORT');
            const btn = document.getElementById('btn-save-operations');
            if (!portEl || !btn) return false;
            let original = btn.dataset.originalPort || portEl.dataset.originalPort;
            // If original not known yet, treat current value as original to avoid false positives
            if (original == null) {
                original = String(portEl.value || '4000');
                btn.dataset.originalPort = original;
                portEl.dataset.originalPort = original;
            }
            const current = Number(portEl.value || 4000);
            const origNum = Number(original);
            if (!Number.isFinite(current) || !Number.isFinite(origNum)) return false;
            return current !== origNum;
        }
        function updateOpsSaveButtonLabel() {
            const btn = document.getElementById('btn-save-operations');
            if (!btn) return;
            const span = btn.querySelector('span');
            const needs = opsRestartNeeded();
            if (span) span.textContent = needs ? 'Save Settings & Restart' : 'Save Settings';
            btn.dataset.restartRequired = needs ? 'true' : 'false';
        }
        // Expose for later use after async loads
        window.updateOpsSaveButtonLabel = updateOpsSaveButtonLabel;
        // Wire live updates on port input
        if (portInput) {
            ['input', 'change'].forEach(evt =>
                portInput.addEventListener(evt, updateOpsSaveButtonLabel)
            );
        }

        // Unified save for Operations: saves Config Backups schedule + Server Settings + Promobox
        btnSaveOps?.addEventListener('click', async () => {
            const btn = btnSaveOps;
            try {
                // Collect Server Settings
                const portEl = document.getElementById('SERVER_PORT');
                const serverPort = Math.max(1024, Math.min(65535, Number(portEl?.value || 4000)));
                if (!Number.isFinite(serverPort) || serverPort < 1024 || serverPort > 65535) {
                    return window.notify?.toast({
                        type: 'warning',
                        title: 'Invalid Port',
                        message: 'Port must be between 1024 and 65535',
                        duration: 4000,
                    });
                }
                // Collect Background Refresh Minutes (Media)
                const brmInput = document.getElementById('ops.backgroundRefreshMinutes');
                let backgroundRefreshMinutes = Number(brmInput?.value || 60);
                if (!Number.isFinite(backgroundRefreshMinutes)) backgroundRefreshMinutes = 60;
                backgroundRefreshMinutes = Math.max(
                    5,
                    Math.min(1440, Math.round(backgroundRefreshMinutes))
                );
                if (brmInput) brmInput.value = String(backgroundRefreshMinutes);
                if (!btn.querySelector('.spinner')) {
                    const sp = document.createElement('span');
                    sp.className = 'spinner';
                    btn.insertBefore(sp, btn.firstChild);
                }
                btn.classList.add('btn-loading');
                // First, save Config Backups schedule silently so the pill and list can refresh
                try {
                    await saveCfgBackupSchedule({ silent: true });
                } catch (_) {
                    // Proceed; errors will be surfaced by unified toast below if needed
                }
                // Collect Promobox
                const enabled = !!document.getElementById('siteServer.enabled')?.checked;
                const portVal = Number(document.getElementById('siteServer.port')?.value || 4001);

                // Collect Entry Route (rootRoute)
                const rrBehavior =
                    document.getElementById('rootRoute_behavior')?.value || 'landing';
                const rrStatusCode = Number(
                    document.getElementById('rootRoute_statusCode')?.value || '302'
                );
                const bypassEl = document.getElementById('rootRoute_bypassParam');
                const rrBypassParam = (bypassEl?.value || 'landing').trim();

                // Client-side validation for bypass flag (non-empty only)
                try {
                    const utils =
                        (typeof window !== 'undefined' && window.__adminUtils) || undefined;
                    const validate = utils?.validateBypassParam;
                    if (
                        rrBypassParam &&
                        typeof validate === 'function' &&
                        !validate(rrBypassParam)
                    ) {
                        window.notify?.toast({
                            type: 'warning',
                            title: 'Invalid bypass flag',
                            message:
                                "Use 1-32 chars: start with a letter; letters, numbers, '_' or '-' allowed.",
                            duration: 4500,
                        });
                        if (bypassEl && typeof bypassEl.focus === 'function') bypassEl.focus();
                        return; // abort save
                    }
                } catch (_) {
                    /* validation helper unavailable; proceed */
                }

                await saveConfigPatch(
                    {
                        serverPort: serverPort,
                        backgroundRefreshMinutes,
                        siteServer: { enabled, port: portVal },
                        rootRoute: {
                            behavior: rrBehavior,
                            statusCode: rrStatusCode === 307 ? 307 : 302,
                            bypassParam: rrBypassParam || 'landing',
                        },
                    },
                    { SERVER_PORT: String(serverPort) }
                );

                const needsRestart = btn.dataset.restartRequired === 'true' || opsRestartNeeded();
                if (needsRestart) {
                    // eslint-disable-next-line no-undef
                    await triggerRestartAndPoll({
                        title: 'Restarting…',
                        message: 'Port changed. Applying changes and restarting.',
                    });
                } else {
                    window.notify?.toast({
                        type: 'success',
                        title: 'Saved',
                        message: 'Operations settings updated',
                        duration: 2500,
                    });
                }
            } catch (e) {
                window.notify?.toast({
                    type: 'error',
                    title: 'Save failed',
                    message: e?.message || 'Unable to save',
                    duration: 4500,
                });
            } finally {
                btn.classList.remove('btn-loading');
            }
        });

        // Toggle port/status visibility
        const promoEnabled = document.getElementById('siteServer.enabled');
        promoEnabled?.addEventListener('change', async () => {
            const show = promoEnabled.checked;
            const portGroup = document.getElementById('siteServerPortGroup');
            const status = document.getElementById('siteServerStatus');
            const pill = document.getElementById('siteServer-pill');
            if (portGroup) portGroup.style.display = show ? 'block' : 'none';
            if (status) {
                status.style.display = show ? 'block' : 'none';
                if (show) {
                    try {
                        // Fetch current server info to get an IP if exposed; otherwise, use the current host
                        const cfgRes = await window.dedupJSON('/api/admin/config', {
                            credentials: 'include',
                        });
                        const cfg = cfgRes.ok ? await cfgRes.json() : {};
                        const hostFromApi = cfg?.server?.ipAddress;
                        const host =
                            hostFromApi && hostFromApi !== '127.0.0.1'
                                ? hostFromApi
                                : window.location?.hostname || 'localhost';
                        const protocol = 'http';
                        const port = Number(
                            document.getElementById('siteServer.port')?.value || 4001
                        );
                        const url = `${protocol}://${host}:${port}`;
                        status.innerHTML = `<div class="status-line"><i class="fas fa-globe"></i> <a class="url-chip" href="${url}" target="_blank" rel="noopener">${url}</a></div>`;
                    } catch {
                        const host = window.location?.hostname || 'localhost';
                        const protocol = 'http';
                        const port = Number(
                            document.getElementById('siteServer.port')?.value || 4001
                        );
                        const url = `${protocol}://${host}:${port}`;
                        status.innerHTML = `<div class="status-line"><i class="fas fa-globe"></i> <a class="url-chip" href="${url}" target="_blank" rel="noopener">${url}</a></div>`;
                    }
                } else {
                    status.textContent = '';
                }
            }
            if (pill) {
                pill.textContent = show ? 'Enabled' : 'Disabled';
                pill.classList.toggle('status-warning', !show);
                pill.classList.toggle('status-success', !!show);
            }
        });
    });
    // If the DOM is already loaded, run wireEvents immediately
    try {
        if (document.readyState !== 'loading') {
            typeof wireEvents === 'function' && wireEvents();
            try {
                wireDashboardMetricShortcuts();
            } catch (_) {
                /* width bucket sizing heuristic failed (styling fallback) */
            }
        }
    } catch (_) {
        /* optional eager wire-up; safe to skip on older browsers */
    }

    async function refreshOperationsPanels() {
        try {
            const r = await window.dedupJSON('/api/admin/config', { credentials: 'include' });
            const j = r.ok ? await r.json() : null;
            // Removed duplicate unused env declaration (was: const env = j?.env || {};) no longer needed.
            const cfg = j?.config || {};
            // SERVER_PORT
            const portElMain = document.getElementById('SERVER_PORT');
            if (portElMain) {
                const v = j?.env?.SERVER_PORT || cfg?.serverPort || 4000;
                portElMain.value = Number(v) || 4000;
                // Snapshot original for restart detection in unified save
                portElMain.dataset.originalPort = String(portElMain.value);
            }
            // Background Refresh Minutes (Media)
            const brmEl = document.getElementById('ops.backgroundRefreshMinutes');
            if (brmEl) {
                const v = Number(cfg?.backgroundRefreshMinutes ?? 60);
                brmEl.value = Number.isFinite(v) && v > 0 ? String(v) : '60';
            }
            // Promobox
            const site = cfg.siteServer || {};
            const enabledEl = document.getElementById('siteServer.enabled');
            const portEl = document.getElementById('siteServer.port');
            const portGroup = document.getElementById('siteServerPortGroup');
            const status = document.getElementById('siteServerStatus');
            const sitePill = document.getElementById('siteServer-pill');
            if (enabledEl) enabledEl.checked = !!site.enabled;
            if (portEl) portEl.value = site.port || 4001;
            if (portGroup) portGroup.style.display = site.enabled ? 'block' : 'none';
            if (status) {
                status.style.display = site.enabled ? 'block' : 'none';
                if (site.enabled) {
                    const hostFromApi = j?.server?.ipAddress;
                    const host =
                        hostFromApi && hostFromApi !== '127.0.0.1'
                            ? hostFromApi
                            : window.location?.hostname || 'localhost';
                    const protocol = 'http';
                    const port = site.port || 4001;
                    const url = `${protocol}://${host}:${port}`;
                    status.innerHTML = `<div class="status-line"><i class="fas fa-globe"></i> <a class="url-chip" href="${url}" target="_blank" rel="noopener">${url}</a></div>`;
                } else {
                    status.textContent = '';
                }
            }
            if (sitePill) {
                sitePill.textContent = site.enabled ? 'Enabled' : 'Disabled';
                sitePill.classList.toggle('status-warning', !site.enabled);
                sitePill.classList.toggle('status-success', !!site.enabled);
            }
            // Entry Route (rootRoute)
            try {
                const rr = cfg.rootRoute || {};
                const beh = document.getElementById('rootRoute_behavior');
                const code = document.getElementById('rootRoute_statusCode');
                const bp = document.getElementById('rootRoute_bypassParam');
                if (beh) beh.value = rr.behavior || 'landing';
                if (code) code.value = String(rr.statusCode === 307 ? 307 : 302);
                if (bp) bp.value = rr.bypassParam || 'landing';
                // Update bypass open link text/href
                try {
                    const link = document.getElementById('rootRoute_bypass_open');
                    const flag = (bp?.value || 'landing').trim();
                    if (link) {
                        const q = flag ? `?${encodeURIComponent(flag)}` : '';
                        link.href = `/${q}`;
                        link.textContent = q ? `Open /${q}` : 'Open /';
                        link.title = q
                            ? 'Open landing (bypass)'
                            : 'Open / (landing if landing behavior)';
                    }
                } catch (_) {
                    /* noop */
                }
                // Apply visibility based on behavior
                try {
                    const behavior = beh?.value || 'landing';
                    const wrap = document.getElementById('rootRoute_status_wrap');
                    const statusEl = document.getElementById('rootRoute_statusCode');
                    const utils = window.__adminUtils || {};
                    if (typeof utils.applyRedirectStatusState === 'function') {
                        utils.applyRedirectStatusState(behavior, statusEl, wrap);
                    } else if (statusEl) {
                        statusEl.disabled = behavior !== 'redirect';
                        statusEl.setAttribute('aria-disabled', String(behavior !== 'redirect'));
                    }
                } catch (_) {
                    /* non-fatal */
                }
            } catch (_) {
                /* non-fatal */
            }
            // Ensure the unified save button label is correct after loading
            if (typeof window.updateOpsSaveButtonLabel === 'function') {
                window.updateOpsSaveButtonLabel();
            }
        } catch (e) {
            // non-fatal
        }
    }

    // Toggle Entry Route status visibility on behavior change
    try {
        const behSel = document.getElementById('rootRoute_behavior');
        if (behSel) {
            const applyBehaviorState = () => {
                try {
                    const behavior = behSel.value;
                    const wrap = document.getElementById('rootRoute_status_wrap');
                    const statusEl = document.getElementById('rootRoute_statusCode');
                    const utils = window.__adminUtils || {};
                    if (typeof utils.applyRedirectStatusState === 'function') {
                        utils.applyRedirectStatusState(behavior, statusEl, wrap);
                    } else if (statusEl) {
                        statusEl.disabled = behavior !== 'redirect';
                        statusEl.setAttribute('aria-disabled', String(behavior !== 'redirect'));
                    }
                } catch (_) {
                    /* non-fatal */
                }
            };
            // Apply once on load to ensure sensible initial state
            applyBehaviorState();
            behSel.addEventListener('change', applyBehaviorState);
        }

        // Keep the bypass open link in sync with user input
        const bypassInput = document.getElementById('rootRoute_bypassParam');
        if (bypassInput) {
            const updateBypassLink = () => {
                try {
                    const link = document.getElementById('rootRoute_bypass_open');
                    const flag = (bypassInput.value || 'landing').trim();
                    if (link) {
                        const q = flag ? `?${encodeURIComponent(flag)}` : '';
                        link.href = `/${q}`;
                        link.textContent = q ? `Open /${q}` : 'Open /';
                        link.title = q
                            ? 'Open landing (bypass)'
                            : 'Open / (landing if landing behavior)';
                    }
                } catch (_) {
                    /* noop */
                }
            };
            // Initialize once so the link is consistent on load
            updateBypassLink();
            bypassInput.addEventListener('input', updateBypassLink);
            bypassInput.addEventListener('change', updateBypassLink);
        }
    } catch (_) {
        /* optional behavior wire */
    }

    // Version + update pill
    async function refreshVersionAndUpdate() {
        try {
            // Get current version
            const v = await fetchJSON('/api/admin/version').catch(() => null);
            const version = v?.version || 'Unknown';
            const vEl = document.getElementById('app-version');
            if (vEl) vEl.textContent = version !== 'Unknown' ? `${version}` : '—';

            // Check for updates
            const upd = await fetchJSON('/api/admin/update-check').catch(() => null);
            const hasUpdate = !!upd?.hasUpdate;
            const latest = upd?.latestVersion;
            const pill = document.getElementById('update-available-pill');
            if (pill) {
                if (hasUpdate && latest && latest !== version) {
                    pill.hidden = false;
                    pill.textContent = 'Update available';
                    pill.title = `Latest: v${latest}`;
                } else {
                    pill.hidden = true;
                }
            }

            // Also reflect availability in the Automatic Updates card (idle pill)
            try {
                const idlePill = document.getElementById('update-idle-pill');
                const progState = document.getElementById('update-progress-state');
                // Only adjust when not actively updating
                const isProgressVisible = !!progState && progState.style.display !== 'none';
                if (idlePill && !isProgressVisible) {
                    if (hasUpdate && latest && latest !== version) {
                        idlePill.textContent = 'Update available';
                        idlePill.classList.remove('status-success');
                        idlePill.classList.add('status-warning');
                        idlePill.title = `Latest: v${latest}`;
                    } else {
                        idlePill.textContent = 'Ready';
                        idlePill.classList.remove('status-warning');
                        idlePill.classList.add('status-success');
                        idlePill.removeAttribute('title');
                    }
                }
            } catch (_) {
                /* non-fatal */
            }
        } catch (e) {
            // Non-fatal
            console.warn('Version/update check failed', e);
        }
    }

    // ---------------- Device Management Whitelist UI ----------------
    const whitelistState = {
        current: [],
        original: [],
        dirty: false,
        saving: false,
    };

    function renderWhitelist() {
        try {
            const listEl = document.getElementById('device-whitelist-list');
            const emptyEl = document.getElementById('device-whitelist-empty');
            if (!listEl || !emptyEl) return;

            if (!whitelistState.current.length) {
                listEl.innerHTML = '';
                emptyEl.style.display = 'block';
                return;
            }
            emptyEl.style.display = 'none';

            listEl.innerHTML = '';
            whitelistState.current.forEach(entry => {
                const chip = document.createElement('div');
                chip.className = 'ip-chip';
                chip.style.cssText = `
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                    padding: 8px 12px;
                    background: var(--color-bg-secondary);
                    border: 1px solid var(--color-border);
                    border-radius: 6px;
                    font-size: 13px;
                    font-weight: 500;
                    color: var(--color-text-primary);
                    transition: border-color 0.2s ease;
                `;

                chip.innerHTML = `
                    <span class="ip-text" style="
                        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; 
                        letter-spacing: 0.01em;
                        color: var(--color-text-primary);
                    ">${entry}</span>
                    <button type="button" class="ip-remove" title="Remove ${entry}" aria-label="Remove ${entry}" style="
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 18px;
                        height: 18px;
                        border: none;
                        background: transparent;
                        color: var(--color-text-muted);
                        border-radius: 3px;
                        cursor: pointer;
                        transition: color 0.2s ease;
                        font-size: 10px;
                    " onmouseover="this.style.color='var(--color-error)'" onmouseout="this.style.color='var(--color-text-muted)'">
                        <i class="fas fa-times"></i>
                    </button>
                `;

                // Subtle hover effect for the chip
                chip.addEventListener('mouseenter', () => {
                    chip.style.borderColor = 'var(--color-primary)';
                });
                chip.addEventListener('mouseleave', () => {
                    chip.style.borderColor = 'var(--color-border)';
                });

                // Remove functionality
                chip.querySelector('.ip-remove').addEventListener('click', () => {
                    whitelistState.current = whitelistState.current.filter(v => v !== entry);
                    markWhitelistDirty();
                    renderWhitelist();
                });

                listEl.appendChild(chip);
            });
        } catch (e) {
            console.warn('Whitelist render error', e);
        }
    }

    function markWhitelistDirty() {
        whitelistState.dirty =
            JSON.stringify(whitelistState.current) !== JSON.stringify(whitelistState.original);
        const saveBtn = document.getElementById('btn-whitelist-save');
        if (saveBtn) {
            saveBtn.disabled = !whitelistState.dirty || whitelistState.saving;
        }
    }

    function loadWhitelistFromConfig(cfg) {
        try {
            const arr =
                cfg?.config?.deviceMgmt?.bypass?.ipAllowList ||
                cfg?.deviceMgmt?.bypass?.ipAllowList ||
                [];
            whitelistState.original = Array.isArray(arr) ? [...arr] : [];
            whitelistState.current = [...whitelistState.original];
            whitelistState.dirty = false;
            renderWhitelist();
            markWhitelistDirty();
        } catch (e) {
            console.warn('Load whitelist error', e);
        }
    }

    async function saveWhitelist() {
        if (!whitelistState.dirty || whitelistState.saving) return;
        whitelistState.saving = true;
        markWhitelistDirty();
        const statusEl = document.getElementById('whitelist-status');

        try {
            // Get current config
            const cfgResp = await fetch('/api/admin/config', {
                method: 'GET',
                credentials: 'include',
            });
            if (!cfgResp.ok) throw new Error('Failed to load config');
            const fullCfg = await cfgResp.json();

            // Update whitelist in config (fix both locations to ensure consistency)
            if (!fullCfg.config.deviceMgmt) fullCfg.config.deviceMgmt = {};
            if (!fullCfg.config.deviceMgmt.bypass) fullCfg.config.deviceMgmt.bypass = {};
            fullCfg.config.deviceMgmt.bypass.ipAllowList = [...whitelistState.current];

            // Also update the root deviceMgmt (for backwards compatibility)
            if (!fullCfg.deviceMgmt) fullCfg.deviceMgmt = {};
            if (!fullCfg.deviceMgmt.bypass) fullCfg.deviceMgmt.bypass = {};
            fullCfg.deviceMgmt.bypass.ipAllowList = [...whitelistState.current];

            // Save config
            const saveResp = await fetch('/api/admin/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify(fullCfg),
            });

            if (!saveResp.ok) {
                const errorText = await saveResp.text();
                console.error('Save failed with status:', saveResp.status, 'Response:', errorText);
                throw new Error(`Failed to save config: ${saveResp.status} ${errorText}`);
            }

            await saveResp.text(); // Consume response

            // Update state
            whitelistState.original = [...whitelistState.current];
            whitelistState.dirty = false;
            if (statusEl) {
                statusEl.style.display = 'block';
                statusEl.textContent = 'Whitelist saved.';
                statusEl.style.color = '#22c55e';
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
            markWhitelistDirty();
        } catch (e) {
            console.error('Save whitelist error', e);
            if (statusEl) {
                statusEl.style.display = 'block';
                statusEl.style.color = '#ef4444';
                statusEl.textContent = 'Error saving whitelist: ' + e.message;
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        } finally {
            whitelistState.saving = false;
            markWhitelistDirty();
        }
    }

    // Simple IPv4 validation
    function isValidIPv4(ip) {
        const parts = ip.split('.');
        if (parts.length !== 4) return false;
        return parts.every(part => {
            const num = parseInt(part, 10);
            return num >= 0 && num <= 255 && part === String(num);
        });
    }

    function isValidIPv4CIDR(cidr) {
        const [ip, prefix] = cidr.split('/');
        if (!ip || prefix === undefined) return false;
        if (!isValidIPv4(ip)) return false;
        const prefixNum = parseInt(prefix, 10);
        return prefixNum >= 0 && prefixNum <= 32;
    }

    // Show error modal with custom message
    function showErrorModal(message) {
        const modal = document.getElementById('modal-error');
        const messageElement = document.getElementById('modal-error-message');
        if (modal && messageElement) {
            messageElement.textContent = message;
            modal.classList.add('open');
        }
    }

    function initWhitelistEvents() {
        try {
            const addBtn = document.getElementById('btn-add-whitelist');
            const saveBtn = document.getElementById('btn-whitelist-save');
            const input = document.getElementById('input-whitelist-entry');

            if (!addBtn || !saveBtn || !input) return;

            // Add entry
            const addEntry = () => {
                const raw = input.value.trim();
                if (!raw) return;

                // Basic IPv4 validation (single IP or CIDR)
                const isValid = raw.includes('/') ? isValidIPv4CIDR(raw) : isValidIPv4(raw);
                if (!isValid) {
                    showErrorModal(
                        'Please enter a valid IPv4 address or CIDR range (e.g. 192.168.1.25 or 192.168.0.0/16)'
                    );
                    return;
                }

                if (!whitelistState.current.includes(raw)) {
                    whitelistState.current.push(raw);
                    whitelistState.current.sort();
                    markWhitelistDirty();
                    renderWhitelist();
                    input.value = '';
                }
            };

            addBtn.addEventListener('click', addEntry);
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addEntry();
                }
            });

            // Restrict input to IP-related characters only (numbers, dots, slashes)
            input.addEventListener('input', e => {
                // Allow only numbers, dots, and forward slashes for IP/CIDR
                const allowedChars = /[^0-9./]/g;
                const cursorPos = e.target.selectionStart;
                const originalValue = e.target.value;
                const filteredValue = originalValue.replace(allowedChars, '');

                if (originalValue !== filteredValue) {
                    e.target.value = filteredValue;
                    // Restore cursor position accounting for removed characters
                    const removedChars = originalValue.length - filteredValue.length;
                    e.target.setSelectionRange(cursorPos - removedChars, cursorPos - removedChars);
                }
            });

            // Also prevent paste of invalid characters
            input.addEventListener('paste', e => {
                e.preventDefault();
                const paste = (e.clipboardData || window.clipboardData).getData('text');
                const filtered = paste.replace(/[^0-9./]/g, '');
                const cursorPos = e.target.selectionStart;
                const currentValue = e.target.value;
                const newValue =
                    currentValue.slice(0, cursorPos) +
                    filtered +
                    currentValue.slice(e.target.selectionEnd);
                e.target.value = newValue;
                e.target.setSelectionRange(
                    cursorPos + filtered.length,
                    cursorPos + filtered.length
                );
            });

            // Save whitelist
            saveBtn.addEventListener('click', () => {
                if (!whitelistState.dirty || whitelistState.saving) return;
                saveWhitelist();
            });
        } catch (e) {
            console.warn('Whitelist events init error', e);
        }
    }

    // Initialize whitelist on config load
    document.addEventListener('DOMContentLoaded', () => {
        initWhitelistEvents();

        // Load initial whitelist from config
        fetchJSON('/api/admin/config')
            .then(cfg => {
                if (cfg) loadWhitelistFromConfig(cfg);
            })
            .catch(() => {
                console.warn('Failed to load initial whitelist config');
            });
    });

    // Listen for reload events from section navigation
    document.addEventListener('reloadWhitelist', event => {
        const cfg = event.detail;
        if (cfg) loadWhitelistFromConfig(cfg);
    });

    // Global function to reload whitelist data when section becomes active
    window.reloadWhitelistData = function () {
        fetch('/api/admin/config')
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch config');
                return response.json();
            })
            .then(cfg => {
                // Dispatch custom event to trigger whitelist reload
                const event = new CustomEvent('reloadWhitelist', { detail: cfg });
                document.dispatchEvent(event);
            })
            .catch(error => {
                console.error('Failed to reload whitelist data:', error);
            });
    };
})();

// ===== Fallback spinner delegation (late-phase safety net) =====
// Ensures number spinner buttons work even if earlier wiring failed due to
// race conditions or partial DOM when navigating directly to Media Sources.
// Skips wrappers that already have directHandlers set.
if (!document.__niwDelegatedFallback) {
    document.addEventListener('click', e => {
        const btn = e.target?.closest?.('.number-input-wrapper .number-btn');
        if (!btn) return;
        const wrapper = btn.closest('.number-input-wrapper');
        if (!wrapper) return;
        if (wrapper.dataset.directHandlers === '1') return;
        const input = wrapper.querySelector('input[type="number"]');
        if (!input) return;
        e.preventDefault();
        const stepVal = (() => Number(input.step || '1') || 1)();
        const min = input.min === '' ? null : Number(input.min);
        const max = input.max === '' ? null : Number(input.max);
        const decimalsForStep = s => {
            const str = String(s);
            if (str.includes('e') || str.includes('E')) return 6;
            const i = str.indexOf('.');
            return i === -1 ? 0 : Math.min(6, str.length - i - 1);
        };
        const snap = (val, s) => Math.round(val / s) * s;
        const clamp = v => {
            let val = v;
            if (min != null && !Number.isNaN(min)) val = Math.max(val, min);
            if (max != null && !Number.isNaN(max)) val = Math.min(val, max);
            return val;
        };
        const cur = Number(input.value || '0') || 0;
        let out;
        if (btn.classList.contains('number-inc')) out = clamp(snap(cur + stepVal, stepVal));
        else if (btn.classList.contains('number-dec')) out = clamp(snap(cur - stepVal, stepVal));
        else return;
        const d = decimalsForStep(stepVal);
        input.value = d > 0 ? Number(out).toFixed(d) : String(Math.round(out));
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
    });
    document.__niwDelegatedFallback = true;
}

// ===== Override Modal Schema Assistant (keys panel + autocomplete) =====
(function () {
    const textarea = document.getElementById('override-json');
    if (!textarea) return;
    let schemaCache = null;
    let keyIndex = [];
    let keyIndexMap = {};
    let acEl = null;
    let acActive = -1;
    const statusEl = document.getElementById('override-json-status');

    function fetchSchema() {
        if (schemaCache) return Promise.resolve(schemaCache);
        const candidates = [
            '/api/admin/config-schema', // new alias we added
            '/api/admin/config/schema', // existing admin-prefixed
            '/api/config/schema', // non-admin fallback
        ];
        let attempt = 0;
        const tryNext = () => {
            if (attempt >= candidates.length) {
                console.warn('[override] All schema endpoints failed:', candidates);
                if (statusEl) {
                    statusEl.textContent = 'Schema unavailable (autocomplete limited)';
                    statusEl.className = 'override-status warning';
                }
                return Promise.resolve(null);
            }
            const url = candidates[attempt++];
            return fetch(url, { headers: { Accept: 'application/json' } })
                .then(r => {
                    if (!r.ok) throw new Error('HTTP ' + r.status);
                    return r.json();
                })
                .then(js => {
                    schemaCache = js;
                    return js;
                })
                .catch(err => {
                    console.warn('[override] schema fetch failed for', url, err.message || err);
                    return tryNext();
                });
        };
        return tryNext();
    }
    function buildIndex(schema, pfx = '') {
        if (!schema || schema.type !== 'object') return;
        const props = schema.properties || {};
        Object.entries(props).forEach(([k, v]) => {
            const path = pfx ? pfx + '.' + k : k;
            keyIndex.push({
                path,
                type: v.type || 'any',
                description: v.description || '',
                schema: v,
            });
            keyIndexMap[path] = v;
            if (v.type === 'object') buildIndex(v, path);
        });
    }
    function ensurePanel() {
        const list = document.getElementById('ov-keys-list');
        const search = document.getElementById('ov-keys-search');
        const emptyEl = document.getElementById('ov-keys-empty');
        if (!list || !search) return;
        let activeIndex = -1;
        function render(filter = '') {
            const f = filter.trim().toLowerCase();
            list.innerHTML = '';
            if (!f) {
                // Show empty prompt
                if (emptyEl) {
                    emptyEl.textContent = 'Start typing to see matching keys.';
                    emptyEl.style.display = 'block';
                }
                activeIndex = -1;
                updateActive();
                return;
            }
            let count = 0;
            keyIndex.forEach(it => {
                if (!it.path.toLowerCase().includes(f)) return;
                if (count >= 400) return; // safety cap
                const div = document.createElement('div');
                div.className = 'ov-key-item';
                div.dataset.path = it.path;
                div.innerHTML = `<span class="k">${it.path}</span><span class="ov-key-type t-${it.type}">${it.type}</span>`;
                div.title = it.description || it.path;
                div.addEventListener('click', () => insertKey(it.path));
                list.appendChild(div);
                count++;
            });
            if (!list.children.length) {
                if (emptyEl) {
                    emptyEl.textContent = 'No matching keys';
                    emptyEl.style.display = 'block';
                }
                activeIndex = -1;
            } else {
                if (emptyEl) emptyEl.style.display = 'none';
                activeIndex = 0;
            }
            updateActive();
        }
        function updateActive() {
            [...list.children].forEach((el, i) => el.classList.toggle('active', i === activeIndex));
        }
        search.addEventListener('input', () => render(search.value));
        search.addEventListener('focus', () => {
            if (!search.value) render(''); // will show empty prompt
        });
        search.addEventListener('keydown', e => {
            const total = list.children.length;
            if (!total) return;
            if (e.key === 'ArrowDown') {
                activeIndex = (activeIndex + 1) % total;
                updateActive();
                e.preventDefault();
            } else if (e.key === 'ArrowUp') {
                activeIndex = (activeIndex - 1 + total) % total;
                updateActive();
                e.preventDefault();
            } else if (e.key === 'Enter' && activeIndex >= 0) {
                const item = list.children[activeIndex];
                if (item) {
                    insertKey(item.dataset.path);
                    e.preventDefault();
                }
            } else if (e.key === 'Escape') {
                search.blur();
            }
        });
        // initial: do not render keys list until user types
        if (emptyEl) emptyEl.style.display = 'block';
    }
    // Legacy dropdown listener removed: segmented control now the single source of truth for mode flags
    function insertKey(path) {
        let obj = {};
        try {
            obj = JSON.parse(textarea.value || '{}');
        } catch (_) {
            obj = {};
        }
        const parts = path.split('.');
        let node = obj;
        for (let i = 0; i < parts.length; i++) {
            const p = parts[i];
            if (i === parts.length - 1) {
                const schemaNode = keyIndexMap[path];
                let val = null;
                if (schemaNode) {
                    if ('default' in schemaNode) val = schemaNode.default;
                    else if (schemaNode.type === 'string') val = '';
                    else if (schemaNode.type === 'number' || schemaNode.type === 'integer') val = 0;
                    else if (schemaNode.type === 'boolean') val = false;
                    else if (schemaNode.type === 'array') val = [];
                    else if (schemaNode.type === 'object') val = {};
                }
                node[p] = val;
            } else {
                if (!node[p] || typeof node[p] !== 'object') node[p] = {};
                node = node[p];
            }
        }
        textarea.value = JSON.stringify(obj, null, 2);
        textarea.dispatchEvent(new Event('input'));
    }
    function caretPos(el) {
        return el.selectionStart;
    }
    function tokenBefore(text, caret) {
        let i = caret - 1;
        while (i >= 0 && /[A-Za-z0-9_.]/.test(text[i])) i--;
        return text.slice(i + 1, caret);
    }
    function showAC(matches) {
        hideAC();
        if (!matches.length) return;
        acEl = document.createElement('div');
        acEl.className = 'ov-autocomplete';
        matches.slice(0, 150).forEach(it => {
            const d = document.createElement('div');
            d.className = 'ov-autocomplete-item';
            d.dataset.path = it.path;
            d.innerHTML = `<span>${it.path}</span><span class="ov-key-type t-${it.type}">${it.type}</span>`;
            d.addEventListener('mousedown', e => {
                e.preventDefault();
                applyAC(it.path);
            });
            acEl.appendChild(d);
        });
        document.body.appendChild(acEl);
        positionAC();
    }
    function positionAC() {
        if (!acEl) return;
        const r = textarea.getBoundingClientRect();
        acEl.style.top = window.scrollY + r.bottom + 4 + 'px';
        acEl.style.left = window.scrollX + r.left + 'px';
    }
    function hideAC() {
        if (acEl) {
            acEl.remove();
            acEl = null;
            acActive = -1;
        }
    }
    function moveAC(d) {
        if (!acEl) return;
        const items = [...acEl.querySelectorAll('.ov-autocomplete-item')];
        if (!items.length) return;
        acActive = (acActive + d + items.length) % items.length;
        items.forEach((el, i) => el.classList.toggle('active', i === acActive));
    }
    function applyAC(path) {
        const caret = caretPos(textarea);
        const text = textarea.value;
        const token = tokenBefore(text, caret);
        const start = caret - token.length;
        const before = text.slice(0, start);
        const after = text.slice(caret);
        textarea.value = before + path + after;
        const newCaret = start + path.length;
        textarea.setSelectionRange(newCaret, newCaret);
        hideAC();
        textarea.focus();
    }
    function handleAC() {
        const caret = caretPos(textarea);
        const text = textarea.value;
        const token = tokenBefore(text, caret);
        if (token.length < 2) {
            hideAC();
            return;
        }
        const lower = token.toLowerCase();
        const matches = keyIndex.filter(k => k.path.toLowerCase().startsWith(lower));
        if (matches.length) showAC(matches);
        else hideAC();
    }
    function validateAgainstSchema() {
        if (!schemaCache) return;
        let obj;
        try {
            obj = JSON.parse(textarea.value);
        } catch (e) {
            if (statusEl) {
                statusEl.textContent = 'Invalid JSON';
                statusEl.className = 'override-status error';
            }
            return;
        }
        const unknown = [];
        const typeMismatches = [];
        function walk(node, prefix) {
            if (node && typeof node === 'object' && !Array.isArray(node)) {
                Object.entries(node).forEach(([k, v]) => {
                    const path = prefix ? prefix + '.' + k : k;
                    const schemaNode = keyIndexMap[path];
                    if (!schemaNode) {
                        unknown.push(path);
                    } else {
                        const expected = schemaNode.type;
                        const actual = Array.isArray(v) ? 'array' : v === null ? 'null' : typeof v;
                        if (expected && expected !== 'any') {
                            if (Array.isArray(expected)) {
                                if (!expected.includes(actual))
                                    typeMismatches.push({
                                        path,
                                        expected: expected.join('|'),
                                        actual,
                                    });
                            } else if (expected !== actual) {
                                typeMismatches.push({ path, expected, actual });
                            }
                        }
                    }
                    walk(v, path);
                });
            }
        }
        walk(obj, '');
        if (statusEl) {
            if (!unknown.length && !typeMismatches.length) {
                statusEl.textContent = 'Valid JSON';
                statusEl.className = 'override-status success';
            } else {
                const parts = [];
                if (unknown.length) parts.push(unknown.length + ' unknown');
                if (typeMismatches.length) parts.push(typeMismatches.length + ' type mismatches');
                statusEl.textContent = 'Warnings: ' + parts.join(', ');
                statusEl.className = 'override-status warning';
            }
        }
    }
    function handleInput() {
        handleAC();
        validateAgainstSchema();
    }
    textarea.addEventListener('input', handleInput);
    textarea.addEventListener('keydown', e => {
        if (acEl) {
            if (e.key === 'ArrowDown') {
                moveAC(1);
                e.preventDefault();
            } else if (e.key === 'ArrowUp') {
                moveAC(-1);
                e.preventDefault();
            } else if (e.key === 'Enter') {
                if (acActive >= 0) {
                    const it = acEl.querySelectorAll('.ov-autocomplete-item')[acActive];
                    if (it) {
                        applyAC(it.dataset.path);
                        e.preventDefault();
                    }
                }
            } else if (e.key === 'Escape') {
                hideAC();
            }
        }
    });
    document.addEventListener('click', e => {
        if (acEl && !acEl.contains(e.target) && e.target !== textarea) hideAC();
    });
    const modal = document.getElementById('modal-override');
    const obs = new MutationObserver(() => {
        const open = modal.classList.contains('open');
        if (open && !schemaCache) {
            fetchSchema().then(s => {
                if (!s) return;
                keyIndex = [];
                keyIndexMap = {};
                buildIndex(s);
                ensurePanel();
                validateAgainstSchema();
                if (statusEl) {
                    statusEl.textContent = 'Schema loaded (' + keyIndex.length + ' keys)';
                    statusEl.className = 'override-status success';
                }
            });
        }
    });
    obs.observe(modal, { attributes: true, attributeFilter: ['class'] });
})();

/* ============================================= */
/* Local Directory Management */
/* Cache bust: 2025-10-04 16:12 */
/* ============================================= */

(function initLocalDirectory() {
    let currentPath = '/';
    let currentRelativePath = ''; // Relative path from rootPath for API calls
    let isSearchMode = false;
    // eslint-disable-next-line no-unused-vars
    let currentSearchQuery = '';
    const selectedFiles = new Set();

    // Directory picker modal removed (fixed root)

    function resolveSaveConfigHelper() {
        if (typeof saveConfigPatch === 'function') return saveConfigPatch;
        if (typeof window !== 'undefined') {
            if (typeof window.saveConfigPatch === 'function') return window.saveConfigPatch;
            if (typeof window.__saveConfigPatch === 'function') return window.__saveConfigPatch;
        }
        return null;
    }

    // Path helpers removed with modal

    // Initialize the local directory panel - following the same pattern as Plex/Jellyfin
    window.admin2 = window.admin2 || {};

    function maybeInitLocalDirectoryOnOpen() {
        try {
            (async () => {
                window.__autoFetchedLibs = window.__autoFetchedLibs || {
                    plex: false,
                    jf: false,
                    local: false,
                };

                // Initialize local directory panel when opening for the first time
                if (!window.__autoFetchedLibs.local) {
                    window.__autoFetchedLibs.local = true;

                    // Initialize components
                    initFileDropZone();
                    initDirectoryBrowser();
                    initEventListeners();

                    // Load initial state
                    loadLocalDirectoryConfig();
                }
            })();
        } catch (error) {
            console.error('Error initializing local directory panel:', error);
        }
    }

    window.admin2.maybeInitLocalDirectoryOnOpen = maybeInitLocalDirectoryOnOpen;

    // Safety net: if the Local panel becomes visible and the browser still shows the
    // initial placeholder, auto-initialize and trigger a directory load. This guards
    // against rare timing issues where the init function isn't called by the router
    // or segmented-tabs handler.
    try {
        const panel = document.getElementById('panel-local');
        if (panel && !panel.__localObs) {
            const checkAndInit = () => {
                if (panel.hidden) return;
                // Ensure init is attempted
                try {
                    window.admin2?.maybeInitLocalDirectoryOnOpen?.();
                } catch (_) {
                    /* best-effort init; ignore if admin2 or method not available */
                }
                // If content remains the static placeholder, force a config load
                setTimeout(() => {
                    try {
                        const host = document.getElementById('local-browser-content');
                        if (!host) return;
                        const hasList = !!host.querySelector('.browser-list');
                        const hasEmpty = !!host.querySelector('.browser-empty');
                        if (!hasList && hasEmpty) {
                            loadLocalDirectoryConfig();
                        }
                    } catch (_) {
                        /* optional placeholder check; non-fatal if DOM not ready */
                    }
                }, 50);
            };
            const mo = new MutationObserver(() => checkAndInit());
            mo.observe(panel, { attributes: true, attributeFilter: ['hidden', 'class'] });
            panel.__localObs = mo;
            // If already visible on load, run once immediately
            if (!panel.hidden) checkAndInit();
        }
        // Also handle direct navigation to #local via hash changes
        window.addEventListener('hashchange', () => {
            try {
                const h = (location.hash || '').toLowerCase();
                if (h === '#local') {
                    setTimeout(() => {
                        try {
                            const p = document.getElementById('panel-local');
                            if (p && !p.hidden) {
                                window.admin2?.maybeInitLocalDirectoryOnOpen?.();
                                const host = document.getElementById('local-browser-content');
                                if (host && !host.querySelector('.browser-list')) {
                                    loadLocalDirectoryConfig();
                                }
                            }
                        } catch (_) {
                            /* numeric wrapper width xs class add failed (cosmetic) */
                        }
                    }, 40);
                }
            } catch (_) {
                /* hash handling is optional; ignore transient errors */
            }
        });
    } catch (_) {
        /* observer wiring is optional and may fail in legacy contexts */
    }

    function initFileDropZone() {
        // Quick Upload removed; only wire per-directory buttons/inputs
        const dropZone = document.getElementById('local-file-drop');
        const fileInput = document.getElementById('local-file-input');
        const selectBtn = document.getElementById('btn-select-files');
        const btnPosters = document.getElementById('btn-upload-posters');
        const btnBackgrounds = document.getElementById('btn-upload-backgrounds');
        const btnMotion = document.getElementById('btn-upload-motion');
        const btnPacks = document.getElementById('btn-upload-packs');
        const fiPosters = document.getElementById('file-input-posters');
        const fiBackgrounds = document.getElementById('file-input-backgrounds');
        const fiMotion = document.getElementById('file-input-motion');
        const fiPacks = document.getElementById('file-input-packs');

        // Guard: Quick Upload may not exist; skip these
        if (selectBtn && fileInput) {
            selectBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', e =>
                handleFileSelection(e, inferTargetFromPath())
            );
        }

        // Per-directory uploads
        const openFilePicker = (fi, targetDir) => {
            if (!fi) return;
            // Reentrancy guard to prevent double opening on cancel/escape
            if (fi.__opening) return;
            fi.__opening = true;
            // Ensure selecting same file again will fire 'change'
            try {
                fi.value = '';
            } catch (_) {
                /* clearing input value can fail on some browsers; safe to ignore */
            }
            // Fallback: clear opening state after a short delay in case no 'change' fires (cancel)
            const clearOpen = () => {
                fi.__opening = false;
            };
            const clearTimer = setTimeout(clearOpen, 1200);
            // One-time change handler to clear the guard sooner
            const onChange = e => {
                clearTimeout(clearTimer);
                fi.__opening = false;
                handleFileSelection(e, targetDir);
                // Reset so same file selection triggers change next time
                try {
                    fi.value = '';
                } catch (_) {
                    /* resetting input to allow same-file reselect; ignore if blocked */
                }
                fi.removeEventListener('change', onChange);
            };
            fi.addEventListener('change', onChange);
            // Open dialog
            fi.click();
        };

        if (btnPosters && fiPosters) {
            btnPosters.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();
                openFilePicker(fiPosters, 'posters');
            });
        }
        if (btnBackgrounds && fiBackgrounds) {
            btnBackgrounds.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();
                openFilePicker(fiBackgrounds, 'backgrounds');
            });
        }
        if (btnMotion && fiMotion) {
            btnMotion.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();
                openFilePicker(fiMotion, 'motion');
            });
        }
        if (btnPacks && fiPacks) {
            btnPacks.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();
                openFilePicker(fiPacks, 'complete');
            });
        }

        // Drag and drop (Quick Upload) removed
        if (dropZone) {
            // If a drop zone is reintroduced later, wire events here
        }
    }

    function initDirectoryBrowser() {
        const refreshBtn = document.getElementById('btn-refresh-browser');
        if (refreshBtn)
            refreshBtn.addEventListener('click', () => loadDirectoryContents(currentPath));

        // Search functionality - recursive search via API
        const searchInput = document.getElementById('local-browser-search');
        const clearBtn = document.getElementById('local-search-clear');

        if (searchInput) {
            let searchTimeout;

            // Show/hide clear button based on input content
            const updateClearButton = () => {
                if (clearBtn) {
                    clearBtn.style.display = searchInput.value ? 'flex' : 'none';
                }
            };

            searchInput.addEventListener('input', e => {
                const query = e.target.value.toLowerCase().trim();
                updateClearButton();

                // Clear previous timeout
                clearTimeout(searchTimeout);

                // If empty query, exit search mode and reload current directory
                if (!query) {
                    isSearchMode = false;
                    currentSearchQuery = '';
                    loadDirectoryContents(currentPath);
                    return;
                }

                // Debounce search for 300ms
                searchTimeout = setTimeout(async () => {
                    try {
                        isSearchMode = true;
                        currentSearchQuery = query;
                        stopRealtimeDirectoryRefresh(); // Stop auto-refresh during search

                        const searchPath = currentRelativePath || '';
                        const response = await fetch(
                            `/api/local/search?query=${encodeURIComponent(query)}&path=${encodeURIComponent(searchPath)}`
                        );
                        if (!response.ok) throw new Error('Search failed');

                        const results = await response.json();
                        renderSearchResults(results, query);
                    } catch (error) {
                        console.error('Search error:', error);
                        isSearchMode = false;
                        currentSearchQuery = '';
                        // Fallback to local filtering if API fails
                        const browserContent = document.getElementById('local-browser-content');
                        if (!browserContent) return;

                        const items = browserContent.querySelectorAll('.browser-item');
                        items.forEach(item => {
                            const nameEl = item.querySelector('.name-text');
                            const name = nameEl ? nameEl.textContent.toLowerCase() : '';
                            item.style.display = !query || name.includes(query) ? '' : 'none';
                        });
                    }
                }, 300);
            });

            // Clear button functionality
            if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                    searchInput.value = '';
                    updateClearButton();
                    isSearchMode = false;
                    currentSearchQuery = '';
                    loadDirectoryContents(currentPath);
                    searchInput.focus();
                });
            }
        }

        // Create-folder and Delete-selected are not present in maintenance mode
        const dlBtn = document.getElementById('btn-download-dir');
        if (dlBtn) {
            dlBtn.addEventListener('click', e => {
                e.preventDefault();
                const pathToZip = currentPath || '/';
                const url = `/api/local/download-all?path=${encodeURIComponent(pathToZip)}`;
                const dlg =
                    window.confirmAction ||
                    (opts =>
                        Promise.resolve(
                            window.confirm(opts?.message || 'Download all files in this folder?')
                        ));
                dlg({
                    title: 'Download folder as ZIP',
                    message:
                        `This will bundle and download all files inside:<br><code>${pathToZip}</code><br><br>` +
                        `Large folders may take time to prepare. Continue?`,
                    okText: 'Download',
                    okClass: 'btn-confirm-accent',
                    okIcon: 'file-zipper',
                }).then(ok => {
                    if (!ok) return;
                    window.location.href = url;
                });
            });
        }
    }

    function initEventListeners() {
        // Save settings button
        const saveBtn = document.getElementById('btn-save-local');
        if (saveBtn) {
            // Remove existing listener if any
            saveBtn.removeEventListener('click', saveLocalDirectorySettings);
            saveBtn.addEventListener('click', saveLocalDirectorySettings);
        }

        // Browse path button
        const browsePathBtn = document.getElementById('btn-browse-path');
        if (browsePathBtn) {
            // Hide the browse button; path is fixed
            browsePathBtn.style.display = 'none';
        }

        // Directory scan button
        const scanBtn = document.getElementById('btn-local-scan');
        if (scanBtn) scanBtn.addEventListener('click', scanDirectory);

        // Browse button removed (redundant with Refresh)

        // Posterpack generation
        const generateBtn = document.getElementById('btn-generate-posterpack');
        if (generateBtn) generateBtn.addEventListener('click', generatePosterpack);

        const previewBtn = document.getElementById('btn-preview-posterpack');
        if (previewBtn) previewBtn.addEventListener('click', previewPosterpackSelection);

        const sourceSelect = document.getElementById('posterpack.source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', handleSourceSelection);
            // trigger once on load to sync visibility and maybe populate libraries
            handleSourceSelection({ target: sourceSelect });
            // also re-sync shortly after load to defend against late DOM updates
            setTimeout(() => handleSourceSelection({ target: sourceSelect }), 250);
            setTimeout(() => handleSourceSelection({ target: sourceSelect }), 800);
        }
        // Initialize Posterpack multiselect widgets (empty; options populated later)
        try {
            if (typeof initMsForSelect === 'function') {
                initMsForSelect('pp-plex-ms-movies', 'pp-plex.movies');
                initMsForSelect('pp-plex-ms-shows', 'pp-plex.shows');
                initMsForSelect('pp-jf-ms-movies', 'pp-jf.movies');
                initMsForSelect('pp-jf-ms-shows', 'pp-jf.shows');
            }
        } catch (_) {
            /* multiselect init is cosmetic; ignore failures */
        }

        // Clear completed jobs
        const clearJobsBtn = document.getElementById('btn-clear-completed-jobs');
        if (clearJobsBtn) clearJobsBtn.addEventListener('click', clearCompletedJobs);
    }

    // Quick Upload drag/drop handlers removed

    function handleFileSelection(e, targetDirectory = 'posters') {
        const files = Array.from(e.target.files || []);
        uploadFiles(files, targetDirectory);
    }

    function inferTargetFromPath() {
        try {
            const p = (currentPath || '/').toLowerCase();
            if (/\/backgrounds\/?$/.test(p) || /\/(?:^|.*\/)backgrounds(\/|$)/.test(p))
                return 'backgrounds';
            if (/\/motion\/?$/.test(p) || /\/(?:^|.*\/)motion(\/|$)/.test(p)) return 'motion';
            // Posterpack uploads should always target 'complete' (manual)
            if (/\/(?:^|.*\/)posterpacks(\/|$)/.test(p)) return 'complete';
            if (/\/complete\/?$/.test(p) || /\/(?:^|.*\/)complete(\/|$)/.test(p)) return 'complete';
            return 'posters';
        } catch (_) {
            return 'posters';
        }
    }

    function uploadFiles(files, targetDirectory = 'posters') {
        if (files.length === 0) return;

        const formData = new FormData();
        files.forEach(file => {
            formData.append('files', file);
        });
        // Include target for server-side validation
        formData.append('targetDirectory', targetDirectory);
        // Minimal UX: show transient notification while uploading
        showNotification(`Uploading to ${targetDirectory}…`, 'info');

        fetch('/api/local/upload', {
            method: 'POST',
            body: formData,
        })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    const td = result.targetDirectory || targetDirectory;
                    showNotification(
                        `Uploaded ${result.uploadedFiles?.length || files.length} file(s) to ${td}`,
                        'success'
                    );
                    // Update view while keeping handlers intact
                    refreshDirectorySafe(true);
                } else {
                    showNotification(result.message || 'Upload failed', 'error');
                }
            })
            .catch(error => {
                console.error('Upload error:', error);
                showNotification('Upload failed', 'error');
            });
    }

    function loadDirectoryContents(path = '/') {
        // Exit search mode when navigating
        isSearchMode = false;
        currentSearchQuery = '';

        // Keep the requested path, but we will normalize after fetching server data
        currentPath = path;

        const browserContent = document.getElementById('local-browser-content');
        if (!browserContent) return;

        // Show loading state
        browserContent.innerHTML =
            '<div class="browser-empty"><i class="fas fa-spinner fa-spin"></i><div>Loading...</div></div>';

        fetch(`/api/local/browse?path=${encodeURIComponent(path)}`)
            .then(response => response.json())
            .then(result => {
                // Expecting { basePath, currentPath, directories: [], files: [], totalItems }
                const hasPayload =
                    !!result && (Array.isArray(result.files) || Array.isArray(result.directories));
                if (hasPayload) {
                    // Update currentPath to absolute path from server
                    if (result.currentPath) currentPath = result.currentPath;
                    // Compute a relative path for breadcrumb display and API calls
                    const rel =
                        result.basePath &&
                        result.currentPath &&
                        result.currentPath.startsWith(result.basePath)
                            ? result.currentPath.slice(result.basePath.length) || '/'
                            : result.currentPath || '/';
                    // Store the relative path (remove leading slash for API)
                    currentRelativePath = rel === '/' ? '' : rel.replace(/^\/+/, '');
                    // Don't auto-refresh directory contents - only refresh on user action
                    // startRealtimeDirectoryRefresh();
                    updateBreadcrumb(rel);
                    renderDirectoryContents(result);
                } else {
                    browserContent.innerHTML = `
                        <div class="browser-empty">
                            <i class="fas fa-exclamation-triangle"></i>
                            <div>Error loading directory</div>
                            <small>${(result && result.error) || 'Unknown error'}</small>
                        </div>
                    `;
                }
            })
            .catch(error => {
                console.error('Directory browse error:', error);
                browserContent.innerHTML = `
                    <div class="browser-empty">
                        <i class="fas fa-exclamation-triangle"></i>
                        <div>Failed to load directory</div>
                        <small>Check console for details</small>
                    </div>
                `;
            });
    }

    // --- Realtime Directory size updates (safe and throttled) ---
    let __browserRefreshTimer = null;
    let __browserRefreshInFlight = null;
    let __browserRefreshCooldownUntil = 0;
    const BROWSER_MIN_INTERVAL = 3000; // 3s between refreshes (adaptive)
    async function refreshDirectorySafe(forceFresh = false) {
        try {
            // Don't refresh if in search mode
            if (isSearchMode) {
                return;
            }

            const now = Date.now();
            if (now < __browserRefreshCooldownUntil) return;
            if (__browserRefreshInFlight) {
                await __browserRefreshInFlight;
                return;
            }
            // Only refresh when Local browser is visible
            const host = document.getElementById('local-browser-content');
            const visible = !!host && host.offsetParent !== null; // not display:none
            if (!visible) {
                stopRealtimeDirectoryRefresh();
                return;
            }
            const url = `/api/local/browse?path=${encodeURIComponent(currentPath || '/')}${
                forceFresh ? `&_=${Date.now()}` : ''
            }`;
            // Prefer dedupJSON to re-use its 10s mini cache and status handling
            const p = (async () => {
                let res, data;
                if (typeof window.dedupJSON === 'function') {
                    const headers = forceFresh
                        ? { Pragma: 'no-cache', 'Cache-Control': 'no-cache' }
                        : undefined;
                    res = await window.dedupJSON(url, { credentials: 'include', headers });
                    if (res && res.status === 429) {
                        __browserRefreshCooldownUntil = Date.now() + 15_000; // 15s cool-down
                        return null;
                    }
                    data = res && res.ok ? await res.json() : null;
                } else {
                    const r = await fetch(url, {
                        credentials: 'include',
                        headers: forceFresh
                            ? { Pragma: 'no-cache', 'Cache-Control': 'no-cache' }
                            : undefined,
                    }).catch(() => null);
                    if (!r) return null;
                    if (r.status === 429) {
                        __browserRefreshCooldownUntil = Date.now() + 15_000;
                        return null;
                    }
                    data = r.ok ? await r.json().catch(() => null) : null;
                }
                if (!data) return null;
                // Only re-render sizes; preserve handlers (we re-render the list anyway with a single delegated handler)
                renderDirectoryContents(data);
                // If this was a forced refresh, schedule a quick follow-up to catch rapid changes
                if (forceFresh) {
                    setTimeout(() => {
                        // Fire-and-forget; internal guards prevent overlap
                        refreshDirectorySafe(false);
                    }, 600);
                }
                return data;
            })();
            __browserRefreshInFlight = p;
            await p;
        } catch (_) {
            // ignore
        } finally {
            __browserRefreshInFlight = null;
        }
    }
    function startRealtimeDirectoryRefresh() {
        if (__browserRefreshTimer) return;
        const tick = async () => {
            try {
                await refreshDirectorySafe();
            } finally {
                __browserRefreshTimer = setTimeout(tick, BROWSER_MIN_INTERVAL);
            }
        };
        // Trigger an immediate refresh so header pills and sizes update without initial delay
        tick();
    }
    function stopRealtimeDirectoryRefresh() {
        if (__browserRefreshTimer) {
            clearTimeout(__browserRefreshTimer);
            __browserRefreshTimer = null;
        }
    }

    function renderSearchResults(results, query) {
        const browserContent = document.getElementById('local-browser-content');
        if (!browserContent) return;

        if (!results || !Array.isArray(results) || results.length === 0) {
            browserContent.innerHTML = `
                <div class="browser-empty">
                    <i class="fas fa-search"></i>
                    <div>No results found for "${query}"</div>
                    <small>Try a different search term</small>
                </div>
            `;
            return;
        }

        const humanSize = bytes => {
            const n = Number(bytes);
            if (!Number.isFinite(n)) return '';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let i = 0;
            let v = n;
            while (v >= 1024 && i < units.length - 1) {
                v /= 1024;
                i++;
            }
            const prec = v >= 100 || i === 0 ? 0 : 1;
            return `${v.toFixed(prec)} ${units[i]}`;
        };

        const listHTML = results
            .map(item => {
                const isDir = item.type === 'directory';
                let iconHtml = '';

                // If this is a ZIP file, attempt to show posterpack thumbnail
                if (!isDir && /\.zip$/i.test(item.name)) {
                    const zipRel = item.path;
                    const tUrl = `/local-posterpack?zip=${encodeURIComponent(zipRel)}&entry=thumbnail`;
                    iconHtml = `
                        <div class="browser-item-icon file has-thumb" data-ziprel="${zipRel}">
                            <img class="pp-zip-thumb" src="${tUrl}" alt="" loading="lazy" decoding="async" referrerpolicy="no-referrer" />
                            <i class="fas fa-file-zipper"></i>
                        </div>`;
                } else {
                    const iconClass = isDir ? 'fa-folder' : 'fa-file';
                    iconHtml = `
                        <div class="browser-item-icon ${item.type}">
                            <i class="fas ${iconClass}"></i>
                        </div>`;
                }

                // Display name: hide .zip extension for cleaner look
                const displayName =
                    !isDir && /\.zip$/i.test(item.name)
                        ? item.name.replace(/\.zip$/i, '')
                        : item.name;

                return `
            <div class="browser-item" data-path="${item.path}" data-type="${item.type}">
                ${iconHtml}
                <div class="browser-item-name">
                    <span class="name-text">${displayName}</span>
                    <span class="status-pill sp-size" style="opacity: 0.6">${item.path}</span>
                    ${item.sizeBytes != null ? `<span class="status-pill sp-size">${humanSize(item.sizeBytes)}</span>` : ''}
                </div>
                <div class="browser-item-actions">
                    ${isDir ? `<button class="btn btn-secondary btn-sm btn-open-folder" data-path="${item.path}" title="Open"><span class="spinner"></span><i class="fas fa-folder-open"></i><span class="hide-on-xs">Open</span></button>` : ''}
                    ${!isDir ? `<button class="btn btn-secondary btn-sm btn-download-file" data-path="${item.path}" title="Download"><span class="spinner"></span><i class="fas fa-download"></i><span class="hide-on-xs">Download</span></button>` : ''}
                    <button class="btn btn-error btn-sm btn-delete" data-path="${item.path}" title="Delete"><span class="spinner"></span><i class="fas fa-trash"></i><span class="hide-on-xs">Delete</span></button>
                </div>
            </div>
        `;
            })
            .join('');

        browserContent.innerHTML = `<div class="browser-list">${listHTML}</div>`;

        // Handle thumbnail loading for ZIP files
        try {
            const icons = browserContent.querySelectorAll('.browser-item-icon.has-thumb');
            icons.forEach(icon => {
                const img = icon.querySelector('img.pp-zip-thumb');
                const ico = icon.querySelector('i');
                if (!img) return;
                const onLoad = () => {
                    icon.classList.add('thumb-loaded');
                    if (ico) ico.style.display = 'none';
                };
                const onError = () => {
                    // Remove image and keep the default icon
                    if (img && img.parentNode) img.parentNode.removeChild(img);
                    icon.classList.remove('thumb-loaded');
                    icon.classList.remove('has-thumb');
                    if (ico) ico.style.display = '';
                };
                // If already complete (cache), apply immediately; else wait
                if (img.complete && img.naturalWidth > 0) onLoad();
                else {
                    img.addEventListener('load', onLoad, { once: true });
                    img.addEventListener('error', onError, { once: true });
                }
            });
        } catch (_) {
            /* icon thumb enhancer is optional; ignore errors */
        }
    }

    function renderDirectoryContents(contents) {
        const browserContent = document.getElementById('local-browser-content');
        if (!browserContent) return;

        // Normalize payload: expect { basePath, currentPath, directories: [], files: [] }
        const basePath = contents?.basePath || '';
        const curr = contents?.currentPath || '';
        const dirsRaw = Array.isArray(contents?.directories) ? contents.directories : [];
        const filesRaw = Array.isArray(contents?.files) ? contents.files : [];
        const normEntry = e =>
            typeof e === 'string'
                ? { name: e, sizeBytes: undefined, zipPills: undefined, itemCount: undefined }
                : {
                      name: e.name,
                      sizeBytes: e.sizeBytes,
                      zipPills: e.zipPills,
                      itemCount: e.itemCount,
                  };
        const dirs = dirsRaw.map(normEntry);
        const files = filesRaw.map(normEntry);

        if (dirs.length === 0 && files.length === 0) {
            browserContent.innerHTML = `
                <div class="browser-empty">
                    <i class="fas fa-folder-open"></i>
                    <div>Empty directory</div>
                    <small>No files or folders found</small>
                </div>
            `;
            return;
        }

        const joinPath = (p, n) => {
            if (!p || p === '/') return `/${n}`;
            return `${p.replace(/\/$/, '')}/${n}`;
        };

        const items = [
            ...dirs.map(d => ({
                name: d.name,
                sizeBytes: d.sizeBytes,
                type: 'directory',
                itemCount: d.itemCount,
                path: joinPath(curr || basePath, d.name),
            })),
            ...files.map(f => ({
                name: f.name,
                sizeBytes: f.sizeBytes,
                zipPills: f.zipPills,
                type: 'file',
                path: joinPath(curr || basePath, f.name),
            })),
        ];

        const humanSize = bytes => {
            const n = Number(bytes);
            if (!Number.isFinite(n)) return '';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let i = 0;
            let v = n;
            while (v >= 1024 && i < units.length - 1) {
                v /= 1024;
                i++;
            }
            const prec = v >= 100 || i === 0 ? 0 : 1;
            return `${v.toFixed(prec)} ${units[i]}`;
        };

        const pillLabel = k =>
            ({
                poster: 'Poster',
                background: 'Background',
                thumbnail: 'Thumbnail',
                clearlogo: 'ClearLogo',
                banner: 'Banner',
                fanart: 'Fanart',
                disc: 'Disc',
                cast: 'Cast',
                metadata: 'Metadata',
                cd: 'CD',
            })[k] || k;

        const listHTML = items
            .map(item => {
                // If this is a ZIP file inside complete/*, attempt to show posterpack thumbnail
                let iconHtml = '';
                if (item.type === 'file' && /\.zip$/i.test(item.name)) {
                    // Compute path relative to basePath for /local-posterpack (server requires relative)
                    let zipRel = '';
                    try {
                        const abs = String(item.path || '');
                        const base = String(basePath || '');
                        zipRel = abs.startsWith(base)
                            ? abs.slice(base.length).replace(/^\/+/, '')
                            : abs; // fallback: best-effort
                    } catch (_) {
                        /* compute relative zip path best-effort; fall back to absolute */
                    }
                    const tUrl = `/local-posterpack?zip=${encodeURIComponent(zipRel)}&entry=thumbnail`;
                    // Render both a tiny img and a fallback icon; we hide the icon once the image loads
                    iconHtml = `
                        <div class="browser-item-icon file has-thumb" data-ziprel="${zipRel}">
                            <img class="pp-zip-thumb" src="${tUrl}" alt="" loading="lazy" decoding="async" referrerpolicy="no-referrer" />
                            <i class="fas fa-file-zipper"></i>
                        </div>`;
                } else {
                    iconHtml = `
                        <div class="browser-item-icon ${item.type}">
                            <i class="fas fa-${item.type === 'directory' ? 'folder' : 'file'}"></i>
                        </div>`;
                }
                // Display name: hide .zip extension for cleaner look
                const displayName =
                    item.type === 'file' && /\.zip$/i.test(item.name)
                        ? item.name.replace(/\.zip$/i, '')
                        : item.name;
                return `
            <div class="browser-item" data-path="${item.path}" data-type="${item.type}">
                ${iconHtml}
                <div class="browser-item-name">
                    <span class="name-text">${displayName}</span>
                    ${
                        item.sizeBytes != null
                            ? `<span class="status-pill sp-size">${humanSize(item.sizeBytes)}</span>`
                            : ''
                    }
                    ${
                        item.type === 'directory' && Number.isFinite(Number(item.itemCount))
                            ? `<span class="status-pill sp-size" title="Item count">${Number(item.itemCount).toLocaleString()}</span>`
                            : ''
                    }
                    ${
                        Array.isArray(item.zipPills) && item.zipPills.length
                            ? item.zipPills
                                  .map(
                                      k =>
                                          `<span class="status-pill sp-size sp-zip">${pillLabel(k)}</span>`
                                  )
                                  .join(' ')
                            : ''
                    }
                </div>
                <div class="browser-item-actions">
                    ${
                        item.type === 'directory'
                            ? `<button class="btn btn-secondary btn-sm btn-upload-here" data-path="${item.path}" data-name="${item.name}" title="Upload"><span class="spinner"></span><i class="fas fa-upload"></i><span class="hide-on-xs">Upload</span></button>
                               <button class="btn btn-secondary btn-sm btn-download-all" data-path="${item.path}" title="Download all"><span class="spinner"></span><i class="fas fa-file-zipper"></i><span class="hide-on-xs">Download All</span></button>`
                            : ''
                    }
                    ${
                        item.type === 'file'
                            ? `<button class="btn btn-secondary btn-sm btn-download-file" data-path="${item.path}" title="Download"><span class="spinner"></span><i class="fas fa-download"></i><span class="hide-on-xs">Download</span></button>`
                            : ''
                    }
                    <button class="btn btn-error btn-sm btn-delete" data-path="${item.path}" title="${
                        item.type === 'directory' ? 'Delete contents' : 'Delete'
                    }"><span class="spinner"></span><i class="fas fa-trash"></i><span class="hide-on-xs">${
                        item.type === 'directory' ? 'Delete' : 'Delete'
                    }</span></button>
                </div>
            </div>
        `;
            })
            .join('');

        browserContent.innerHTML = `<div class="browser-list">${listHTML}</div>`;

        // When the tiny ZIP thumbnail loads, hide the fallback icon and keep row height unchanged
        try {
            const icons = browserContent.querySelectorAll('.browser-item-icon.has-thumb');
            icons.forEach(icon => {
                const img = icon.querySelector('img.pp-zip-thumb');
                const ico = icon.querySelector('i');
                if (!img) return;
                const onLoad = () => {
                    icon.classList.add('thumb-loaded');
                    if (ico) ico.style.display = 'none';
                };
                const onError = () => {
                    // Remove image and keep the default icon
                    if (img && img.parentNode) img.parentNode.removeChild(img);
                    icon.classList.remove('thumb-loaded');
                    icon.classList.remove('has-thumb');
                    if (ico) ico.style.display = '';
                };
                // If already complete (cache), apply immediately; else wait
                if (img.complete && img.naturalWidth > 0) onLoad();
                else {
                    img.addEventListener('load', onLoad, { once: true });
                    img.addEventListener('error', onError, { once: true });
                }
            });
        } catch (_) {
            /* zip thumb enhancement optional; ignore errors */
        }

        // Also update the Local header count by summing top-level directory itemCounts
        try {
            // Sum files-only counts for posters, backgrounds, motion, and complete
            const topDirs = new Map(dirs.map(d => [String(d.name).toLowerCase(), d]));
            const sumCount = name => Number(topDirs.get(name)?.itemCount || 0);
            const totalLocal =
                sumCount('posters') +
                sumCount('backgrounds') +
                sumCount('motion') +
                sumCount('complete');
            if (Number.isFinite(totalLocal)) {
                const tt = `Local items — posters+backgrounds+motion+complete: ${totalLocal.toLocaleString()}`;
                if (typeof window.setCount === 'function') {
                    window.setCount('local-count-pill', totalLocal, null, tt);
                } else {
                    const el = document.getElementById('local-count-pill');
                    if (el) {
                        el.textContent = `Items: ${totalLocal.toLocaleString()}`;
                        el.title = tt;
                    }
                }
            }
        } catch (_) {
            // non-fatal
        }

        // Single delegated click handler for selection and actions (attach once)
        if (!browserContent.__handlersAttached) {
            browserContent.__handlersAttached = true;
            browserContent.addEventListener('click', e => {
                // Handle item click (navigation/select) when not clicking on actions
                const itemEl = e.target.closest('.browser-item');
                if (itemEl && !e.target.closest('.browser-item-actions')) {
                    const p = itemEl.dataset.path;
                    const t = itemEl.dataset.type;
                    if (t === 'directory') loadDirectoryContents(p);
                    else toggleFileSelection(itemEl, p);
                    return;
                }

                // Action buttons
                const uploadHereBtn = e.target.closest('.btn-upload-here');
                const openFolderBtn = e.target.closest('.btn-open-folder');
                const deleteBtn = e.target.closest('.btn-delete');
                const downloadDirBtn = e.target.closest('.btn-download-all');
                const downloadFileBtn = e.target.closest('.btn-download-file');

                if (openFolderBtn) {
                    const p = openFolderBtn.dataset.path;
                    if (p) {
                        // Clear search input when navigating to a folder
                        const searchInput = document.getElementById('local-browser-search');
                        if (searchInput) searchInput.value = '';
                        loadDirectoryContents(p);
                    }
                } else if (uploadHereBtn) {
                    const name = (uploadHereBtn.dataset.name || '').toLowerCase();
                    // Map directory name to targetDirectory and input element
                    let target = 'posters';
                    let fi = document.getElementById('file-input-posters');
                    if (name === 'backgrounds') {
                        target = 'backgrounds';
                        fi = document.getElementById('file-input-backgrounds');
                    } else if (name === 'motion') {
                        target = 'motion';
                        fi = document.getElementById('file-input-motion');
                    } else if (name === 'posterpacks' || name === 'complete') {
                        target = 'complete';
                        fi = document.getElementById('file-input-packs');
                    }
                    // Use the same robust opening logic as per-directory buttons
                    const openFilePicker = (input, td) => {
                        if (!input) return;
                        if (input.__opening) return;
                        input.__opening = true;
                        try {
                            input.value = '';
                        } catch (_) {
                            /* refreshBadge on visibilitychange failed (ignored) */
                        }
                        const clearOpen = () => {
                            input.__opening = false;
                        };
                        const clearTimer = setTimeout(clearOpen, 1200);
                        const onChange = ev => {
                            clearTimeout(clearTimer);
                            input.__opening = false;
                            handleFileSelection(ev, td);
                            try {
                                input.value = '';
                            } catch (_) {
                                /* numeric wrapper width sm class add failed (cosmetic) */
                            }
                            input.removeEventListener('change', onChange);
                        };
                        input.addEventListener('change', onChange);
                        input.click();
                    };
                    openFilePicker(fi, target);
                } else if (downloadDirBtn) {
                    const p = downloadDirBtn.dataset.path;
                    if (p) {
                        const url = `/api/local/download-all?path=${encodeURIComponent(p)}`;
                        const dlg =
                            window.confirmAction ||
                            (opts =>
                                Promise.resolve(
                                    window.confirm(
                                        opts?.message || 'Download all files in this folder?'
                                    )
                                ));
                        dlg({
                            title: 'Download folder as ZIP',
                            message:
                                `This will bundle and download all files inside:<br><code>${p}</code><br><br>` +
                                `Large folders may take time to prepare. Continue?`,
                            okText: 'Download',
                            okClass: 'btn-confirm-accent',
                            okIcon: 'file-zipper',
                        }).then(ok => {
                            if (!ok) return;
                            window.location.href = url;
                        });
                    }
                } else if (downloadFileBtn) {
                    const p = downloadFileBtn.dataset.path;
                    if (p) {
                        const url = `/api/local/download?path=${encodeURIComponent(p)}`;
                        window.location.href = url;
                    }
                } else if (deleteBtn) {
                    const path = deleteBtn.dataset.path;
                    const itemEl = deleteBtn.closest('.browser-item');
                    const type = itemEl?.dataset?.type || 'file';
                    // Use themed confirm modal; customize message for directories
                    const message =
                        type === 'directory'
                            ? `This will remove all files and subfolders inside:<br><code>${path}</code><br><br><strong>The folder itself will be kept.</strong>`
                            : `This will permanently delete:<br><code>${path}</code>`;
                    const okText = type === 'directory' ? 'Delete contents' : 'Delete';
                    const okClass =
                        type === 'directory' ? 'btn-confirm-accent btn-danger-accent' : 'btn-error';
                    (window.confirmAction || (() => Promise.resolve(confirm('Are you sure?'))))({
                        title: type === 'directory' ? 'Delete folder contents' : 'Delete file',
                        message,
                        okText: okText,
                        okClass,
                        okIcon: 'trash',
                    }).then(ok => {
                        if (!ok) return;
                        deletePath(path, type);
                    });
                }
            });
        }
    }

    function updateBreadcrumb(path) {
        const breadcrumb = document.getElementById('local-breadcrumb');
        if (!breadcrumb) return;

        const parts = path.split('/').filter(Boolean);
        let currentPath = '';

        let html = `<button class="breadcrumb-item" data-path="/"><i class="fas fa-home"></i></button>`;

        parts.forEach(part => {
            currentPath += '/' + part;
            html += `<span>/</span><button class="breadcrumb-item" data-path="${currentPath}">${part}</button>`;
        });

        breadcrumb.innerHTML = html;

        // Add event delegation for breadcrumb navigation (attach once)
        if (!breadcrumb.__handlersAttached) {
            breadcrumb.__handlersAttached = true;
            breadcrumb.addEventListener('click', e => {
                const btn = e.target.closest('.breadcrumb-item');
                if (btn) {
                    const path = btn.dataset.path;
                    if (path) loadDirectoryContents(path);
                }
            });
        }
    }

    function toggleFileSelection(element, path) {
        if (selectedFiles.has(path)) {
            selectedFiles.delete(path);
            element.classList.remove('selected');
        } else {
            selectedFiles.add(path);
            element.classList.add('selected');
        }

        // No global delete-selected button in maintenance mode
        // Update Posterpack filters visibility when local file selection changes
        try {
            const sourceSelect = document.getElementById('posterpack.source');
            if (sourceSelect) handleSourceSelection({ target: sourceSelect });
        } catch (_) {
            /* posterpack visibility update is optional; ignore */
        }
    }

    function scanDirectory() {
        const enabledInput = document.getElementById('localDirectory.enabled');

        if (!enabledInput?.checked) {
            showNotification('Please enable local directory first', 'warning');
            return;
        }

        // Fixed media path in use; no additional path validation needed

        const scanBtn = document.getElementById('btn-local-scan');
        if (scanBtn) {
            scanBtn.disabled = true;
            scanBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
        }

        fetch('/api/local/scan', { method: 'POST' })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    showNotification('Directory scan completed', 'success');
                    // Update view while keeping handlers intact (force fresh)
                    refreshDirectorySafe(true);
                } else {
                    showNotification(result.message || 'Scan failed', 'error');
                }
            })
            .catch(error => {
                console.error('Scan error:', error);
                showNotification('Scan failed', 'error');
            })
            .finally(() => {
                if (scanBtn) {
                    scanBtn.disabled = false;
                    scanBtn.innerHTML = '<i class="fas fa-sync"></i>';
                }
            });
    }

    function generatePosterpack() {
        const generateBtn = document.getElementById('btn-generate-posterpack');
        if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
        }

        // Get posterpack configuration
        const source = document.getElementById('posterpack.source')?.value || 'plex';
        // Resolve selected library IDs for plex/jellyfin (from Posterpack section; empty = all)
        let libraryIds = [];
        if (source === 'plex') {
            const mvSel =
                typeof getMultiSelectValues === 'function'
                    ? getMultiSelectValues('pp-plex.movies')
                    : Array.from(
                          document.getElementById('pp-plex.movies')?.selectedOptions || []
                      ).map(o => o.value);
            const shSel =
                typeof getMultiSelectValues === 'function'
                    ? getMultiSelectValues('pp-plex.shows')
                    : Array.from(
                          document.getElementById('pp-plex.shows')?.selectedOptions || []
                      ).map(o => o.value);
            const map = window.__plexLibraryNameToId || new Map();
            const toIds = names =>
                (Array.isArray(names) ? names : []).map(n => map.get(n) || null).filter(Boolean);
            const chosen = [...mvSel, ...shSel];
            if (chosen.length) {
                libraryIds = toIds(chosen);
            } else {
                // Empty => include all known libraries
                const all = Array.from(map.keys());
                libraryIds = toIds(all);
            }
        } else if (source === 'jellyfin') {
            const mvSel =
                typeof getMultiSelectValues === 'function'
                    ? getMultiSelectValues('pp-jf.movies')
                    : Array.from(
                          document.getElementById('pp-jf.movies')?.selectedOptions || []
                      ).map(o => o.value);
            const shSel =
                typeof getMultiSelectValues === 'function'
                    ? getMultiSelectValues('pp-jf.shows')
                    : Array.from(document.getElementById('pp-jf.shows')?.selectedOptions || []).map(
                          o => o.value
                      );
            const map = window.__jfLibraryNameToId || new Map();
            const toIds = names =>
                (Array.isArray(names) ? names : []).map(n => map.get(n) || null).filter(Boolean);
            const chosen = [...mvSel, ...shSel];
            if (chosen.length) {
                libraryIds = toIds(chosen);
            } else {
                const all = Array.from(map.keys());
                libraryIds = toIds(all);
            }
        }

        const commonYearFilter = document.getElementById('posterpack.yearFilter')?.value || '';
        const config = {
            sourceType: source,
            libraryIds,
            options: {
                compression: 'balanced',
                yearFilter: commonYearFilter,
                // Build filter set from in-section controls; when empty, default to no narrowing
                filtersPlex: source === 'plex' ? getPosterpackFilterObject('plex') : undefined,
                filtersJellyfin:
                    source === 'jellyfin' ? getPosterpackFilterObject('jellyfin') : undefined,
            },
        };

        // Validate configuration
        if (
            (source === 'plex' || source === 'jellyfin') &&
            (!Array.isArray(libraryIds) || libraryIds.length === 0)
        ) {
            showNotification('Select one or more libraries first', 'warning');
            if (generateBtn) {
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<i class="fas fa-archive"></i> Generate Posterpack';
            }
            return;
        }

        fetch('/api/local/generate-posterpack', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(config),
        })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    const lbl = source || 'local';
                    showNotification(
                        `${lbl.charAt(0).toUpperCase() + lbl.slice(1)} posterpack generation started`,
                        'success'
                    );
                    startJobPolling(result.jobId);
                } else {
                    showNotification(result.message || 'Generation failed', 'error');
                }
            })
            .catch(error => {
                console.error('Generation error:', error);
                showNotification('Generation failed', 'error');
            })
            .finally(() => {
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = '<i class="fas fa-archive"></i> Generate Posterpack';
                }
            });
    }

    async function previewPosterpackSelection() {
        const source = document.getElementById('posterpack.source')?.value || 'plex';
        const yearFilter = document.getElementById('posterpack.yearFilter')?.value || '';

        // Resolve library IDs same as generate (Posterpack section picks; empty = all)
        let libraryIds = [];
        if (source === 'plex') {
            // Ensure Plex map is populated
            try {
                const ok =
                    window.__plexLibraryNameToId instanceof Map &&
                    window.__plexLibraryNameToId.size > 0;
                if (!ok && typeof fetchPlexLibraries === 'function') {
                    await Promise.resolve(fetchPlexLibraries(false, true)).catch(() => {});
                }
            } catch (_) {
                /* multiselect rebuild is optional */
            }
            const mvSel =
                typeof getMultiSelectValues === 'function'
                    ? getMultiSelectValues('pp-plex.movies')
                    : Array.from(
                          document.getElementById('pp-plex.movies')?.selectedOptions || []
                      ).map(o => o.value);
            const shSel =
                typeof getMultiSelectValues === 'function'
                    ? getMultiSelectValues('pp-plex.shows')
                    : Array.from(
                          document.getElementById('pp-plex.shows')?.selectedOptions || []
                      ).map(o => o.value);
            const map = window.__plexLibraryNameToId || new Map();
            const toIds = names =>
                (Array.isArray(names) ? names : []).map(n => map.get(n)).filter(Boolean);
            const chosen = [...mvSel, ...shSel];
            libraryIds = chosen.length
                ? toIds(chosen)
                : map.size
                  ? toIds(Array.from(map.keys()))
                  : [];
            // If mapping failed but we have names, fall back to using all known IDs
            if ((!libraryIds || libraryIds.length === 0) && map.size) {
                libraryIds = Array.from(map.values()).map(String);
            }
        } else if (source === 'jellyfin') {
            // Ensure Jellyfin map is populated
            try {
                const ok =
                    window.__jfLibraryNameToId instanceof Map &&
                    window.__jfLibraryNameToId.size > 0;
                if (!ok && typeof fetchJellyfinLibraries === 'function') {
                    await Promise.resolve(fetchJellyfinLibraries(false, true)).catch(() => {});
                }
            } catch (_) {
                /* jellyfin library map ensure optional; continue */
            }
            const mvSel =
                typeof getMultiSelectValues === 'function'
                    ? getMultiSelectValues('pp-jf.movies')
                    : Array.from(
                          document.getElementById('pp-jf.movies')?.selectedOptions || []
                      ).map(o => o.value);
            const shSel =
                typeof getMultiSelectValues === 'function'
                    ? getMultiSelectValues('pp-jf.shows')
                    : Array.from(document.getElementById('pp-jf.shows')?.selectedOptions || []).map(
                          o => o.value
                      );
            const map = window.__jfLibraryNameToId || new Map();
            const toIds = names =>
                (Array.isArray(names) ? names : []).map(n => map.get(n)).filter(Boolean);
            const chosen = [...mvSel, ...shSel];
            libraryIds = chosen.length
                ? toIds(chosen)
                : map.size
                  ? toIds(Array.from(map.keys()))
                  : [];
            if ((!libraryIds || libraryIds.length === 0) && map.size) {
                libraryIds = Array.from(map.values()).map(String);
            }
        }

        const config = {
            sourceType: source,
            libraryIds,
            options: {
                yearFilter,
                // No mediaType/limit for Plex/Jellyfin; server handles sensible defaults
                filtersPlex: source === 'plex' ? getPosterpackFilterObject('plex') : undefined,
                filtersJellyfin:
                    source === 'jellyfin' ? getPosterpackFilterObject('jellyfin') : undefined,
            },
        };

        fetch('/api/local/preview-posterpack', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(config),
        })
            .then(response => response.json())
            .then(result => {
                if (result?.summary) {
                    const total = Number(result.summary.totalItems) || 0;
                    const limFromServer = Number(result.summary.limit) || 10000;
                    const est =
                        Number(result.estimatedToGenerate) || Math.min(total, limFromServer);
                    const src = result.summary.sourceType || source;
                    const msg = `Preview (${src}): ${total.toLocaleString()} items available • estimated ${est.toLocaleString()} to generate`;
                    showNotification(msg, 'info');

                    // Optional: if there is a preview gallery element, render a tiny visual using thumbnails when available
                    try {
                        const previewHost = document.getElementById('posterpack-preview-thumbs');
                        if (previewHost && Array.isArray(result.exampleItems)) {
                            previewHost.innerHTML = '';
                            const sample = result.exampleItems.slice(0, 12);
                            for (const it of sample) {
                                const img = document.createElement('img');
                                img.loading = 'lazy';
                                img.decoding = 'async';
                                img.referrerPolicy = 'no-referrer';
                                img.alt = it.title || 'preview';
                                img.width = 64;
                                img.height = 96;
                                img.className = 'pp-thumb';
                                img.src = it.thumbnailUrl || it.posterUrl || it.backgroundUrl || '';
                                previewHost.appendChild(img);
                            }
                            previewHost.style.display = sample.length ? '' : 'none';
                        }
                    } catch (_) {
                        /* refreshBadge on pageshow failed (will run on next interval) */
                    }
                } else {
                    showNotification(result?.error || 'Preview failed', 'error');
                }
            })
            .catch(error => {
                console.error('Preview error:', error);
                showNotification('Preview failed', 'error');
            });
    }

    function handleSourceSelection(e) {
        const source = e.target.value;

        const filtersSection = document.getElementById('posterpack-filters');
        const srvFilters = document.getElementById('posterpack-filters-srv');
        const localFilters = document.getElementById('posterpack-filters-local');
        const libsSection = document.getElementById('posterpack-lib-section');
        const plexLibs = document.getElementById('pp-plex-libs');
        const jfLibs = document.getElementById('pp-jf-libs');

        if (filtersSection) {
            const isLocal = source === 'local';
            // Always show the filters section for any source now
            filtersSection.hidden = false;
            filtersSection.style.display = '';
            filtersSection.setAttribute('aria-hidden', 'false');

            if (srvFilters) {
                const showSrv = source === 'plex' || source === 'jellyfin';
                srvFilters.hidden = !showSrv;
                srvFilters.style.display = showSrv ? '' : 'none';
            }
            if (localFilters) {
                const showLocal = isLocal;
                localFilters.hidden = !showLocal;
                localFilters.style.display = showLocal ? '' : 'none';
                if (showLocal) {
                    try {
                        if (typeof initMsForSelect === 'function') {
                            initMsForSelect('pp-local-ms-ratings', 'pp-local.ratings');
                            initMsForSelect('pp-local-ms-genres', 'pp-local.genres');
                            initMsForSelect('pp-local-ms-qualities', 'pp-local.qualities');
                        }
                        loadLocalFilterOptions()
                            .then(() => {
                                if (typeof rebuildMsForSelect === 'function') {
                                    rebuildMsForSelect('pp-local-ms-ratings', 'pp-local.ratings');
                                    rebuildMsForSelect('pp-local-ms-genres', 'pp-local.genres');
                                    rebuildMsForSelect(
                                        'pp-local-ms-qualities',
                                        'pp-local.qualities'
                                    );
                                }
                            })
                            .catch(() => {
                                /* local filter options load best-effort; UI can proceed */
                            });
                    } catch (_) {
                        /* init local multiselects is cosmetic; continue */
                    }
                }
            }
        }
        const showLibs = source !== 'local';
        if (libsSection) {
            libsSection.hidden = !showLibs;
            libsSection.style.display = showLibs ? '' : 'none';
            libsSection.setAttribute('aria-hidden', showLibs ? 'false' : 'true');
        }
        const showPlex = source === 'plex';
        if (plexLibs) {
            plexLibs.hidden = !showPlex;
            plexLibs.style.display = showPlex ? '' : 'none';
            plexLibs.setAttribute('aria-hidden', showPlex ? 'false' : 'true');
        }
        const showJf = source === 'jellyfin';
        if (jfLibs) {
            jfLibs.hidden = !showJf;
            jfLibs.style.display = showJf ? '' : 'none';
            jfLibs.setAttribute('aria-hidden', showJf ? 'false' : 'true');
        }
        // Populate library lists lazily; the populate function will rebuild widgets after options are filled
        if (source === 'plex') {
            // Ensure widgets are initialized; actual rebuild occurs inside populate after options are written
            try {
                if (typeof initMsForSelect === 'function') {
                    initMsForSelect('pp-plex-ms-movies', 'pp-plex.movies');
                    initMsForSelect('pp-plex-ms-shows', 'pp-plex.shows');
                    initMsForSelect('pp-srv-ms-ratings', 'pp-server.ratings');
                    initMsForSelect('pp-srv-ms-genres', 'pp-server.genres');
                    initMsForSelect('pp-srv-ms-qualities', 'pp-server.qualities');
                }
            } catch (_) {
                /* init multiselects is optional */
            }
            // Ensure Qualities (entire form-group) is visible for Plex
            try {
                const qSel = document.getElementById('pp-server.qualities');
                const group = qSel?.closest('.form-group');
                if (group) {
                    group.hidden = false;
                    group.style.display = '';
                }
                const qRoot = document.getElementById('pp-srv-ms-qualities');
                if (qRoot) qRoot.classList.remove('disabled');
            } catch (_) {
                /* show qualities is cosmetic; ignore */
            }
            try {
                loadPosterpackServerFilterOptions().catch(() => {});
            } catch (_) {
                /* server filter options are optional; ignore */
            }
            // Proactively fetch Plex libraries using the main fetcher (reads config/inputs), then populate
            try {
                Promise.resolve(fetchPlexLibraries(false, true)).finally(() => {
                    try {
                        populatePosterpackLibraries('plex');
                    } catch (_) {
                        /* populate fallback failed; another retry will occur */
                    }
                });
            } catch (_) {
                populatePosterpackLibraries('plex');
            }
            // If still empty shortly after, copy from main selects as a last resort for instant UX
            setTimeout(() => {
                try {
                    const mvSel = document.getElementById('pp-plex.movies');
                    const shSel = document.getElementById('pp-plex.shows');

                    if (
                        mvSel &&
                        shSel &&
                        mvSel.options.length === 0 &&
                        shSel.options.length === 0
                    ) {
                        if (typeof populatePosterpackLibraries === 'function') {
                            // Call with internal copy fallback via kind detection
                            try {
                                populatePosterpackLibraries('plex');
                            } catch (_) {
                                /* last-resort populate is optional */
                            }
                        }
                    }
                } catch (_) {
                    /* dedupe nested number wrapper pass failed (benign) */
                }
            }, 350);
        } else if (source === 'jellyfin') {
            try {
                if (typeof initMsForSelect === 'function') {
                    initMsForSelect('pp-jf-ms-movies', 'pp-jf.movies');
                    initMsForSelect('pp-jf-ms-shows', 'pp-jf.shows');
                    initMsForSelect('pp-srv-ms-ratings', 'pp-server.ratings');
                    initMsForSelect('pp-srv-ms-genres', 'pp-server.genres');
                    // Do not wire Qualities for Jellyfin — feature not supported; hide it
                }
            } catch (_) {
                /* export dedupeNumberWrappers failed (diagnostic only) */
            }
            try {
                loadPosterpackServerFilterOptions().catch(() => {});
            } catch (_) {
                /* display preview summary interval update failed (visual only) */
            }
            // Hide and clear Qualities (entire form-group) when source is Jellyfin
            try {
                const qSel = document.getElementById('pp-server.qualities');
                const group = qSel?.closest('.form-group');
                if (group) {
                    group.hidden = true;
                    group.style.display = 'none';
                }
                const qRoot = document.getElementById('pp-srv-ms-qualities');
                if (qRoot) qRoot.classList.add('disabled');
                if (qSel) {
                    Array.from(qSel.options).forEach(o => (o.selected = false));
                    qSel.dispatchEvent(new Event('change', { bubbles: true }));
                }
            } catch (_) {
                /* jellyfin libs populate hide/clear qualities is cosmetic */
            }
            // Proactively fetch Jellyfin libraries using the main fetcher, then populate
            try {
                Promise.resolve(fetchJellyfinLibraries(false, true)).finally(() => {
                    try {
                        populatePosterpackLibraries('jellyfin');
                    } catch (_) {
                        /* preview update nudge failed (non-critical) */
                    }
                });
            } catch (_) {
                populatePosterpackLibraries('jellyfin');
            }
        }
    }

    // getLocalPosterpackFilters removed (Local source removed from Posterpack UI)

    async function loadLocalFilterOptions() {
        // Deduplicate concurrent loads but allow refreshing on each open
        if (window.__ppLocalFiltersInFlight) return window.__ppLocalFiltersInFlight;
        window.__ppLocalFiltersInFlight = (async () => {
            try {
                // Ensure Jellyfin libraries are known so we can query genres across all libs
                try {
                    const jfMapOk =
                        window.__jfLibraryNameToId instanceof Map &&
                        window.__jfLibraryNameToId.size > 0;
                    if (!jfMapOk && typeof fetchJellyfinLibraries === 'function') {
                        await Promise.resolve(fetchJellyfinLibraries(false, true)).catch(() => {});
                    }
                } catch (_) {
                    /* notif mutation observer install failed (manual refresh only) */
                }

                // Build Jellyfin movie/show library name arrays if available
                let jfMovieLibs = [];
                let jfShowLibs = [];
                try {
                    const counts =
                        window.__jfLibraryCounts instanceof Map ? window.__jfLibraryCounts : null;
                    const names =
                        window.__jfLibraryNameToId instanceof Map
                            ? Array.from(window.__jfLibraryNameToId.keys())
                            : [];
                    if (counts && counts.size) {
                        jfMovieLibs = names.filter(
                            n => (counts.get(n)?.type || '').toLowerCase() === 'movie'
                        );
                        jfShowLibs = names.filter(
                            n => (counts.get(n)?.type || '').toLowerCase() === 'show'
                        );
                    } else if (names.length) {
                        // If we can't distinguish, include all names in both so endpoint returns union
                        jfMovieLibs = names.slice();
                        jfShowLibs = names.slice();
                    }
                } catch (_) {
                    /* building jf movie/show lib name lists is optional */
                }

                // Prepare requests
                const plexRatingsReq = window
                    .dedupJSON('/api/sources/plex/ratings-with-counts', { credentials: 'include' })
                    .catch(() => null);
                const jfRatingsReq = window
                    .dedupJSON('/api/sources/jellyfin/ratings-with-counts', {
                        credentials: 'include',
                    })
                    .catch(() => null);
                const plexGenresReq = (async () => {
                    try {
                        const res = await window.dedupJSON('/api/admin/plex-genres-with-counts', {
                            credentials: 'include',
                        });
                        const data = res ? await res.json().catch(() => ({})) : {};
                        const arr = Array.isArray(data?.genres) ? data.genres : [];
                        if (arr.length) return data;
                        // Fallback: if user entered Plex connection params, try test endpoint to fetch genres-with-counts directly
                        const hostname = document.getElementById('plex.hostname')?.value;
                        const port = document.getElementById('plex.port')?.value;
                        const token = document.getElementById('plex.token')?.value || undefined;
                        if (hostname && port) {
                            const res2 = await fetch('/api/admin/plex-genres-with-counts-test', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                credentials: 'include',
                                body: JSON.stringify({ hostname, port, token }),
                            });
                            if (res2.ok) return await res2.json().catch(() => ({}));
                        }
                        // Last resort: plain genres list from any enabled Plex server
                        try {
                            const res3 = await window.dedupJSON('/api/admin/plex-genres', {
                                credentials: 'include',
                            });
                            if (res3?.ok) return await res3.json().catch(() => ({}));
                        } catch (_) {
                            /* plain plex genres fallback failed; continue */
                        }
                    } catch (_) {
                        /* preview update nudge failed (non-critical) */
                    }
                    return null;
                })();
                const jfGenresReq = (async () => {
                    try {
                        // If we have selected or discovered library names, try the precise with-counts endpoint first
                        if (jfMovieLibs.length || jfShowLibs.length) {
                            try {
                                const res = await fetch('/api/admin/jellyfin-genres-with-counts', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    credentials: 'include',
                                    body: JSON.stringify({
                                        movieLibraries: jfMovieLibs,
                                        showLibraries: jfShowLibs,
                                    }),
                                });
                                if (res.ok) {
                                    const js = await res.json().catch(() => ({}));
                                    if (Array.isArray(js?.genres) && js.genres.length) return js;
                                }
                            } catch (_) {
                                // fall through to all-libraries fallback
                            }
                        }
                        // Always attempt the all-libraries fallback so Local never ends up empty
                        try {
                            const r2 = await window.dedupJSON('/api/admin/jellyfin-genres-all', {
                                credentials: 'include',
                            });
                            if (r2?.ok) return await r2.json().catch(() => ({}));
                        } catch (_) {
                            /* jellyfin all-genres fallback failed; continue */
                        }
                        return null;
                    } catch (_) {
                        return null;
                    }
                })();
                const plexQualReq = window
                    .dedupJSON('/api/admin/plex-qualities-with-counts', { credentials: 'include' })
                    .catch(() => null);
                const jfQualReq = window
                    .dedupJSON('/api/admin/jellyfin-qualities-with-counts', {
                        credentials: 'include',
                    })
                    .catch(() => null);

                const [
                    plexRatingsRes,
                    jfRatingsRes,
                    plexGenresRes,
                    jfGenresRes,
                    plexQualRes,
                    jfQualRes,
                ] = await Promise.all([
                    plexRatingsReq,
                    jfRatingsReq,
                    plexGenresReq,
                    jfGenresReq,
                    plexQualReq,
                    jfQualReq,
                ]);

                const ratings = new Set();
                const qualities = new Set();
                const genres = new Set();

                const addRatings = res => {
                    const arr = Array.isArray(res?.data)
                        ? res.data
                        : Array.isArray(res?.ratings)
                          ? res.ratings
                          : [];
                    arr.forEach(r => {
                        const key = (r?.rating || r)?.toString().trim().toUpperCase();
                        if (key) ratings.add(key);
                    });
                };
                const addQuals = res => {
                    const arr = Array.isArray(res?.qualities) ? res.qualities : [];
                    arr.forEach(q => {
                        const key = (q?.quality || q)?.toString().trim();
                        if (key) qualities.add(key);
                    });
                };
                const addGenres = res => {
                    const arr = Array.isArray(res?.genres) ? res.genres : [];
                    arr.forEach(g => {
                        const name = (g?.genre || g?.name || g?.Title || g?.value || g)
                            ?.toString()
                            .trim();
                        if (name && name !== '[object Object]') genres.add(name);
                    });
                };

                addRatings(plexRatingsRes);
                addRatings(jfRatingsRes);
                addQuals(plexQualRes);
                addQuals(jfQualRes);
                addGenres(plexGenresRes);
                addGenres(jfGenresRes);

                // Fallbacks
                if (!ratings.size) {
                    [
                        'G',
                        'PG',
                        'PG-13',
                        'R',
                        'NC-17',
                        'NR',
                        'UNRATED',
                        'TV-Y',
                        'TV-Y7',
                        'TV-G',
                        'TV-PG',
                        'TV-14',
                        'TV-MA',
                    ].forEach(r => ratings.add(r));
                }
                if (!qualities.size) {
                    ['SD', '720p', '1080p', '4K'].forEach(q => qualities.add(q));
                }
                // No hardcoded fallback for genres to avoid noise; leave empty if none

                const fillSelect = (id, list) => {
                    const sel = document.getElementById(id);
                    if (!sel) return;
                    const prev = new Set(Array.from(sel.selectedOptions).map(o => o.value));
                    sel.innerHTML = '';
                    list.forEach(v => {
                        const opt = document.createElement('option');
                        opt.value = v;
                        opt.textContent = v;
                        if (prev.has(v)) opt.selected = true;
                        sel.appendChild(opt);
                    });
                };

                const ratingsList = Array.from(ratings).sort();
                const qualitiesOrder = ['SD', '720p', '1080p', '4K'];
                const qualitiesList = Array.from(qualities).sort((a, b) => {
                    const ia = qualitiesOrder.indexOf(a);
                    const ib = qualitiesOrder.indexOf(b);
                    if (ia !== -1 && ib !== -1) return ia - ib;
                    if (ia !== -1) return -1;
                    if (ib !== -1) return 1;
                    return a.localeCompare(b);
                });
                let genresList = Array.from(genres).sort((a, b) => a.localeCompare(b));
                if (!genresList.length) {
                    const DEFAULT_GENRES = [
                        'Action',
                        'Adventure',
                        'Animation',
                        'Comedy',
                        'Crime',
                        'Documentary',
                        'Drama',
                        'Family',
                        'Fantasy',
                        'History',
                        'Horror',
                        'Music',
                        'Mystery',
                        'Romance',
                        'Science Fiction',
                        'Thriller',
                        'War',
                        'Western',
                    ];
                    DEFAULT_GENRES.forEach(g => genres.add(g));
                    genresList = Array.from(genres).sort((a, b) => a.localeCompare(b));
                }

                fillSelect('pp-local.ratings', ratingsList);
                fillSelect('pp-local.qualities', qualitiesList);
                fillSelect('pp-local.genres', genresList);

                // Last-resort fallback: if Local Genres are still empty, mirror from Server filters after loading them
                try {
                    if (
                        !genresList.length &&
                        typeof loadPosterpackServerFilterOptions === 'function'
                    ) {
                        await Promise.resolve(loadPosterpackServerFilterOptions()).catch(() => {});
                        const srvGenresSel = document.getElementById('pp-server.genres');
                        if (srvGenresSel && srvGenresSel.options && srvGenresSel.options.length) {
                            const srvList = Array.from(srvGenresSel.options)
                                .map(o => o.value)
                                .filter(Boolean);
                            if (srvList.length) {
                                genresList = srvList.slice().sort((a, b) => a.localeCompare(b));
                                fillSelect('pp-local.genres', genresList);
                            }
                        }
                    }
                } catch (_) {
                    /* screensaver preset apply failed (user can set manually) */
                }

                // If the widgets are already wired, rebuild them to reflect new options
                try {
                    if (typeof rebuildMsForSelect === 'function') {
                        rebuildMsForSelect('pp-local-ms-ratings', 'pp-local.ratings');
                        rebuildMsForSelect('pp-local-ms-genres', 'pp-local.genres');
                        rebuildMsForSelect('pp-local-ms-qualities', 'pp-local.qualities');
                    }
                } catch (_) {
                    /* wallart preset apply failed (user can adjust) */
                }
            } catch (_) {
                /* posterpack local filters rebuild optional; ignore */
            }
        })();
        try {
            await window.__ppLocalFiltersInFlight;
        } catch (_) {
            /* awaiting local filters in-flight optional; ignore */
        }
        window.__ppLocalFiltersInFlight = null;
    }

    function populatePosterpackLibraries(kind) {
        // Reuse global maps if available; otherwise fetch via existing admin endpoints

        const copyFromMainIfEmpty = source => {
            try {
                if (source === 'plex') {
                    const mainMv = document.getElementById('plex.movies');
                    const mainSh = document.getElementById('plex.shows');
                    const mvNames = mainMv ? Array.from(mainMv.options).map(o => o.value) : [];
                    const shNames = mainSh ? Array.from(mainSh.options).map(o => o.value) : [];

                    if (mvNames.length || shNames.length) {
                        fill('pp-plex.movies', mvNames);
                        fill('pp-plex.shows', shNames);
                        return true;
                    }
                } else if (source === 'jellyfin') {
                    const mainMv = document.getElementById('jf.movies');
                    const mainSh = document.getElementById('jf.shows');
                    const mvNames = mainMv ? Array.from(mainMv.options).map(o => o.value) : [];
                    const shNames = mainSh ? Array.from(mainSh.options).map(o => o.value) : [];

                    if (mvNames.length || shNames.length) {
                        fill('pp-jf.movies', mvNames);
                        fill('pp-jf.shows', shNames);
                        return true;
                    }
                }
            } catch (_) {
                /* toast guard optional; ignore */
            }
            return false;
        };
        const toastNoLibsOnce = src => {
            try {
                const key = `__pp_no_libs_toast_${src}`;
                if (window[key]) return;
                window[key] = true;
                if (typeof showNotification === 'function') {
                    showNotification(
                        `No ${src} libraries found for Posterpack selection`,
                        'warning'
                    );
                }
            } catch (_) {
                /* rebuild multiselect optional; ignore */
            }
        };
        const fill = (selId, names) => {
            const sel = document.getElementById(selId);
            if (!sel) return;
            // Preserve previously selected values where possible
            const prevSelected = new Set(Array.from(sel.selectedOptions).map(o => o.value));
            sel.innerHTML = '';
            names.forEach(n => {
                const opt = document.createElement('option');
                opt.value = n;
                opt.textContent = n;
                if (prevSelected.has(n)) opt.selected = true;
                sel.appendChild(opt);
            });

            try {
                if (typeof rebuildMsForSelect === 'function') {
                    const map = {
                        'pp-plex.movies': 'pp-plex-ms-movies',
                        'pp-plex.shows': 'pp-plex-ms-shows',
                        'pp-jf.movies': 'pp-jf-ms-movies',
                        'pp-jf.shows': 'pp-jf-ms-shows',
                    };
                    const msId = map[selId];
                    if (msId) rebuildMsForSelect(msId, selId);
                }
            } catch (_) {
                /* rebuild multiselect for select optional */
            }
        };
        const fetchAndFillPlex = async () => {
            try {
                const { map, libs } = await (async () => {
                    if (
                        window.__plexLibraryNameToId instanceof Map &&
                        window.__plexLibraryNameToId.size
                    )
                        return { map: window.__plexLibraryNameToId, libs: null };

                    // Get connection details (same logic as fetchPlexLibraries)
                    const hostname =
                        document.getElementById('plex.hostname')?.value ||
                        document.getElementById('plex_hostname')?.value ||
                        undefined;
                    const port =
                        document.getElementById('plex.port')?.value ||
                        document.getElementById('plex_port')?.value ||
                        undefined;
                    // Get token from: 1) dataset, 2) input value, 3) global token store, 4) undefined
                    const tokenInput =
                        document.getElementById('plex.token') ||
                        document.getElementById('plex_token');
                    const token =
                        tokenInput?.dataset?.actualToken ||
                        tokenInput?.value ||
                        window.__tokenStore?.plexToken ||
                        undefined;

                    const r = await fetch('/api/admin/plex-libraries', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ hostname, port, token }),
                    });
                    const j = r.ok ? await r.json().catch(() => ({})) : {};
                    const libs = Array.isArray(j.libraries) ? j.libraries : [];
                    const m = new Map();
                    libs.forEach(l => m.set(l.name, l.id || l.key));
                    window.__plexLibraryNameToId = m;
                    // also store counts/types for separation if not present
                    if (!(window.__plexLibraryCounts instanceof Map)) {
                        window.__plexLibraryCounts = new Map();
                        libs.forEach(l => {
                            if (l && l.name)
                                window.__plexLibraryCounts.set(l.name, {
                                    itemCount: Number(l.itemCount) || 0,
                                    type: l.type,
                                });
                        });
                    }
                    return { map: m, libs };
                })();
                const counts =
                    window.__plexLibraryCounts instanceof Map ? window.__plexLibraryCounts : null;
                const allNames = Array.from(map.keys()).sort((a, b) => a.localeCompare(b));

                // If still empty, try the main fetcher as a fallback and retry using global maps
                if (!allNames.length) {
                    try {
                        await Promise.resolve(fetchPlexLibraries(false, true));
                        const m2 =
                            window.__plexLibraryNameToId instanceof Map
                                ? window.__plexLibraryNameToId
                                : new Map();
                        const c2 =
                            window.__plexLibraryCounts instanceof Map
                                ? window.__plexLibraryCounts
                                : null;
                        const names2 = Array.from(m2.keys()).sort((a, b) => a.localeCompare(b));

                        if (c2 && c2.size) {
                            const movieNames2 = names2.filter(
                                n => (c2.get(n)?.type || '').toLowerCase() === 'movie'
                            );
                            const showNames2 = names2.filter(
                                n => (c2.get(n)?.type || '').toLowerCase() === 'show'
                            );
                            fill('pp-plex.movies', movieNames2);
                            fill('pp-plex.shows', showNames2);
                        } else {
                            fill('pp-plex.movies', names2);
                            fill('pp-plex.shows', names2);
                        }
                        return;
                    } catch (_) {
                        /* plex libs main fetch fallback failed; continue */
                    }
                }
                if (counts && counts.size) {
                    const movieNames = allNames.filter(
                        n => (counts.get(n)?.type || '').toLowerCase() === 'movie'
                    );
                    const showNames = allNames.filter(
                        n => (counts.get(n)?.type || '').toLowerCase() === 'show'
                    );

                    fill('pp-plex.movies', movieNames);
                    fill('pp-plex.shows', showNames);
                } else if (Array.isArray(libs) && libs.length) {
                    const movieNames = libs
                        .filter(l => (l.type || '').toLowerCase() === 'movie')
                        .map(l => l.name)
                        .sort((a, b) => a.localeCompare(b));
                    const showNames = libs
                        .filter(l => (l.type || '').toLowerCase() === 'show')
                        .map(l => l.name)
                        .sort((a, b) => a.localeCompare(b));

                    fill('pp-plex.movies', movieNames);
                    fill('pp-plex.shows', showNames);
                } else if (!copyFromMainIfEmpty('plex')) {
                    // As last resort, toast instead of mixing all into both lists
                    toastNoLibsOnce('Plex');
                }
            } catch (_) {
                /* plex fetch-and-fill is best-effort */
            }
        };
        const fetchAndFillJf = async () => {
            try {
                const { map, libs } = await (async () => {
                    if (
                        window.__jfLibraryNameToId instanceof Map &&
                        window.__jfLibraryNameToId.size
                    )
                        return { map: window.__jfLibraryNameToId, libs: null };
                    const r = await fetch('/api/admin/jellyfin-libraries', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({}),
                    });
                    const j = r.ok ? await r.json().catch(() => ({})) : {};
                    const libs = Array.isArray(j.libraries) ? j.libraries : [];
                    const m = new Map();
                    libs.forEach(l => m.set(l.name, l.id || l.key));
                    window.__jfLibraryNameToId = m;
                    if (!(window.__jfLibraryCounts instanceof Map)) {
                        window.__jfLibraryCounts = new Map();
                        libs.forEach(l => {
                            if (l && l.name) {
                                window.__jfLibraryCounts.set(l.name, {
                                    itemCount: Number(l.itemCount) || 0,
                                    type: l.type,
                                });
                            }
                        });
                    }
                    return { map: m, libs };
                })();
                const counts =
                    window.__jfLibraryCounts instanceof Map ? window.__jfLibraryCounts : null;
                const allNames = Array.from(map.keys()).sort((a, b) => a.localeCompare(b));

                // If still empty, try the main fetcher as a fallback and retry using global maps
                if (!allNames.length) {
                    try {
                        await Promise.resolve(fetchJellyfinLibraries(false, true));
                        const m2 =
                            window.__jfLibraryNameToId instanceof Map
                                ? window.__jfLibraryNameToId
                                : new Map();
                        const c2 =
                            window.__jfLibraryCounts instanceof Map
                                ? window.__jfLibraryCounts
                                : null;
                        const names2 = Array.from(m2.keys()).sort((a, b) => a.localeCompare(b));

                        if (c2 && c2.size) {
                            const movieNames2 = names2.filter(
                                n => (c2.get(n)?.type || '').toLowerCase() === 'movie'
                            );
                            const showNames2 = names2.filter(
                                n => (c2.get(n)?.type || '').toLowerCase() === 'show'
                            );
                            fill('pp-jf.movies', movieNames2);
                            fill('pp-jf.shows', showNames2);
                        } else {
                            fill('pp-jf.movies', names2);
                            fill('pp-jf.shows', names2);
                        }
                        return;
                    } catch (_) {
                        /* build jf lib name arrays best-effort; continue */
                    }
                }
                if (counts && counts.size) {
                    const movieNames = allNames.filter(
                        n => (counts.get(n)?.type || '').toLowerCase() === 'movie'
                    );
                    const showNames = allNames.filter(
                        n => (counts.get(n)?.type || '').toLowerCase() === 'show'
                    );

                    fill('pp-jf.movies', movieNames);
                    fill('pp-jf.shows', showNames);
                } else if (Array.isArray(libs) && libs.length) {
                    const movieNames = libs
                        .filter(l => l.type === 'movie')
                        .map(l => l.name)
                        .sort((a, b) => a.localeCompare(b));
                    const showNames = libs
                        .filter(l => l.type === 'show')
                        .map(l => l.name)
                        .sort((a, b) => a.localeCompare(b));

                    fill('pp-jf.movies', movieNames);
                    fill('pp-jf.shows', showNames);
                } else {
                    if (allNames.length) {
                        fill('pp-jf.movies', allNames);
                        fill('pp-jf.shows', allNames);
                    } else if (!copyFromMainIfEmpty('jellyfin')) {
                        toastNoLibsOnce('Jellyfin');
                    }
                }
            } catch (_) {
                /* jellyfin fetch-and-fill is best-effort */
            }
        };
        if (kind === 'plex') fetchAndFillPlex();
        else if (kind === 'jellyfin') fetchAndFillJf();
    }

    function getPosterpackFilterObject(kind) {
        // Read from Posterpack section inputs; empty fields mean no narrowing.
        // Server posterpack filters now use multiselects (hidden selects) mirroring Plex/JF style.
        const read = id => (document.getElementById(id)?.value || '').trim();
        const bool = id => !!document.getElementById(id)?.checked;
        const msValues = id => {
            const sel = document.getElementById(id);
            if (!sel) return '';
            const vals = Array.from(sel.selectedOptions)
                .map(o => o.value)
                .filter(Boolean);
            return vals.join(',');
        };
        const obj = {
            years: read('posterpack.yearFilter'),
            genres: msValues('pp-server.genres'),
            ratings: msValues('pp-server.ratings'),
            qualities: msValues('pp-server.qualities'),
            recentOnly: bool('pp.filters.recentOnly'),
            recentDays: Number(read('pp.filters.recentDays')) || 0,
        };
        const isEmpty =
            !obj.years && !obj.genres && !obj.ratings && !obj.qualities && !obj.recentOnly;
        if (isEmpty) {
            // Fallback to current main panel filters if posterpack section is empty
            const readHidden = id => (document.getElementById(id)?.value || '').trim();
            if (kind === 'plex') {
                return {
                    years: (document.getElementById('plex.yearFilter')?.value || '').trim(),
                    genres: readHidden('plex.genreFilter-hidden'),
                    ratings: readHidden('plex.ratingFilter-hidden'),
                    qualities: readHidden('plex.qualityFilter-hidden'),
                    recentOnly: !!document.getElementById('plex.recentOnlyHeader')?.checked,
                    recentDays: Number(document.getElementById('plex.recentDays')?.value) || 0,
                };
            }
            if (kind === 'jellyfin') {
                return {
                    years: (document.getElementById('jf.yearFilter')?.value || '').trim(),
                    genres: readHidden('jf.genreFilter-hidden'),
                    ratings: readHidden('jf.ratingFilter-hidden'),
                    qualities: readHidden('jf.qualityFilter-hidden'),
                    recentOnly: !!document.getElementById('jf.recentOnlyHeader')?.checked,
                    recentDays: Number(document.getElementById('jf.recentDays')?.value) || 0,
                };
            }
        }
        // For Jellyfin qualities are ignored server-side; OK to pass through
        return obj;
    }

    // Populate posterpack server multiselect filter options (ratings/genres/qualities)
    async function loadPosterpackServerFilterOptions() {
        if (window.__ppSrvFiltersInFlight) return window.__ppSrvFiltersInFlight;
        window.__ppSrvFiltersInFlight = (async () => {
            try {
                // Ensure Jellyfin libs are known for genres
                try {
                    const jfMapOk =
                        window.__jfLibraryNameToId instanceof Map &&
                        window.__jfLibraryNameToId.size > 0;
                    if (!jfMapOk && typeof fetchJellyfinLibraries === 'function') {
                        await Promise.resolve(fetchJellyfinLibraries(false, true)).catch(() => {});
                    }
                } catch (_) {
                    /* jellyfin fetch-and-fill is best-effort */
                }

                // Gather selected Posterpack Jellyfin libraries if available, else fallback to discovered/all
                const readSelected = id =>
                    Array.from(document.getElementById(id)?.selectedOptions || []).map(
                        o => o.value
                    );
                let jfMovieLibs = readSelected('pp-jf.movies');
                let jfShowLibs = readSelected('pp-jf.shows');
                if (jfMovieLibs.length === 0 && jfShowLibs.length === 0) {
                    try {
                        const counts =
                            window.__jfLibraryCounts instanceof Map
                                ? window.__jfLibraryCounts
                                : null;
                        const names =
                            window.__jfLibraryNameToId instanceof Map
                                ? Array.from(window.__jfLibraryNameToId.keys())
                                : [];
                        if (counts && counts.size) {
                            jfMovieLibs = names.filter(
                                n => (counts.get(n)?.type || '').toLowerCase() === 'movie'
                            );
                            jfShowLibs = names.filter(
                                n => (counts.get(n)?.type || '').toLowerCase() === 'show'
                            );
                        } else {
                            jfMovieLibs = names.slice();
                            jfShowLibs = names.slice();
                        }
                    } catch (_) {
                        /* jellyfin all-genres GET fallback failed; continue */
                    }
                }

                const plexRatingsReq = window
                    .dedupJSON('/api/sources/plex/ratings-with-counts', { credentials: 'include' })
                    .catch(() => null);
                const jfRatingsReq = window
                    .dedupJSON('/api/sources/jellyfin/ratings-with-counts', {
                        credentials: 'include',
                    })
                    .catch(() => null);
                const plexGenresReq = (async () => {
                    try {
                        const res = await window.dedupJSON('/api/admin/plex-genres-with-counts', {
                            credentials: 'include',
                        });
                        const data = res ? await res.json().catch(() => ({})) : {};
                        const arr = Array.isArray(data?.genres) ? data.genres : [];
                        if (arr.length) return data;
                        const hostname = document.getElementById('plex.hostname')?.value;
                        const port = document.getElementById('plex.port')?.value;
                        const token = document.getElementById('plex.token')?.value || undefined;
                        if (hostname && port) {
                            const res2 = await fetch('/api/admin/plex-genres-with-counts-test', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                credentials: 'include',
                                body: JSON.stringify({ hostname, port, token }),
                            });
                            if (res2.ok) return await res2.json().catch(() => ({}));
                        }
                        // Last resort: plain genres list from any enabled Plex server
                        try {
                            const res3 = await window.dedupJSON('/api/admin/plex-genres', {
                                credentials: 'include',
                            });
                            if (res3?.ok) return await res3.json().catch(() => ({}));
                        } catch (_) {
                            /* refreshBadge delayed after mark-all failed (will retry later) */
                        }
                    } catch (_) {
                        /* periodic badgeTick refresh failed (will retry) */
                    }
                    return null;
                })();
                const jfGenresReq = (async () => {
                    try {
                        if (jfMovieLibs.length || jfShowLibs.length) {
                            try {
                                const res = await fetch('/api/admin/jellyfin-genres-with-counts', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    credentials: 'include',
                                    body: JSON.stringify({
                                        movieLibraries: jfMovieLibs,
                                        showLibraries: jfShowLibs,
                                    }),
                                });
                                if (res.ok) {
                                    const js = await res.json().catch(() => ({}));
                                    if (Array.isArray(js?.genres) && js.genres.length) return js;
                                }
                            } catch (_) {
                                /* frequent open-panel refresh failed (next interval will retry) */
                            }
                        }
                        // Fallback: try all-libraries GET to avoid empty genres
                        try {
                            const r2 = await window.dedupJSON('/api/admin/jellyfin-genres-all', {
                                credentials: 'include',
                            });
                            if (r2?.ok) return await r2.json().catch(() => ({}));
                        } catch (_) {
                            /* plain plex genres fallback failed; continue */
                        }
                        return null;
                    } catch (_) {
                        return null;
                    }
                })();
                const plexQualReq = window
                    .dedupJSON('/api/admin/plex-qualities-with-counts', { credentials: 'include' })
                    .catch(() => null);
                const jfQualReq = window
                    .dedupJSON('/api/admin/jellyfin-qualities-with-counts', {
                        credentials: 'include',
                    })
                    .catch(() => null);

                const [plexRatings, jfRatings, plexGenres, jfGenres, plexQual, jfQual] =
                    await Promise.all([
                        plexRatingsReq,
                        jfRatingsReq,
                        plexGenresReq,
                        jfGenresReq,
                        plexQualReq,
                        jfQualReq,
                    ]);

                const ratings = new Set();
                const genres = new Set();
                const qualities = new Set();
                const addRatings = res => {
                    const arr = Array.isArray(res?.data)
                        ? res.data
                        : Array.isArray(res?.ratings)
                          ? res.ratings
                          : [];
                    arr.forEach(r => {
                        const s = (r?.rating || r)?.toString().trim().toUpperCase();
                        if (s) ratings.add(s);
                    });
                };
                const addQuals = res => {
                    const arr = Array.isArray(res?.qualities) ? res.qualities : [];
                    arr.forEach(q => {
                        const s = (q?.quality || q)?.toString().trim();
                        if (s) qualities.add(s);
                    });
                };
                const addGenres = res => {
                    const arr = Array.isArray(res?.genres) ? res.genres : [];
                    arr.forEach(g => {
                        const s = (g?.genre || g?.name || g?.Title || g?.value || g)
                            ?.toString()
                            .trim();
                        if (s && s !== '[object Object]') genres.add(s);
                    });
                };
                addRatings(plexRatings);
                addRatings(jfRatings);
                addQuals(plexQual);
                addQuals(jfQual);
                addGenres(plexGenres);
                addGenres(jfGenres);

                if (!ratings.size)
                    [
                        'G',
                        'PG',
                        'PG-13',
                        'R',
                        'NC-17',
                        'NR',
                        'UNRATED',
                        'TV-Y',
                        'TV-Y7',
                        'TV-G',
                        'TV-PG',
                        'TV-14',
                        'TV-MA',
                    ].forEach(r => ratings.add(r));
                if (!qualities.size) ['SD', '720p', '1080p', '4K'].forEach(q => qualities.add(q));

                const fill = (id, list) => {
                    const sel = document.getElementById(id);
                    if (!sel) return;
                    const prev = new Set(Array.from(sel.selectedOptions).map(o => o.value));
                    sel.innerHTML = '';
                    list.forEach(v => {
                        const opt = document.createElement('option');
                        opt.value = v;
                        opt.textContent = v;
                        if (prev.has(v)) opt.selected = true;
                        sel.appendChild(opt);
                    });
                };
                const ratingsList = Array.from(ratings).sort();
                const qualitiesOrder = ['SD', '720p', '1080p', '4K'];
                const qualitiesList = Array.from(qualities).sort((a, b) => {
                    const ia = qualitiesOrder.indexOf(a);
                    const ib = qualitiesOrder.indexOf(b);
                    if (ia !== -1 && ib !== -1) return ia - ib;
                    if (ia !== -1) return -1;
                    if (ib !== -1) return 1;
                    return a.localeCompare(b);
                });
                let genresList = Array.from(genres).sort((a, b) => a.localeCompare(b));
                if (!genresList.length) {
                    const DEFAULT_GENRES = [
                        'Action',
                        'Adventure',
                        'Animation',
                        'Comedy',
                        'Crime',
                        'Documentary',
                        'Drama',
                        'Family',
                        'Fantasy',
                        'History',
                        'Horror',
                        'Music',
                        'Mystery',
                        'Romance',
                        'Science Fiction',
                        'Thriller',
                        'War',
                        'Western',
                    ];
                    DEFAULT_GENRES.forEach(g => genres.add(g));
                    genresList = Array.from(genres).sort((a, b) => a.localeCompare(b));
                }

                fill('pp-server.ratings', ratingsList);
                fill('pp-server.genres', genresList);
                fill('pp-server.qualities', qualitiesList);

                if (typeof rebuildMsForSelect === 'function') {
                    rebuildMsForSelect('pp-srv-ms-ratings', 'pp-server.ratings');
                    rebuildMsForSelect('pp-srv-ms-genres', 'pp-server.genres');
                    rebuildMsForSelect('pp-srv-ms-qualities', 'pp-server.qualities');
                }
            } catch (_) {
                /* initial refreshBadge prime failed (will retry shortly) */
            }
        })();
        try {
            await window.__ppSrvFiltersInFlight;
        } catch (_) {
            /* refreshBadge(true) on online failed (network unstable) */
        }
        window.__ppSrvFiltersInFlight = null;
    }

    function startJobPolling(jobId) {
        let progressToast = null;
        const interval = setInterval(() => {
            fetch(`/api/local/jobs/${jobId}`)
                .then(response => response.json())
                .then(result => {
                    // Server returns the job object directly. Support legacy wrappers too.
                    const job = result?.job || result;
                    if (!job || !job.status) return;
                    updateJobDisplay(job);

                    // Keep Directory Contents fresh while work is running
                    if (job.status === 'running') {
                        startRealtimeDirectoryRefresh();
                    }

                    // Create or update a persistent progress toast
                    if (job.status === 'running') {
                        const pct = Number(job.progress) || 0;
                        const done = Number(job.processedItems) || 0;
                        const total = Number(job.totalItems) || 0;
                        const suffix = total ? ` (${done}/${total})` : '';
                        const msg = `Generating posterpacks… ${pct}%${suffix}`;
                        if (!progressToast) {
                            progressToast = window.notify?.toast({
                                type: 'info',
                                title: 'Working',
                                message: msg,
                                duration: 0,
                            });
                        } else if (progressToast.element) {
                            const m = progressToast.element.querySelector('.toast-message');
                            if (m) m.textContent = msg;
                        }
                    }

                    if (job.status === 'completed' || job.status === 'failed') {
                        clearInterval(interval);
                        stopRealtimeDirectoryRefresh();
                        // One last refresh so sizes reflect final state (force bypass cache)
                        refreshDirectorySafe(true);
                        if (progressToast?.dismiss) progressToast.dismiss();
                        const ok = job.status === 'completed';
                        const title = ok ? 'Posterpack ready' : 'Posterpack failed';
                        const count = job?.results?.totalGenerated;
                        const totalMsg =
                            typeof count === 'number'
                                ? ` (${count} file${count === 1 ? '' : 's'})`
                                : '';
                        const exportHint = (() => {
                            try {
                                const src = job.sourceType || 'plex';
                                return `Open “complete/${src}-export” in Directory Contents to download.`;
                            } catch (_) {
                                return '';
                            }
                        })();
                        window.notify?.toast({
                            type: ok ? 'success' : 'error',
                            title,
                            message: ok
                                ? `Generation finished${totalMsg}. ${exportHint}`
                                : job.error || 'See logs for details',
                            duration: ok ? 6000 : 7000,
                        });
                    }
                })
                .catch(error => {
                    console.error('Job status error:', error);
                    clearInterval(interval);
                    if (progressToast?.dismiss) progressToast.dismiss();
                });
        }, 1000);
    }
    // Generated Packs UI removed; downloads are available directly in the Directory browser

    function updateJobDisplay(job) {
        const jobsList = document.getElementById('local-job-list');
        if (!jobsList) return;

        let jobElement = jobsList.querySelector(`[data-job-id="${job.id}"]`);
        if (!jobElement) {
            jobElement = document.createElement('div');
            jobElement.className = 'job-item';
            jobElement.dataset.jobId = job.id;
            jobsList.appendChild(jobElement);
        }

        const totalOk = Number(job?.results?.totalGenerated || 0);
        const totalErr = Number(job?.results?.totalFailed || 0);
        const totalsStr = totalOk + totalErr > 0 ? `${totalOk} ok • ${totalErr} failed` : '';
        const exportDir = (() => {
            try {
                const src = job.sourceType || 'plex';
                return `complete/${src}-export`;
            } catch (_) {
                return '';
            }
        })();

        jobElement.innerHTML = `
            <div class="job-header">
                <div class="job-title">${job.type || 'Unknown Job'}</div>
                <div class="job-status ${job.status}">${job.status.toUpperCase()}</div>
            </div>
            ${
                job.progress !== undefined
                    ? `
                <div class="job-progress">
                    <div class="job-progress-bar">
                        <div class="job-progress-fill" style="width: ${job.progress}%"></div>
                    </div>
                </div>
            `
                    : ''
            }
            <div class="job-details">
                ${
                    job.status === 'completed'
                        ? totalsStr || 'Completed'
                        : job.message || 'No details available'
                }
                ${
                    job.status === 'completed'
                        ? `<span class="status-pill" style="margin-left:8px"><i class="fas fa-folder"></i> ${exportDir}</span>`
                        : ''
                }
                ${job.downloadUrl ? `<a href="${job.downloadUrl}" class="btn btn-outline btn-sm" style="margin-left: 10px;"><i class="fas fa-download"></i> Download</a>` : ''}
            </div>
        `;

        // Show jobs section if hidden
        const jobsSection = document.getElementById('local-jobs-section');
        if (jobsSection && jobsSection.hidden) {
            jobsSection.hidden = false;
        }
    }

    function loadLocalDirectoryConfig() {
        fetch('/api/admin/config', { credentials: 'include' })
            .then(response => response.json())
            .then(data => {
                const config = data && (data.config || data);
                if (config && config.localDirectory) {
                    const cfg = config.localDirectory;

                    // Update form fields
                    const pathInput = document.getElementById('localDirectory.rootPath');
                    if (pathInput) {
                        const fixed = (cfg.rootPath && cfg.rootPath.trim()) || 'media';
                        pathInput.value = fixed;
                        pathInput.readOnly = true;
                        pathInput.classList.add('input-readonly');
                        const grid = document.getElementById('local-dir-config');
                        if (grid) grid.hidden = true;
                    }

                    const watchInput = document.getElementById('localDirectory.watchDirectories');
                    if (watchInput) {
                        watchInput.checked = true;
                        const grp = watchInput.closest('.form-group');
                        if (grp) grp.style.display = 'none';
                    }

                    const enabledInput = document.getElementById('localDirectory.enabled');
                    if (enabledInput) {
                        enabledInput.checked = cfg.enabled || false;
                        // Store original enabled state for Save & Restart logic
                        enabledInput.dataset.originalEnabled = enabledInput.checked
                            ? 'true'
                            : 'false';
                        // Ensure label reflects clean state
                        try {
                            // eslint-disable-next-line no-undef
                            updateSourceSaveButtonLabel('local');
                        } catch (_) {
                            /* refreshBadge on focus failed (ignored) */
                        }
                        // Wire label updater once
                        try {
                            if (enabledInput && enabledInput.dataset.restartWired !== 'true') {
                                enabledInput.addEventListener('change', () =>
                                    // eslint-disable-next-line no-undef
                                    updateSourceSaveButtonLabel('local')
                                );
                                enabledInput.dataset.restartWired = 'true';
                            }
                        } catch (_) {
                            /* notify center event listener binding failed (degrades gracefully) */
                        }
                    }

                    // Update status pill (match Plex/Jellyfin styling)
                    const statusPill = document.getElementById('local-status-pill-header');
                    if (statusPill) {
                        const isConfigured = !!(cfg.enabled && cfg.rootPath);
                        statusPill.textContent = isConfigured ? 'Configured' : 'Not configured';
                        statusPill.classList.remove(
                            'status-success',
                            'status-warning',
                            'status-error',
                            'is-configured',
                            'is-not-configured',
                            'sp-success',
                            'sp-disabled'
                        );
                        if (isConfigured) {
                            statusPill.classList.add('status-success', 'is-configured');
                        } else {
                            statusPill.classList.add('is-not-configured');
                        }
                    }

                    // Toggle Directory Browser visibility based on enabled flag
                    const browser = document.getElementById('local-browser');
                    const refreshBtn = document.getElementById('btn-refresh-browser');
                    const dlBtn = document.getElementById('btn-download-dir');
                    // Always show the browser, regardless of Local enabled state
                    if (browser) browser.hidden = false;
                    if (refreshBtn) refreshBtn.disabled = false;
                    if (dlBtn) dlBtn.disabled = false;
                    // Load directory listing (will show meaningful error if misconfigured)
                    loadDirectoryContents('/');
                }

                // Load posterpack defaults
                const sourceSelect = document.getElementById('posterpack.source');
                if (sourceSelect && sourceSelect.value === 'local') {
                    handleSourceSelection({ target: sourceSelect });
                }
            })
            .catch(error => {
                console.error('Config load error:', error);
            });
    }

    async function saveLocalDirectorySettings() {
        const saveBtn = document.getElementById('btn-save-local');
        if (saveBtn) {
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
        }

        const config = {
            localDirectory: {
                enabled: document.getElementById('localDirectory.enabled')?.checked || false,
                rootPath: 'media',
                // Schema requires an array of absolute paths; UI currently doesn't expose inputs,
                // so send an empty array to satisfy validation.
                watchDirectories: [],
            },
        };

        const saveHelper = resolveSaveConfigHelper();
        if (!saveHelper) {
            showNotification('Save helper not ready. Please reload and try again.', 'error');
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="fas fa-save"></i><span>Save Settings</span>';
            }
            return;
        }

        const enabledInput = document.getElementById('localDirectory.enabled');
        // Prefer persisted config for baseline; fallback to dataset only if config is unavailable
        let originalEnabled;
        try {
            const cfgRes = await window.dedupJSON('/api/admin/config', {
                credentials: 'include',
            });
            const base = cfgRes.ok ? await cfgRes.json() : {};
            const currentCfg = base?.config || base || {};
            if (
                currentCfg &&
                currentCfg.localDirectory &&
                typeof currentCfg.localDirectory.enabled === 'boolean'
            ) {
                originalEnabled = !!currentCfg.localDirectory.enabled;
            } else {
                originalEnabled =
                    enabledInput?.dataset?.originalEnabled === 'true'
                        ? true
                        : enabledInput?.dataset?.originalEnabled === 'false'
                          ? false
                          : undefined;
            }
        } catch (_) {
            originalEnabled =
                enabledInput?.dataset?.originalEnabled === 'true'
                    ? true
                    : enabledInput?.dataset?.originalEnabled === 'false'
                      ? false
                      : undefined;
        }
        try {
            await saveHelper(config, {});
            showNotification('Local directory settings saved', 'success');
            loadLocalDirectoryConfig();
            // Restart if enabled state changed
            try {
                const currEnabled = !!config.localDirectory.enabled;
                const changed =
                    typeof originalEnabled === 'boolean' ? originalEnabled !== currEnabled : true; // if unknown, treat as changed to ensure restart
                const needsRestart = changed || saveBtn?.dataset?.restartRequired === 'true';

                if (enabledInput)
                    enabledInput.dataset.originalEnabled = currEnabled ? 'true' : 'false';
                if (needsRestart) {
                    const span = saveBtn?.querySelector('span');
                    if (span) span.textContent = 'Save Settings & Restart';
                    saveBtn && (saveBtn.dataset.restartRequired = 'true');
                    await window.triggerRestartAndPoll();
                }
            } catch (_) {
                /* restart trigger optional; ignore if helper unavailable */
            }
        } catch (error) {
            console.error('Save error:', error);
            showNotification(error?.message || 'Save failed', 'error');
        } finally {
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="fas fa-save"></i><span>Save Settings</span>';
            }
        }
    }

    // Path modal disabled: fixed media root in use
    // Utility functions

    function showNotification(message, type = 'info') {
        // Use the existing notification system if available
        if (window.notify?.toast) {
            window.notify.toast({
                type: type === 'error' ? 'error' : type === 'success' ? 'success' : 'info',
                title: type.charAt(0).toUpperCase() + type.slice(1),
                message: message,
                duration: type === 'error' ? 5000 : 3500,
            });
        } else {
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
    }

    // Internal helper for delete (file or directory contents)
    function deletePath(path, type = 'file') {
        const opType = type === 'directory' ? 'delete-contents' : 'delete';
        const payload = {
            operations: [{ type: opType, path }],
            dryRun: false,
        };
        fetch('/api/local/cleanup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
        })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    if (opType === 'delete-contents') {
                        const op = Array.isArray(result.results?.operations)
                            ? result.results.operations.find(o => o.path === path)
                            : null;
                        const count = op?.deletedCount ?? 0;
                        showNotification(
                            `Folder contents deleted (${count} entr${count === 1 ? 'y' : 'ies'})`,
                            'success'
                        );
                    } else {
                        showNotification('File deleted successfully', 'success');
                    }
                    refreshDirectorySafe();
                } else {
                    showNotification(result.message || result.error || 'Delete failed', 'error');
                }
            })
            .catch(error => {
                console.error('Delete error:', error);
                showNotification('Delete failed', 'error');
            });
    }

    function createFolder() {
        // Disabled in fixed-directory maintenance mode
        showNotification('Creating folders is disabled in this mode', 'info');
        return;
    }

    function deleteSelected() {
        if (selectedFiles.size === 0) return;

        const paths = Array.from(selectedFiles);
        const message = `This will permanently delete ${paths.length} selected item(s).`;
        const ask = window.confirmAction || (() => Promise.resolve(confirm(message)));
        ask({
            title: 'Delete selected',
            message,
            okText: 'Delete',
            okClass: 'btn-error',
            okIcon: 'trash',
        }).then(ok => {
            if (!ok) return;

            const payload = {
                operations: paths.map(p => ({ type: 'delete', path: p })),
                dryRun: false,
            };

            fetch('/api/local/cleanup', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            })
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        showNotification('Selected items deleted successfully', 'success');
                        selectedFiles.clear();
                        refreshDirectorySafe(true);
                        // Re-evaluate Posterpack filters visibility after clearing selection
                        try {
                            const sourceSelect = document.getElementById('posterpack.source');
                            if (sourceSelect) handleSourceSelection({ target: sourceSelect });
                        } catch (_) {
                            /* jellyfin all-genres fallback failed; continue */
                        }
                    } else {
                        showNotification(
                            result.message || result.error || 'Delete failed',
                            'error'
                        );
                    }
                })
                .catch(error => {
                    console.error('Delete error:', error);
                    showNotification('Delete failed', 'error');
                });
        });
    }

    // Expose helpers to window for reuse and to avoid unused warnings
    try {
        window.deletePath = deletePath;
        window.deleteSelected = deleteSelected;
        window.createFolder = createFolder; // still disabled, but callable
    } catch (_) {
        /* exposing helpers to window is optional */
    }

    function clearCompletedJobs() {
        // Client-side cleanup only in maintenance mode
        const jobsList = document.getElementById('local-job-list');
        if (!jobsList) return;
        let removed = 0;
        jobsList.querySelectorAll('.job-item').forEach(item => {
            const statusEl = item.querySelector('.job-status');
            const st = statusEl?.textContent?.trim()?.toUpperCase?.() || '';
            if (st === 'COMPLETED' || st === 'FAILED' || st === 'CANCELLED') {
                item.remove();
                removed++;
            }
        });
        showNotification(`${removed} completed job(s) cleared`, 'success');
    }
})();
